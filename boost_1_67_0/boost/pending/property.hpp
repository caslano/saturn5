//  (C) Copyright Jeremy Siek 2004
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_PROPERTY_HPP
#define BOOST_PROPERTY_HPP

#include <boost/mpl/bool.hpp>
#include <boost/mpl/if.hpp>
#include <boost/mpl/has_xxx.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/type_traits.hpp>
#include <boost/static_assert.hpp>

namespace boost
{

struct no_property
{
};

template < class Tag, class T, class Base = no_property > struct property
{
    typedef Base next_type;
    typedef Tag tag_type;
    typedef T value_type;
    property(const T& v = T()) : m_value(v) {}
    property(const T& v, const Base& b) : m_value(v), m_base(b) {}
    // copy constructor and assignment operator will be generated by compiler

    T m_value;
    Base m_base;
};

// Kinds of properties
namespace graph_introspect_detail
{
    BOOST_MPL_HAS_XXX_TRAIT_DEF(kind)
    template < typename T, bool Cond > struct get_kind
    {
        typedef void type;
    };
    template < typename T > struct get_kind< T, true >
    {
        typedef typename T::kind type;
    };
}

// Having a default is to make this trait work for any type, not just valid
// properties, to work around VC++ <= 10 bugs related to SFINAE in
// compressed_sparse_row_graph's get functions and similar
template < class PropertyTag >
struct property_kind
: graph_introspect_detail::get_kind< PropertyTag,
      graph_introspect_detail::has_kind< PropertyTag >::value >
{
};

// Some standard properties defined independently of Boost.Graph:
enum vertex_all_t
{
    vertex_all
};
enum edge_all_t
{
    edge_all
};
enum graph_all_t
{
    graph_all
};
enum vertex_bundle_t
{
    vertex_bundle
};
enum edge_bundle_t
{
    edge_bundle
};
enum graph_bundle_t
{
    graph_bundle
};

// Code to look up one property in a property list:
template < typename PList, typename PropName, typename Enable = void >
struct lookup_one_property_internal
{
    BOOST_STATIC_CONSTANT(bool, found = false);
    typedef void type;
};

// Special-case properties (vertex_all, edge_all, graph_all)
#define BGL_ALL_PROP(tag)                                                 \
    template < typename T > struct lookup_one_property_internal< T, tag > \
    {                                                                     \
        BOOST_STATIC_CONSTANT(bool, found = true);                        \
        typedef T type;                                                   \
        static T& lookup(T& x, tag) { return x; }                         \
        static const T& lookup(const T& x, tag) { return x; }             \
    };                                                                    \
    template < typename Tag, typename T, typename Base >                  \
    struct lookup_one_property_internal< property< Tag, T, Base >, tag >  \
    { /* Avoid ambiguity */                                               \
        BOOST_STATIC_CONSTANT(bool, found = true);                        \
        typedef property< Tag, T, Base > type;                            \
        static type& lookup(type& x, tag) { return x; }                   \
        static const type& lookup(const type& x, tag) { return x; }       \
    };

BGL_ALL_PROP(vertex_all_t)
BGL_ALL_PROP(edge_all_t)
BGL_ALL_PROP(graph_all_t)
#undef BGL_ALL_PROP

// *_bundled; these need to be macros rather than inheritance to resolve
// ambiguities
#define BGL_DO_ONE_BUNDLE_TYPE(kind)                                           \
    template < typename T >                                                    \
    struct lookup_one_property_internal< T, BOOST_JOIN(kind, _bundle_t) >      \
    {                                                                          \
        BOOST_STATIC_CONSTANT(bool, found = true);                             \
        typedef T type;                                                        \
        static T& lookup(T& x, BOOST_JOIN(kind, _bundle_t)) { return x; }      \
        static const T& lookup(const T& x, BOOST_JOIN(kind, _bundle_t))        \
        {                                                                      \
            return x;                                                          \
        }                                                                      \
    };                                                                         \
                                                                               \
    template < typename Tag, typename T, typename Base >                       \
    struct lookup_one_property_internal< property< Tag, T, Base >,             \
        BOOST_JOIN(kind, _bundle_t) >                                          \
    : lookup_one_property_internal< Base, BOOST_JOIN(kind, _bundle_t) >        \
    {                                                                          \
    private:                                                                   \
        typedef lookup_one_property_internal< Base,                            \
            BOOST_JOIN(kind, _bundle_t) >                                      \
            base_type;                                                         \
                                                                               \
    public:                                                                    \
        template < typename BundleTag >                                        \
        static typename lazy_enable_if_c<                                      \
            (base_type::found                                                  \
                && (is_same< BundleTag,                                        \
                    BOOST_JOIN(kind, _bundle_t) >::value)),                    \
            add_reference< typename base_type::type > >::type                  \
        lookup(property< Tag, T, Base >& p, BundleTag)                         \
        {                                                                      \
            return base_type::lookup(p.m_base, BOOST_JOIN(kind, _bundle_t)()); \
        }                                                                      \
        template < typename BundleTag >                                        \
        static typename lazy_enable_if_c<                                      \
            (base_type::found                                                  \
                && (is_same< BundleTag,                                        \
                    BOOST_JOIN(kind, _bundle_t) >::value)),                    \
            add_reference< const typename base_type::type > >::type            \
        lookup(const property< Tag, T, Base >& p, BundleTag)                   \
        {                                                                      \
            return base_type::lookup(p.m_base, BOOST_JOIN(kind, _bundle_t)()); \
        }                                                                      \
    };

BGL_DO_ONE_BUNDLE_TYPE(vertex)
BGL_DO_ONE_BUNDLE_TYPE(edge)
BGL_DO_ONE_BUNDLE_TYPE(graph)
#undef BGL_DO_ONE_BUNDLE_TYPE

// Normal old-style properties; second case also handles chaining of bundled
// property accesses
template < typename Tag, typename T, typename Base >
struct lookup_one_property_internal< boost::property< Tag, T, Base >, Tag >
{
    BOOST_STATIC_CONSTANT(bool, found = true);
    typedef property< Tag, T, Base > prop;
    typedef T type;
    template < typename U >
    static typename enable_if< is_same< prop, U >, T& >::type lookup(
        U& prop, const Tag&)
    {
        return prop.m_value;
    }
    template < typename U >
    static typename enable_if< is_same< prop, U >, const T& >::type lookup(
        const U& prop, const Tag&)
    {
        return prop.m_value;
    }
};

template < typename Tag, typename T, typename Base, typename PropName >
struct lookup_one_property_internal< boost::property< Tag, T, Base >, PropName >
: lookup_one_property_internal< Base, PropName >
{
private:
    typedef lookup_one_property_internal< Base, PropName > base_type;

public:
    template < typename PL >
    static
        typename lazy_enable_if< is_same< PL, boost::property< Tag, T, Base > >,
            add_reference< typename base_type::type > >::type
        lookup(PL& prop, const PropName& tag)
    {
        return base_type::lookup(prop.m_base, tag);
    }
    template < typename PL >
    static
        typename lazy_enable_if< is_same< PL, boost::property< Tag, T, Base > >,
            add_reference< const typename base_type::type > >::type
        lookup(const PL& prop, const PropName& tag)
    {
        return base_type::lookup(prop.m_base, tag);
    }
};

// Pointer-to-member access to bundled properties
#ifndef BOOST_GRAPH_NO_BUNDLED_PROPERTIES
template < typename T, typename TMaybeBase, typename R >
struct lookup_one_property_internal< T, R TMaybeBase::*,
    typename enable_if< is_base_of< TMaybeBase, T > >::type >
{
    BOOST_STATIC_CONSTANT(bool, found = true);
    typedef R type;
    static R& lookup(T& x, R TMaybeBase::*ptr) { return x.*ptr; }
    static const R& lookup(const T& x, R TMaybeBase::*ptr) { return x.*ptr; }
};
#endif

// Version of above handling const property lists properly
template < typename T, typename Tag >
struct lookup_one_property : lookup_one_property_internal< T, Tag >
{
};

template < typename T, typename Tag > struct lookup_one_property< const T, Tag >
{
    BOOST_STATIC_CONSTANT(
        bool, found = (lookup_one_property_internal< T, Tag >::found));
    typedef const typename lookup_one_property_internal< T, Tag >::type type;
    template < typename U >
    static typename lazy_enable_if< is_same< T, U >,
        add_reference< const typename lookup_one_property_internal< T,
            Tag >::type > >::type
    lookup(const U& p, Tag tag)
    {
        return lookup_one_property_internal< T, Tag >::lookup(p, tag);
    }
};

// The BGL properties specialize property_kind and
// property_num, and use enum's for the Property type (see
// graph/properties.hpp), but the user may want to use a class
// instead with a nested kind type and num.  Also, we may want to
// switch BGL back to using class types for properties at some point.

template < class P > struct has_property : boost::mpl::true_
{
};
template <> struct has_property< no_property > : boost::mpl::false_
{
};

} // namespace boost

#include <boost/pending/detail/property.hpp>

namespace boost
{

template < class PropertyList, class Tag >
struct property_value : lookup_one_property< PropertyList, Tag >
{
};

template < class PropertyList, class Tag >
inline typename lookup_one_property< PropertyList, Tag >::type&
get_property_value(PropertyList& p, Tag tag)
{
    return lookup_one_property< PropertyList, Tag >::lookup(p, tag);
}

template < class PropertyList, class Tag >
inline const typename lookup_one_property< PropertyList, Tag >::type&
get_property_value(const PropertyList& p, Tag tag)
{
    return lookup_one_property< PropertyList, Tag >::lookup(p, tag);
}

namespace detail
{

    /** This trait returns true if T is no_property. */
    template < typename T >
    struct is_no_property : mpl::bool_< is_same< T, no_property >::value >
    {
    };

    template < typename PList, typename Tag > class lookup_one_property_f;

    template < typename PList, typename Tag, typename F >
    struct lookup_one_property_f_result;

    template < typename PList, typename Tag >
    struct lookup_one_property_f_result< PList, Tag,
        const lookup_one_property_f< PList, Tag >(PList) >
    {
        typedef typename lookup_one_property< PList, Tag >::type type;
    };

    template < typename PList, typename Tag >
    struct lookup_one_property_f_result< PList, Tag,
        const lookup_one_property_f< PList, Tag >(PList&) >
    {
        typedef typename lookup_one_property< PList, Tag >::type& type;
    };

    template < typename PList, typename Tag >
    struct lookup_one_property_f_result< PList, Tag,
        const lookup_one_property_f< PList, Tag >(const PList&) >
    {
        typedef const typename lookup_one_property< PList, Tag >::type& type;
    };

    template < typename PList, typename Tag > class lookup_one_property_f
    {
        Tag tag;

    public:
        lookup_one_property_f(Tag tag) : tag(tag) {}
        template < typename F >
        struct result : lookup_one_property_f_result< PList, Tag, F >
        {
        };

        typename lookup_one_property_f_result< PList, Tag,
            const lookup_one_property_f(PList&) >::type
        operator()(PList& pl) const
        {
            return lookup_one_property< PList, Tag >::lookup(pl, tag);
        }
    };

} // namespace detail

namespace detail
{
    // Stuff for directed_graph and undirected_graph to skip over their first
    // vertex_index and edge_index properties when providing vertex_all and
    // edge_all; make sure you know the exact structure of your properties if
    // you use there.
    struct remove_first_property
    {
        template < typename F > struct result
        {
            typedef typename boost::function_traits< F >::arg1_type a1;
            typedef typename boost::remove_reference< a1 >::type non_ref;
            typedef typename non_ref::next_type nx;
            typedef typename boost::mpl::if_< boost::is_const< non_ref >,
                boost::add_const< nx >, nx >::type with_const;
            typedef typename boost::add_reference< with_const >::type type;
        };
        template < typename Prop >
        typename Prop::next_type& operator()(Prop& p) const
        {
            return p.m_base;
        }
        template < typename Prop >
        const typename Prop::next_type& operator()(const Prop& p) const
        {
            return p.m_base;
        }
    };
}

} // namesapce boost

#endif /* BOOST_PROPERTY_HPP */

/* property.hpp
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
*/