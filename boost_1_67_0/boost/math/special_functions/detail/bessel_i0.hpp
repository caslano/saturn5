//  Copyright (c) 2006 Xiaogang Zhang
//  Copyright (c) 2017 John Maddock
//  Use, modification and distribution are subject to the
//  Boost Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_MATH_BESSEL_I0_HPP
#define BOOST_MATH_BESSEL_I0_HPP

#ifdef _MSC_VER
#pragma once
#endif

#include <boost/math/tools/rational.hpp>
#include <boost/math/tools/big_constant.hpp>
#include <boost/assert.hpp>

#if defined(__GNUC__) && defined(BOOST_MATH_USE_FLOAT128)
//
// This is the only way we can avoid
// warning: non-standard suffix on floating constant [-Wpedantic]
// when building with -Wall -pedantic.  Neither __extension__
// nor #pragma diagnostic ignored work :(
//
#pragma GCC system_header
#endif

// Modified Bessel function of the first kind of order zero
// we use the approximating forms derived in:
// "Rational Approximations for the Modified Bessel Function of the First Kind - I0(x) for Computations with Double Precision"
// by Pavel Holoborodko, 
// see http://www.advanpix.com/2015/11/11/rational-approximations-for-the-modified-bessel-function-of-the-first-kind-i0-computations-double-precision
// The actual coefficients used are our own, and extend Pavel's work to precision's other than double.

namespace boost { namespace math { namespace detail{

template <typename T>
T bessel_i0(const T& x);

template <class T, class tag>
struct bessel_i0_initializer
{
   struct init
   {
      init()
      {
         do_init(tag());
      }
      static void do_init(const boost::integral_constant<int, 64>&)
      {
         bessel_i0(T(1));
         bessel_i0(T(8));
         bessel_i0(T(12));
         bessel_i0(T(40));
         bessel_i0(T(101));
      }
      static void do_init(const boost::integral_constant<int, 113>&)
      {
         bessel_i0(T(1));
         bessel_i0(T(10));
         bessel_i0(T(20));
         bessel_i0(T(40));
         bessel_i0(T(101));
      }
      template <class U>
      static void do_init(const U&) {}
      void force_instantiate()const {}
   };
   static const init initializer;
   static void force_instantiate()
   {
      initializer.force_instantiate();
   }
};

template <class T, class tag>
const typename bessel_i0_initializer<T, tag>::init bessel_i0_initializer<T, tag>::initializer;

template <typename T, int N>
T bessel_i0_imp(const T&, const boost::integral_constant<int, N>&)
{
   BOOST_ASSERT(0);
   return 0;
}

template <typename T>
T bessel_i0_imp(const T& x, const boost::integral_constant<int, 24>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Max error in interpolated form: 3.929e-08
      // Max Error found at float precision = Poly: 1.991226e-07
      static const float P[] = {
         1.00000003928615375e+00f,
         2.49999576572179639e-01f,
         2.77785268558399407e-02f,
         1.73560257755821695e-03f,
         6.96166518788906424e-05f,
         1.89645733877137904e-06f,
         4.29455004657565361e-08f,
         3.90565476357034480e-10f,
         1.48095934745267240e-11f
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 50)
   {
      // Max error in interpolated form: 5.195e-08
      // Max Error found at float precision = Poly: 8.502534e-08
      static const float P[] = {
         3.98942651588301770e-01f,
         4.98327234176892844e-02f,
         2.91866904423115499e-02f,
         1.35614940793742178e-02f,
         1.31409251787866793e-01f
      };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else
   {
      // Max error in interpolated form: 1.782e-09
      // Max Error found at float precision = Poly: 6.473568e-08
      static const float P[] = {
         3.98942391532752700e-01f,
         4.98455950638200020e-02f,
         2.94835666900682535e-02f
      };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const boost::integral_constant<int, 53>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Bessel I0 over[10 ^ -16, 7.75]
      // Max error in interpolated form : 3.042e-18
      // Max Error found at double precision = Poly : 5.106609e-16 Cheb : 5.239199e-16
      static const double P[] = {
         1.00000000000000000e+00,
         2.49999999999999909e-01,
         2.77777777777782257e-02,
         1.73611111111023792e-03,
         6.94444444453352521e-05,
         1.92901234513219920e-06,
         3.93675991102510739e-08,
         6.15118672704439289e-10,
         7.59407002058973446e-12,
         7.59389793369836367e-14,
         6.27767773636292611e-16,
         4.34709704153272287e-18,
         2.63417742690109154e-20,
         1.13943037744822825e-22,
         9.07926920085624812e-25
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 500)
   {
      // Max error in interpolated form : 1.685e-16
      // Max Error found at double precision = Poly : 2.575063e-16 Cheb : 2.247615e+00
      static const double P[] = {
         3.98942280401425088e-01,
         4.98677850604961985e-02,
         2.80506233928312623e-02,
         2.92211225166047873e-02,
         4.44207299493659561e-02,
         1.30970574605856719e-01,
         -3.35052280231727022e+00,
         2.33025711583514727e+02,
         -1.13366350697172355e+04,
         4.24057674317867331e+05,
         -1.23157028595698731e+07,
         2.80231938155267516e+08,
         -5.01883999713777929e+09,
         7.08029243015109113e+10,
         -7.84261082124811106e+11,
         6.76825737854096565e+12,
         -4.49034849696138065e+13,
         2.24155239966958995e+14,
         -8.13426467865659318e+14,
         2.02391097391687777e+15,
         -3.08675715295370878e+15,
         2.17587543863819074e+15
      };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else
   {
      // Max error in interpolated form : 2.437e-18
      // Max Error found at double precision = Poly : 1.216719e-16
      static const double P[] = {
         3.98942280401432905e-01,
         4.98677850491434560e-02,
         2.80506308916506102e-02,
         2.92179096853915176e-02,
         4.53371208762579442e-02
      };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const boost::integral_constant<int, 64>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Bessel I0 over[10 ^ -16, 7.75]
      // Max error in interpolated form : 3.899e-20
      // Max Error found at float80 precision = Poly : 1.770840e-19
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.99999999999999999961011629e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.50000000000000001321873912e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.77777777777777703400424216e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.73611111111112764793802701e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.94444444444251461247253525e-05),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.92901234569262206386118739e-06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.93675988851131457141005209e-08),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.15118734688297476454205352e-10),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.59405797058091016449222685e-12),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.59406599631719800679835140e-14),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.27598961062070013516660425e-16),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.35920318970387940278362992e-18),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.57372492687715452949437981e-20),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.33908663475949906992942204e-22),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.15976668870980234582896010e-25),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.46240478946376069211156548e-27)
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 10)
   {
      // Maximum Deviation Found:                     6.906e-21
      // Expected Error Term : -6.903e-21
      // Maximum Relative Change in Control Points : 1.631e-04
      // Max Error found at float80 precision = Poly : 7.811948e-21
      static const T Y = 4.051098823547363281250e-01f;
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, -6.158081780620616479492e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.883635969834048766148e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.892782002476195771920e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.478784996478070170327e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.988611837308006851257e+01),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.140133766747436806179e+02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.117316447921276453271e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.942353667455141676001e+04),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.493482682461387081534e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, -5.228100538921466124653e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.195279248600467989454e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.601530760654337045917e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.504921137873298402679e+05)
      };
      return exp(x) * (boost::math::tools::evaluate_polynomial(P, T(1 / x)) + Y) / sqrt(x);
   }
   else if(x < 15)
   {
      // Maximum Deviation Found:                     4.083e-21
      // Expected Error Term : -4.025e-21
      // Maximum Relative Change in Control Points : 1.304e-03
      // Max Error found at float80 precision = Poly : 2.303527e-20
      static const T Y = 4.033188819885253906250e-01f;
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.376373876116109401062e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.982899138682911273321e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.109477529533515397644e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.163760580110576407673e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.776501832837367371883e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.101478069227776656318e+02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.892071912448960299773e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.417739279982328117483e+04),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.296963447724067390552e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.598589306710589358747e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.903662411851774878322e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.622677059040339516093e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.227776578828667629347e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.727797957441040896878e+07)
      };
      return exp(x) * (boost::math::tools::evaluate_polynomial(P, T(1 / x)) + Y) / sqrt(x);
   }
   else if(x < 50)
   {
      // Max error in interpolated form: 1.035e-21
      // Max Error found at float80 precision = Poly: 1.885872e-21
      static const T Y = 4.011702537536621093750e-01f;
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.227973351806078464328e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.986778486088017419036e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.805066823812285310011e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.921443721160964964623e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.517504941996594744052e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.316922639868793684401e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.535891099168810015433e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.706078229522448308087e+01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.351015763079160914632e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.948809013999277355098e+04),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.967598958582595361757e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, -6.346924657995383019558e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.998794574259956613472e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.016371355801690142095e+08),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.768791455631826490838e+09),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.441995678177349895640e+09),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.482292669974971387738e+09)
      };
      return exp(x) * (boost::math::tools::evaluate_polynomial(P, T(1 / x)) + Y) / sqrt(x);
   }
   else
   {
      // Bessel I0 over[50, INF]
      // Max error in interpolated form : 5.587e-20
      // Max Error found at float80 precision = Poly : 8.776852e-20
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.98942280401432677955074061e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.98677850501789875615574058e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.80506290908675604202206833e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.92194052159035901631494784e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.47422430732256364094681137e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.05971614435738691235525172e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.29180522595459823234266708e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.15122547776140254569073131e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.48491812136365376477357324e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.45569740166506688169730713e+02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.66857566379480730407063170e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.71924083955641197750323901e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.74276685704579268845870586e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, -8.89753803265734681907148778e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.82590905134996782086242180e+08),
         BOOST_MATH_BIG_CONSTANT(T, 64, -7.30623197145529889358596301e+09),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.27310000726207055200805893e+10),
         BOOST_MATH_BIG_CONSTANT(T, 64, -6.64365417189215599168817064e+10)
      };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const boost::integral_constant<int, 113>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Bessel I0 over[10 ^ -34, 7.75]
      // Max error in interpolated form : 1.274e-34
      // Max Error found at float128 precision = Poly : 3.096091e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.0000000000000000000000000000000001273856e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4999999999999999999999999999999107477496e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7777777777777777777777777777881795230918e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.7361111111111111111111111106290091648808e-03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.9444444444444444444444445629960334523101e-05),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.9290123456790123456790105563456483249753e-06),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9367598891408415217940836339080514004844e-08),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.1511873267825648777900014857992724731476e-10),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281266233066162999610732449709209e-12),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281266232783124723601470051895304e-14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.2760813455591936763439337059117957836078e-16),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.3583898233049738471136482147779094353096e-18),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5789288895299965395422423848480340736308e-20),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.3157800456718804437960453545507623434606e-22),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.8479113149412360748032684260932041506493e-25),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2843403488398038539283241944594140493394e-27),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.9042925594356556196790242908697582021825e-30),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4395919891312152120710245152115597111101e-32),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.7580986145276689333214547502373003196707e-35),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.6886514018062348877723837017198859723889e-37),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.8540558465757554512570197585002702777999e-40),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.4684706070226893763741850944911705726436e-43),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.0210715309399646335858150349406935414314e-45)
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 15)
   {
      // Bessel I0 over[7.75, 15]
      // Max error in interpolated form : 7.534e-35
      // Max Error found at float128 precision = Poly : 6.123912e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.9999999999999999992388573069504617493518e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5000000000000000007304739268173096975340e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7777777777777777744261405400543564492074e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.7361111111111111209006987259719750726867e-03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.9444444444444442399703186871329381908321e-05),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.9290123456790126709286741580242189785431e-06),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9367598891408374246503061422528266924389e-08),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.1511873267826068395343047827801353170966e-10),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281262673459688011737168286944521e-12),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281291583769928563167645746144508e-14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.2760813455438840231126529638737436950274e-16),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.3583898233839583885132809584770578894948e-18),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5789288891798658971960571838369339742994e-20),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.3157800470129311623308216856009970266088e-22),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.8479112701534604520063520412207286692581e-25),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2843404822552330714586265081801727491890e-27),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.9042888166225242675881424439818162458179e-30),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4396027771820721384198604723320045236973e-32),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.7577659910606076328136207973456511895030e-35),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.6896548123724136624716224328803899914646e-37),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.8285850162160539150210466453921758781984e-40),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.9419071894227736216423562425429524883562e-43),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.4720374049498608905571855665134539425038e-45),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7763533278527958112907118930154738930378e-48),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.1213839473168678646697528580511702663617e-51),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.0648035313124146852372607519737686740964e-53),
         -BOOST_MATH_BIG_CONSTANT(T, 113, 5.1255595184052024349371058585102280860878e-57),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.4652470895944157957727948355523715335882e-59)
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 30)
   {
      // Max error in interpolated form : 1.808e-34
      // Max Error found at float128 precision = Poly : 2.399403e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9894228040870793650581242239624530714032e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.9867780576714783790784348982178607842250e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8051948347934462928487999569249907599510e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8971143420388958551176254291160976367263e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.8197359701715582763961322341827341098897e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.3430484862908317377522273217643346601271e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7884507603213662610604413960838990199224e+02),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.8304926482356755790062999202373909300514e+04),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.8867173178574875515293357145875120137676e+05),
         BOOST_MATH_BIG_CONSTANT(T, 113, -4.4261178812193528551544261731796888257644e+07),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.6453010340778116475788083817762403540097e+09),
         BOOST_MATH_BIG_CONSTANT(T, 113, -5.0432401330113978669454035365747869477960e+10),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.2462165331309799059332310595587606836357e+12),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.3299800389951335932792950236410844978273e+13),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5748218240248714177527965706790413406639e+14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.8330014378766930869945511450377736037385e+15),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.8494610073827453236940544799030787866218e+17),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.7244661371420647691301043350229977856476e+18),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.2386378807889388140099109087465781254321e+20),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.1104000573102013529518477353943384110982e+21),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.9426541092239879262282594572224300191016e+22),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.4061439136301913488512592402635688101020e+23),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.2836554760521986358980180942859101564671e+24),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.6270285589905206294944214795661236766988e+25),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.7278631455211972017740134341610659484259e+26),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.1971734473772196124736986948034978906801e+26),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.8669270707172568763908838463689093500098e+27),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.2368879358870281916900125550129211146626e+28),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.8296235063297831758204519071113999839858e+28),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.1253861666023020670144616019148954773662e+28),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.8809536950051955163648980306847791014734e+28) };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else if(x < 100)
   {
      // Bessel I0 over[30, 100]
      // Max error in interpolated form : 1.487e-34
      // Max Error found at float128 precision = Poly : 1.929924e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9894228040143267793996798658172135362278e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.9867785050179084714910130342157246539820e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8050629090725751585266360464766768437048e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.9219405302833158254515212437025679637597e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.4742214371598631578107310396249912330627e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.0602983776478659136184969363625092585520e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2839507231977478205885469900971893734770e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.8925739165733823730525449511456529001868e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4238082222874015159424842335385854632223e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.6759648427182491050716309699208988458050e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.7292246491169360014875196108746167872215e+01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.1001411442786230340015781205680362993575e+01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.8277628835804873490331739499978938078848e+03),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.1208326312801432038715638596517882759639e+05),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.4813611580683862051838126076298945680803e+06),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.1278197693321821164135890132925119054391e+08),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.3190303792682886967459489059860595063574e+09),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.1580767338646580750893606158043485767644e+10),
         BOOST_MATH_BIG_CONSTANT(T, 113, -5.0256008808415702780816006134784995506549e+11),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.9044186472918017896554580836514681614475e+13),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.2521078890073151875661384381880225635135e+14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.3620352486836976842181057590770636605454e+15),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.0375525734060401555856465179734887312420e+16),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.6392664899881014534361728644608549445131e+16)
      };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else
   {
      // Bessel I0 over[100, INF]
      // Max error in interpolated form : 5.459e-35
      // Max Error found at float128 precision = Poly : 1.472240e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9894228040143267793994605993438166526772e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.9867785050179084742493257495245185241487e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8050629090725735167652437695397756897920e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.9219405302839307466358297347675795965363e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.4742214369972689474366968442268908028204e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.0602984099194778006610058410222616383078e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2839502241666629677015839125593079416327e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.8926354981801627920292655818232972385750e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4231921590621824187100989532173995000655e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.7264260959693775207585700654645245723497e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.3890136225398811195878046856373030127018e+01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.1999720924619285464910452647408431234369e+02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.2076909538525038580501368530598517194748e+03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5684635141332367730007149159063086133399e+03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.5178192543258299267923025833141286569141e+04),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.2966297919851965784482163987240461837728e+05) };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const boost::integral_constant<int, 0>&)
{
   if(boost::math::tools::digits<T>() <= 24)
      return bessel_i0_imp(x, boost::integral_constant<int, 24>());
   else if(boost::math::tools::digits<T>() <= 53)
      return bessel_i0_imp(x, boost::integral_constant<int, 53>());
   else if(boost::math::tools::digits<T>() <= 64)
      return bessel_i0_imp(x, boost::integral_constant<int, 64>());
   else if(boost::math::tools::digits<T>() <= 113)
      return bessel_i0_imp(x, boost::integral_constant<int, 113>());
   BOOST_ASSERT(0);
   return 0;
}

template <typename T>
inline T bessel_i0(const T& x)
{
   typedef boost::integral_constant<int,
      ((std::numeric_limits<T>::digits == 0) || (std::numeric_limits<T>::radix != 2)) ?
      0 :
      std::numeric_limits<T>::digits <= 24 ?
      24 :
      std::numeric_limits<T>::digits <= 53 ?
      53 :
      std::numeric_limits<T>::digits <= 64 ?
      64 :
      std::numeric_limits<T>::digits <= 113 ?
      113 : -1
   > tag_type;

   bessel_i0_initializer<T, tag_type>::force_instantiate();
   return bessel_i0_imp(x, tag_type());
}

}}} // namespaces

#endif // BOOST_MATH_BESSEL_I0_HPP


/* bessel_i0.hpp
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
*/