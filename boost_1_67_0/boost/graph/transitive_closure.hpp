// Copyright (C) 2001 Vladimir Prus <ghost@cs.msu.su>
// Copyright (C) 2001 Jeremy Siek <jsiek@cs.indiana.edu>
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// NOTE: this final is generated by libs/graph/doc/transitive_closure.w

#ifndef BOOST_GRAPH_TRANSITIVE_CLOSURE_HPP
#define BOOST_GRAPH_TRANSITIVE_CLOSURE_HPP

#include <vector>
#include <algorithm> // for std::min and std::max
#include <functional>
#include <boost/config.hpp>
#include <boost/bind.hpp>
#include <boost/graph/strong_components.hpp>
#include <boost/graph/topological_sort.hpp>
#include <boost/graph/graph_concepts.hpp>
#include <boost/graph/named_function_params.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/concept/assert.hpp>

namespace boost
{

namespace detail
{
    inline void union_successor_sets(const std::vector< std::size_t >& s1,
        const std::vector< std::size_t >& s2, std::vector< std::size_t >& s3)
    {
        BOOST_USING_STD_MIN();
        for (std::size_t k = 0; k < s1.size(); ++k)
            s3[k] = min BOOST_PREVENT_MACRO_SUBSTITUTION(s1[k], s2[k]);
    }
} // namespace detail

namespace detail
{
    template < typename TheContainer, typename ST = std::size_t,
        typename VT = typename TheContainer::value_type >
    struct subscript_t
    {
        typedef ST argument_type;
        typedef VT& result_type;

        subscript_t(TheContainer& c) : container(&c) {}
        VT& operator()(const ST& i) const { return (*container)[i]; }

    protected:
        TheContainer* container;
    };
    template < typename TheContainer >
    subscript_t< TheContainer > subscript(TheContainer& c)
    {
        return subscript_t< TheContainer >(c);
    }
} // namespace detail

template < typename Graph, typename GraphTC, typename G_to_TC_VertexMap,
    typename VertexIndexMap >
void transitive_closure(const Graph& g, GraphTC& tc,
    G_to_TC_VertexMap g_to_tc_map, VertexIndexMap index_map)
{
    if (num_vertices(g) == 0)
        return;
    typedef typename graph_traits< Graph >::vertex_descriptor vertex;
    typedef typename graph_traits< Graph >::vertex_iterator vertex_iterator;
    typedef typename property_traits< VertexIndexMap >::value_type size_type;
    typedef
        typename graph_traits< Graph >::adjacency_iterator adjacency_iterator;

    BOOST_CONCEPT_ASSERT((VertexListGraphConcept< Graph >));
    BOOST_CONCEPT_ASSERT((AdjacencyGraphConcept< Graph >));
    BOOST_CONCEPT_ASSERT((VertexMutableGraphConcept< GraphTC >));
    BOOST_CONCEPT_ASSERT((EdgeMutableGraphConcept< GraphTC >));
    BOOST_CONCEPT_ASSERT(
        (ReadablePropertyMapConcept< VertexIndexMap, vertex >));

    typedef size_type cg_vertex;
    std::vector< cg_vertex > component_number_vec(num_vertices(g));
    iterator_property_map< cg_vertex*, VertexIndexMap, cg_vertex, cg_vertex& >
        component_number(&component_number_vec[0], index_map);

    int num_scc
        = strong_components(g, component_number, vertex_index_map(index_map));

    std::vector< std::vector< vertex > > components;
    build_component_lists(g, num_scc, component_number, components);

    typedef boost::adjacency_list< boost::vecS, boost::vecS, boost::directedS >
        CG_t;
    CG_t CG(num_scc);
    for (cg_vertex s = 0; s < components.size(); ++s)
    {
        std::vector< cg_vertex > adj;
        for (size_type i = 0; i < components[s].size(); ++i)
        {
            vertex u = components[s][i];
            adjacency_iterator v, v_end;
            for (boost::tie(v, v_end) = adjacent_vertices(u, g); v != v_end;
                 ++v)
            {
                cg_vertex t = component_number[*v];
                if (s != t) // Avoid loops in the condensation graph
                    adj.push_back(t);
            }
        }
        std::sort(adj.begin(), adj.end());
        typename std::vector< cg_vertex >::iterator di
            = std::unique(adj.begin(), adj.end());
        if (di != adj.end())
            adj.erase(di, adj.end());
        for (typename std::vector< cg_vertex >::const_iterator i = adj.begin();
             i != adj.end(); ++i)
        {
            add_edge(s, *i, CG);
        }
    }

    std::vector< cg_vertex > topo_order;
    std::vector< cg_vertex > topo_number(num_vertices(CG));
    topological_sort(CG, std::back_inserter(topo_order),
        vertex_index_map(identity_property_map()));
    std::reverse(topo_order.begin(), topo_order.end());
    size_type n = 0;
    for (typename std::vector< cg_vertex >::iterator iter = topo_order.begin();
         iter != topo_order.end(); ++iter)
        topo_number[*iter] = n++;

    std::vector< std::vector< cg_vertex > > CG_vec(num_vertices(CG));
    for (size_type i = 0; i < num_vertices(CG); ++i)
    {
        typedef typename boost::graph_traits< CG_t >::adjacency_iterator
            cg_adj_iter;
        std::pair< cg_adj_iter, cg_adj_iter > pr = adjacent_vertices(i, CG);
        CG_vec[i].assign(pr.first, pr.second);
        std::sort(CG_vec[i].begin(), CG_vec[i].end(),
            boost::bind(std::less< cg_vertex >(),
                boost::bind(detail::subscript(topo_number), _1),
                boost::bind(detail::subscript(topo_number), _2)));
    }

    std::vector< std::vector< cg_vertex > > chains;
    {
        std::vector< cg_vertex > in_a_chain(CG_vec.size());
        for (typename std::vector< cg_vertex >::iterator i = topo_order.begin();
             i != topo_order.end(); ++i)
        {
            cg_vertex v = *i;
            if (!in_a_chain[v])
            {
                chains.resize(chains.size() + 1);
                std::vector< cg_vertex >& chain = chains.back();
                for (;;)
                {
                    chain.push_back(v);
                    in_a_chain[v] = true;
                    typename std::vector< cg_vertex >::const_iterator next
                        = std::find_if(CG_vec[v].begin(), CG_vec[v].end(),
                            std::not1(detail::subscript(in_a_chain)));
                    if (next != CG_vec[v].end())
                        v = *next;
                    else
                        break; // end of chain, dead-end
                }
            }
        }
    }
    std::vector< size_type > chain_number(CG_vec.size());
    std::vector< size_type > pos_in_chain(CG_vec.size());
    for (size_type i = 0; i < chains.size(); ++i)
        for (size_type j = 0; j < chains[i].size(); ++j)
        {
            cg_vertex v = chains[i][j];
            chain_number[v] = i;
            pos_in_chain[v] = j;
        }

    cg_vertex inf = (std::numeric_limits< cg_vertex >::max)();
    std::vector< std::vector< cg_vertex > > successors(
        CG_vec.size(), std::vector< cg_vertex >(chains.size(), inf));
    for (typename std::vector< cg_vertex >::reverse_iterator i
         = topo_order.rbegin();
         i != topo_order.rend(); ++i)
    {
        cg_vertex u = *i;
        typename std::vector< cg_vertex >::const_iterator adj, adj_last;
        for (adj = CG_vec[u].begin(), adj_last = CG_vec[u].end();
             adj != adj_last; ++adj)
        {
            cg_vertex v = *adj;
            if (topo_number[v] < successors[u][chain_number[v]])
            {
                // Succ(u) = Succ(u) U Succ(v)
                detail::union_successor_sets(
                    successors[u], successors[v], successors[u]);
                // Succ(u) = Succ(u) U {v}
                successors[u][chain_number[v]] = topo_number[v];
            }
        }
    }

    for (size_type i = 0; i < CG_vec.size(); ++i)
        CG_vec[i].clear();
    for (size_type i = 0; i < CG_vec.size(); ++i)
        for (size_type j = 0; j < chains.size(); ++j)
        {
            size_type topo_num = successors[i][j];
            if (topo_num < inf)
            {
                cg_vertex v = topo_order[topo_num];
                for (size_type k = pos_in_chain[v]; k < chains[j].size(); ++k)
                    CG_vec[i].push_back(chains[j][k]);
            }
        }

    // Add vertices to the transitive closure graph
    {
        vertex_iterator i, i_end;
        for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i)
            g_to_tc_map[*i] = add_vertex(tc);
    }
    // Add edges between all the vertices in two adjacent SCCs
    typename std::vector< std::vector< cg_vertex > >::const_iterator si, si_end;
    for (si = CG_vec.begin(), si_end = CG_vec.end(); si != si_end; ++si)
    {
        cg_vertex s = si - CG_vec.begin();
        typename std::vector< cg_vertex >::const_iterator i, i_end;
        for (i = CG_vec[s].begin(), i_end = CG_vec[s].end(); i != i_end; ++i)
        {
            cg_vertex t = *i;
            for (size_type k = 0; k < components[s].size(); ++k)
                for (size_type l = 0; l < components[t].size(); ++l)
                    add_edge(g_to_tc_map[components[s][k]],
                        g_to_tc_map[components[t][l]], tc);
        }
    }
    // Add edges connecting all vertices in a SCC
    for (size_type i = 0; i < components.size(); ++i)
        if (components[i].size() > 1)
            for (size_type k = 0; k < components[i].size(); ++k)
                for (size_type l = 0; l < components[i].size(); ++l)
                {
                    vertex u = components[i][k], v = components[i][l];
                    add_edge(g_to_tc_map[u], g_to_tc_map[v], tc);
                }

    // Find loopbacks in the original graph.
    // Need to add it to transitive closure.
    {
        vertex_iterator i, i_end;
        for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i)
        {
            adjacency_iterator ab, ae;
            for (boost::tie(ab, ae) = adjacent_vertices(*i, g); ab != ae; ++ab)
            {
                if (*ab == *i)
                    if (components[component_number[*i]].size() == 1)
                        add_edge(g_to_tc_map[*i], g_to_tc_map[*i], tc);
            }
        }
    }
}

template < typename Graph, typename GraphTC >
void transitive_closure(const Graph& g, GraphTC& tc)
{
    if (num_vertices(g) == 0)
        return;
    typedef typename property_map< Graph, vertex_index_t >::const_type
        VertexIndexMap;
    VertexIndexMap index_map = get(vertex_index, g);

    typedef typename graph_traits< GraphTC >::vertex_descriptor tc_vertex;
    std::vector< tc_vertex > to_tc_vec(num_vertices(g));
    iterator_property_map< tc_vertex*, VertexIndexMap, tc_vertex, tc_vertex& >
        g_to_tc_map(&to_tc_vec[0], index_map);

    transitive_closure(g, tc, g_to_tc_map, index_map);
}

namespace detail
{
    template < typename Graph, typename GraphTC, typename G_to_TC_VertexMap,
        typename VertexIndexMap >
    void transitive_closure_dispatch(const Graph& g, GraphTC& tc,
        G_to_TC_VertexMap g_to_tc_map, VertexIndexMap index_map)
    {
        typedef typename graph_traits< GraphTC >::vertex_descriptor tc_vertex;
        typename std::vector< tc_vertex >::size_type n
            = is_default_param(g_to_tc_map) ? num_vertices(g) : 1;
        std::vector< tc_vertex > to_tc_vec(n);

        transitive_closure(g, tc,
            choose_param(g_to_tc_map,
                make_iterator_property_map(
                    to_tc_vec.begin(), index_map, to_tc_vec[0])),
            index_map);
    }
} // namespace detail

template < typename Graph, typename GraphTC, typename P, typename T,
    typename R >
void transitive_closure(
    const Graph& g, GraphTC& tc, const bgl_named_params< P, T, R >& params)
{
    if (num_vertices(g) == 0)
        return;
    detail::transitive_closure_dispatch(g, tc,
        get_param(params, orig_to_copy_t()),
        choose_const_pmap(get_param(params, vertex_index), g, vertex_index));
}

template < typename G > void warshall_transitive_closure(G& g)
{
    typedef typename graph_traits< G >::vertex_iterator vertex_iterator;

    BOOST_CONCEPT_ASSERT((AdjacencyMatrixConcept< G >));
    BOOST_CONCEPT_ASSERT((EdgeMutableGraphConcept< G >));

    // Matrix form:
    // for k
    //  for i
    //    if A[i,k]
    //      for j
    //        A[i,j] = A[i,j] | A[k,j]
    vertex_iterator ki, ke, ii, ie, ji, je;
    for (boost::tie(ki, ke) = vertices(g); ki != ke; ++ki)
        for (boost::tie(ii, ie) = vertices(g); ii != ie; ++ii)
            if (edge(*ii, *ki, g).second)
                for (boost::tie(ji, je) = vertices(g); ji != je; ++ji)
                    if (!edge(*ii, *ji, g).second && edge(*ki, *ji, g).second)
                    {
                        add_edge(*ii, *ji, g);
                    }
}

template < typename G > void warren_transitive_closure(G& g)
{
    using namespace boost;
    typedef typename graph_traits< G >::vertex_iterator vertex_iterator;

    BOOST_CONCEPT_ASSERT((AdjacencyMatrixConcept< G >));
    BOOST_CONCEPT_ASSERT((EdgeMutableGraphConcept< G >));

    // Make sure second loop will work
    if (num_vertices(g) == 0)
        return;

    // for i = 2 to n
    //    for k = 1 to i - 1
    //      if A[i,k]
    //        for j = 1 to n
    //          A[i,j] = A[i,j] | A[k,j]

    vertex_iterator ic, ie, jc, je, kc, ke;
    for (boost::tie(ic, ie) = vertices(g), ++ic; ic != ie; ++ic)
        for (boost::tie(kc, ke) = vertices(g); *kc != *ic; ++kc)
            if (edge(*ic, *kc, g).second)
                for (boost::tie(jc, je) = vertices(g); jc != je; ++jc)
                    if (!edge(*ic, *jc, g).second && edge(*kc, *jc, g).second)
                    {
                        add_edge(*ic, *jc, g);
                    }
    //  for i = 1 to n - 1
    //    for k = i + 1 to n
    //      if A[i,k]
    //        for j = 1 to n
    //          A[i,j] = A[i,j] | A[k,j]

    for (boost::tie(ic, ie) = vertices(g), --ie; ic != ie; ++ic)
        for (kc = ic, ke = ie, ++kc; kc != ke; ++kc)
            if (edge(*ic, *kc, g).second)
                for (boost::tie(jc, je) = vertices(g); jc != je; ++jc)
                    if (!edge(*ic, *jc, g).second && edge(*kc, *jc, g).second)
                    {
                        add_edge(*ic, *jc, g);
                    }
}

} // namespace boost

#endif // BOOST_GRAPH_TRANSITIVE_CLOSURE_HPP

/* transitive_closure.hpp
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
*/