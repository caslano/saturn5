// Copyright (c) Jeremy Siek 2001
// Copyright (c) Douglas Gregor 2004
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// NOTE: this final is generated by libs/graph/doc/biconnected_components.w

#ifndef BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP
#define BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP

#include <stack>
#include <vector>
#include <algorithm> // for std::min and std::max
#include <boost/config.hpp>
#include <boost/limits.hpp>
#include <boost/graph/graph_traits.hpp>
#include <boost/graph/graph_concepts.hpp>
#include <boost/property_map/property_map.hpp>
#include <boost/graph/depth_first_search.hpp>
#include <boost/graph/graph_utility.hpp>
#include <boost/concept/assert.hpp>
#include <boost/assert.hpp>

namespace boost
{
namespace detail
{
    template < typename ComponentMap, typename DiscoverTimeMap,
        typename LowPointMap, typename PredecessorMap, typename OutputIterator,
        typename Stack, typename ArticulationVector, typename IndexMap,
        typename DFSVisitor >
    struct biconnected_components_visitor : public dfs_visitor<>
    {
        biconnected_components_visitor(ComponentMap comp, std::size_t& c,
            std::size_t& children_of_root, DiscoverTimeMap dtm,
            std::size_t& dfs_time, LowPointMap lowpt, PredecessorMap pred,
            OutputIterator out, Stack& S,
            ArticulationVector& is_articulation_point, IndexMap index_map,
            DFSVisitor vis)
        : comp(comp)
        , c(c)
        , children_of_root(children_of_root)
        , dtm(dtm)
        , dfs_time(dfs_time)
        , lowpt(lowpt)
        , pred(pred)
        , out(out)
        , S(S)
        , is_articulation_point(is_articulation_point)
        , index_map(index_map)
        , vis(vis)
        {
        }

        template < typename Vertex, typename Graph >
        void initialize_vertex(const Vertex& u, Graph& g)
        {
            put(pred, u, u);
            vis.initialize_vertex(u, g);
        }

        template < typename Vertex, typename Graph >
        void start_vertex(const Vertex& u, Graph& g)
        {
            children_of_root = 0;
            vis.start_vertex(u, g);
        }

        template < typename Vertex, typename Graph >
        void discover_vertex(const Vertex& u, Graph& g)
        {
            put(dtm, u, ++dfs_time);
            put(lowpt, u, get(dtm, u));
            vis.discover_vertex(u, g);
        }

        template < typename Edge, typename Graph >
        void examine_edge(const Edge& e, Graph& g)
        {
            vis.examine_edge(e, g);
        }

        template < typename Edge, typename Graph >
        void tree_edge(const Edge& e, Graph& g)
        {
            typename boost::graph_traits< Graph >::vertex_descriptor src
                = source(e, g);
            typename boost::graph_traits< Graph >::vertex_descriptor tgt
                = target(e, g);

            S.push(e);
            put(pred, tgt, src);
            if (get(pred, src) == src)
            {
                ++children_of_root;
            }
            vis.tree_edge(e, g);
        }

        template < typename Edge, typename Graph >
        void back_edge(const Edge& e, Graph& g)
        {
            BOOST_USING_STD_MIN();

            typename boost::graph_traits< Graph >::vertex_descriptor src
                = source(e, g);
            typename boost::graph_traits< Graph >::vertex_descriptor tgt
                = target(e, g);
            if (tgt != get(pred, src))
            {
                S.push(e);
                put(lowpt, src,
                    min BOOST_PREVENT_MACRO_SUBSTITUTION(
                        get(lowpt, src), get(dtm, tgt)));
            }
            vis.back_edge(e, g);
        }

        template < typename Edge, typename Graph >
        void forward_or_cross_edge(const Edge& e, Graph& g)
        {
            vis.forward_or_cross_edge(e, g);
        }

        template < typename Vertex, typename Graph >
        void finish_vertex(const Vertex& u, Graph& g)
        {
            BOOST_USING_STD_MIN();
            Vertex parent = get(pred, u);
            if (parent == u)
            { // Root of tree is special
                is_articulation_point[get(index_map, u)]
                    = (children_of_root > 1);
            }
            else
            {
                put(lowpt, parent,
                    min BOOST_PREVENT_MACRO_SUBSTITUTION(
                        get(lowpt, parent), get(lowpt, u)));
                if (get(lowpt, u) >= get(dtm, parent))
                {
                    is_articulation_point[get(index_map, parent)] = true;
                    while (get(dtm, source(S.top(), g)) >= get(dtm, u))
                    {
                        put(comp, S.top(), c);
                        S.pop();
                    }
                    BOOST_ASSERT(source(S.top(), g) == parent);
                    BOOST_ASSERT(target(S.top(), g) == u);
                    put(comp, S.top(), c);
                    S.pop();
                    ++c;
                }
            }
            if (is_articulation_point[get(index_map, u)])
            {
                *out++ = u;
            }
            vis.finish_vertex(u, g);
        }

        ComponentMap comp;
        std::size_t& c;
        std::size_t& children_of_root;
        DiscoverTimeMap dtm;
        std::size_t& dfs_time;
        LowPointMap lowpt;
        PredecessorMap pred;
        OutputIterator out;
        Stack& S;
        ArticulationVector& is_articulation_point;
        IndexMap index_map;
        DFSVisitor vis;
    };

    template < typename Graph, typename ComponentMap, typename OutputIterator,
        typename VertexIndexMap, typename DiscoverTimeMap, typename LowPointMap,
        typename PredecessorMap, typename DFSVisitor >
    std::pair< std::size_t, OutputIterator > biconnected_components_impl(
        const Graph& g, ComponentMap comp, OutputIterator out,
        VertexIndexMap index_map, DiscoverTimeMap dtm, LowPointMap lowpt,
        PredecessorMap pred, DFSVisitor dfs_vis)
    {
        typedef typename graph_traits< Graph >::vertex_descriptor vertex_t;
        typedef typename graph_traits< Graph >::edge_descriptor edge_t;
        BOOST_CONCEPT_ASSERT((VertexListGraphConcept< Graph >));
        BOOST_CONCEPT_ASSERT((IncidenceGraphConcept< Graph >));
        BOOST_CONCEPT_ASSERT(
            (WritablePropertyMapConcept< ComponentMap, edge_t >));
        BOOST_CONCEPT_ASSERT(
            (ReadWritePropertyMapConcept< DiscoverTimeMap, vertex_t >));
        BOOST_CONCEPT_ASSERT(
            (ReadWritePropertyMapConcept< LowPointMap, vertex_t >));
        BOOST_CONCEPT_ASSERT(
            (ReadWritePropertyMapConcept< PredecessorMap, vertex_t >));

        std::size_t num_components = 0;
        std::size_t children_of_root;
        std::size_t dfs_time = 0;
        std::stack< edge_t > S;
        std::vector< char > is_articulation_point(num_vertices(g));

        biconnected_components_visitor< ComponentMap, DiscoverTimeMap,
            LowPointMap, PredecessorMap, OutputIterator, std::stack< edge_t >,
            std::vector< char >, VertexIndexMap, DFSVisitor >
            vis(comp, num_components, children_of_root, dtm, dfs_time, lowpt,
                pred, out, S, is_articulation_point, index_map, dfs_vis);

        depth_first_search(g, visitor(vis).vertex_index_map(index_map));

        return std::pair< std::size_t, OutputIterator >(
            num_components, vis.out);
    }

    template < typename PredecessorMap > struct bicomp_dispatch3
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename LowPointMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, LowPointMap lowpt,
            const bgl_named_params< P, T, R >& params, PredecessorMap pred)
        {
            return biconnected_components_impl(g, comp, out, index_map, dtm,
                lowpt, pred,
                choose_param(get_param(params, graph_visitor),
                    make_dfs_visitor(null_visitor())));
        }
    };

    template <> struct bicomp_dispatch3< param_not_found >
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename LowPointMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, LowPointMap lowpt,
            const bgl_named_params< P, T, R >& params, param_not_found)
        {
            typedef typename graph_traits< Graph >::vertex_descriptor vertex_t;
            std::vector< vertex_t > pred(num_vertices(g));
            vertex_t vert = graph_traits< Graph >::null_vertex();

            return biconnected_components_impl(g, comp, out, index_map, dtm,
                lowpt,
                make_iterator_property_map(pred.begin(), index_map, vert),
                choose_param(get_param(params, graph_visitor),
                    make_dfs_visitor(null_visitor())));
        }
    };

    template < typename LowPointMap > struct bicomp_dispatch2
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename P, typename T, typename R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, const bgl_named_params< P, T, R >& params,
            LowPointMap lowpt)
        {
            typedef typename get_param_type< vertex_predecessor_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch3< dispatch_type >::apply(g, comp, out,
                index_map, dtm, lowpt, params,
                get_param(params, vertex_predecessor));
        }
    };

    template <> struct bicomp_dispatch2< param_not_found >
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename P, typename T, typename R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, const bgl_named_params< P, T, R >& params,
            param_not_found)
        {
            typedef typename graph_traits< Graph >::vertices_size_type
                vertices_size_type;
            std::vector< vertices_size_type > lowpt(num_vertices(g));
            vertices_size_type vst(0);

            typedef typename get_param_type< vertex_predecessor_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch3< dispatch_type >::apply(g, comp, out,
                index_map, dtm,
                make_iterator_property_map(lowpt.begin(), index_map, vst),
                params, get_param(params, vertex_predecessor));
        }
    };

    template < typename DiscoverTimeMap > struct bicomp_dispatch1
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            const bgl_named_params< P, T, R >& params, DiscoverTimeMap dtm)
        {
            typedef typename get_param_type< vertex_lowpoint_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch2< dispatch_type >::apply(g, comp, out,
                index_map, dtm, params, get_param(params, vertex_lowpoint));
        }
    };

    template <> struct bicomp_dispatch1< param_not_found >
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            const bgl_named_params< P, T, R >& params, param_not_found)
        {
            typedef typename graph_traits< Graph >::vertices_size_type
                vertices_size_type;
            std::vector< vertices_size_type > discover_time(num_vertices(g));
            vertices_size_type vst(0);

            typedef typename get_param_type< vertex_lowpoint_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch2< dispatch_type >::apply(g, comp, out,
                index_map,
                make_iterator_property_map(
                    discover_time.begin(), index_map, vst),
                params, get_param(params, vertex_lowpoint));
        }
    };

}

template < typename Graph, typename ComponentMap, typename OutputIterator,
    typename DiscoverTimeMap, typename LowPointMap >
std::pair< std::size_t, OutputIterator > biconnected_components(const Graph& g,
    ComponentMap comp, OutputIterator out, DiscoverTimeMap dtm,
    LowPointMap lowpt)
{
    typedef param_not_found dispatch_type;

    return detail::bicomp_dispatch3< dispatch_type >::apply(g, comp, out,
        get(vertex_index, g), dtm, lowpt,
        bgl_named_params< int, buffer_param_t >(0), param_not_found());
}

template < typename Graph, typename ComponentMap, typename OutputIterator,
    typename P, typename T, typename R >
std::pair< std::size_t, OutputIterator > biconnected_components(const Graph& g,
    ComponentMap comp, OutputIterator out,
    const bgl_named_params< P, T, R >& params)
{
    typedef typename get_param_type< vertex_discover_time_t,
        bgl_named_params< P, T, R > >::type dispatch_type;

    return detail::bicomp_dispatch1< dispatch_type >::apply(g, comp, out,
        choose_const_pmap(get_param(params, vertex_index), g, vertex_index),
        params, get_param(params, vertex_discover_time));
}

template < typename Graph, typename ComponentMap, typename OutputIterator >
std::pair< std::size_t, OutputIterator > biconnected_components(
    const Graph& g, ComponentMap comp, OutputIterator out)
{
    return biconnected_components(
        g, comp, out, bgl_named_params< int, buffer_param_t >(0));
}

namespace graph_detail
{
    struct dummy_output_iterator
    {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void pointer;
        typedef void difference_type;

        struct reference
        {
            template < typename T > reference& operator=(const T&)
            {
                return *this;
            }
        };

        reference operator*() const { return reference(); }
        dummy_output_iterator& operator++() { return *this; }
        dummy_output_iterator operator++(int) { return *this; }
    };
} // end namespace graph_detail

template < typename Graph, typename ComponentMap, typename P, typename T,
    typename R >
std::size_t biconnected_components(const Graph& g, ComponentMap comp,
    const bgl_named_params< P, T, R >& params)
{
    return biconnected_components(
        g, comp, graph_detail::dummy_output_iterator(), params)
        .first;
}

template < typename Graph, typename ComponentMap >
std::size_t biconnected_components(const Graph& g, ComponentMap comp)
{
    return biconnected_components(
        g, comp, graph_detail::dummy_output_iterator())
        .first;
}

template < typename Graph, typename OutputIterator, typename P, typename T,
    typename R >
OutputIterator articulation_points(const Graph& g, OutputIterator out,
    const bgl_named_params< P, T, R >& params)
{
    return biconnected_components(g, dummy_property_map(), out, params).second;
}

template < typename Graph, typename OutputIterator >
OutputIterator articulation_points(const Graph& g, OutputIterator out)
{
    return biconnected_components(g, dummy_property_map(), out,
        bgl_named_params< int, buffer_param_t >(0))
        .second;
}

} // namespace boost

#endif /* BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP */

/* biconnected_components.hpp
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
*/