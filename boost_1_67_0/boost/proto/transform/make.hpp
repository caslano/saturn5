///////////////////////////////////////////////////////////////////////////////
/// \file make.hpp
/// Contains definition of the make<> transform.
//
//  Copyright 2008 Eric Niebler. Distributed under the Boost
//  Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_PROTO_TRANSFORM_MAKE_HPP_EAN_12_02_2007
#define BOOST_PROTO_TRANSFORM_MAKE_HPP_EAN_12_02_2007

#include <boost/detail/workaround.hpp>
#include <boost/preprocessor/repetition/enum.hpp>
#include <boost/preprocessor/repetition/enum_params.hpp>
#include <boost/preprocessor/repetition/enum_trailing_params.hpp>
#include <boost/preprocessor/repetition/enum_binary_params.hpp>
#include <boost/preprocessor/repetition/enum_params_with_a_default.hpp>
#include <boost/preprocessor/repetition/repeat_from_to.hpp>
#include <boost/preprocessor/facilities/intercept.hpp>
#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/iteration/iterate.hpp>
#include <boost/preprocessor/selection/max.hpp>
#include <boost/preprocessor/arithmetic/inc.hpp>
#include <boost/mpl/and.hpp>
#include <boost/mpl/aux_/has_type.hpp>
#include <boost/proto/detail/template_arity.hpp>
#include <boost/utility/result_of.hpp>
#include <boost/proto/proto_fwd.hpp>
#include <boost/proto/traits.hpp>
#include <boost/proto/args.hpp>
#include <boost/proto/transform/impl.hpp>
#include <boost/proto/transform/detail/pack.hpp>
#include <boost/proto/detail/as_lvalue.hpp>
#include <boost/proto/detail/ignore_unused.hpp>

#if defined(_MSC_VER)
# pragma warning(push)
# pragma warning(disable : 4714) // function 'xxx' marked as __forceinline not inlined
#endif

namespace boost { namespace proto
{
    namespace detail
    {
        template<typename T>
        struct is_applyable
          : mpl::and_<is_callable<T>, is_transform<T> >
        {};

        template<typename T, bool HasType = mpl::aux::has_type<T>::value>
        struct nested_type
        {
            typedef typename T::type type;
        };

        template<typename T>
        struct nested_type<T, false>
        {
            typedef T type;
        };

        template<typename T, bool Applied>
        struct nested_type_if
        {
            typedef T type;
            static bool const applied = false;
        };

        template<typename T>
        struct nested_type_if<T, true>
          : nested_type<T>
        {
            static bool const applied = true;
        };

        template<
            typename R
          , typename Expr, typename State, typename Data
            BOOST_PROTO_TEMPLATE_ARITY_PARAM(long Arity = detail::template_arity<R>::value)
        >
        struct make_
        {
            typedef R type;
            static bool const applied = false;
        };

        template<
            typename R
          , typename Expr, typename State, typename Data
          , bool IsApplyable = is_applyable<R>::value
        >
        struct make_if_
          : make_<R, Expr, State, Data>
        {};

        template<typename R, typename Expr, typename State, typename Data>
        struct make_if_<R, Expr, State, Data, true>
          : uncvref<typename when<_, R>::template impl<Expr, State, Data>::result_type>
        {
            static bool const applied = true;
        };

        #if BOOST_WORKAROUND(__GNUC__, == 3) || (BOOST_WORKAROUND(__GNUC__, == 4) && __GNUC_MINOR__ == 0)
        // work around GCC bug
        template<typename Tag, typename Args, long N, typename Expr, typename State, typename Data>
        struct make_if_<proto::expr<Tag, Args, N>, Expr, State, Data, false>
        {
            typedef proto::expr<Tag, Args, N> type;
            static bool const applied = false;
        };

        // work around GCC bug
        template<typename Tag, typename Args, long N, typename Expr, typename State, typename Data>
        struct make_if_<proto::basic_expr<Tag, Args, N>, Expr, State, Data, false>
        {
            typedef proto::basic_expr<Tag, Args, N> type;
            static bool const applied = false;
        };
        #endif

        template<typename Type, bool IsAggregate = detail::is_aggregate_<Type>::value>
        struct construct_
        {
            typedef Type result_type;

            BOOST_FORCEINLINE
            Type operator ()() const
            {
                return Type();
            }

            // Other overloads generated by the preprocessor
            #include <boost/proto/transform/detail/construct_funop.hpp>
        };

        template<typename Type>
        struct construct_<Type, true>
        {
            typedef Type result_type;

            BOOST_FORCEINLINE
            Type operator ()() const
            {
                return Type();
            }

            // Other overloads generated by the preprocessor
            #include <boost/proto/transform/detail/construct_pod_funop.hpp>
        };

    }

    /// \brief A PrimitiveTransform which prevents another PrimitiveTransform
    /// from being applied in an \c ObjectTransform.
    ///
    /// When building higher order transforms with <tt>make\<\></tt> or
    /// <tt>lazy\<\></tt>, you sometimes would like to build types that
    /// are parameterized with Proto transforms. In such lambda-style
    /// transforms, Proto will unhelpfully find all nested transforms
    /// and apply them, even if you don't want them to be applied. Consider
    /// the following transform, which will replace the \c _ in
    /// <tt>Bar<_>()</tt> with <tt>proto::terminal\<int\>::type</tt>:
    ///
    /// \code
    /// template<typename T>
    /// struct Bar
    /// {};
    /// 
    /// struct Foo
    ///   : proto::when<_, Bar<_>() >
    /// {};
    /// 
    /// proto::terminal<int>::type i = {0};
    /// 
    /// int main()
    /// {
    ///     Foo()(i);
    ///     std::cout << typeid(Foo()(i)).name() << std::endl;
    /// }
    /// \endcode
    ///
    /// If you actually wanted to default-construct an object of type
    /// <tt>Bar\<_\></tt>, you would have to protect the \c _ to prevent
    /// it from being applied. You can use <tt>proto::protect\<\></tt>
    /// as follows:
    ///
    /// \code
    /// // OK: replace anything with Bar<_>()
    /// struct Foo
    ///   : proto::when<_, Bar<protect<_> >() >
    /// {};
    /// \endcode
    template<typename PrimitiveTransform>
    struct protect : transform<protect<PrimitiveTransform> >
    {
        template<typename, typename, typename>
        struct impl
        {
            typedef PrimitiveTransform result_type;
        };
    };

    /// \brief A PrimitiveTransform which computes a type by evaluating any
    /// nested transforms and then constructs an object of that type.
    ///
    /// The <tt>make\<\></tt> transform checks to see if \c Object is a template.
    /// If it is, the template type is disassembled to find nested transforms.
    /// Proto considers the following types to represent transforms:
    ///
    /// \li Function types
    /// \li Function pointer types
    /// \li Types for which <tt>proto::is_callable\< type \>::value</tt> is \c true
    ///
    /// <tt>boost::result_of\<make\<T\<X0,X1,...\> \>(Expr, State, Data)\>::type</tt>
    /// is evaluated as follows. For each \c X in <tt>X0,X1,...</tt>, do:
    ///
    /// \li If \c X is a template like <tt>U\<Y0,Y1,...\></tt>, then let <tt>X'</tt>
    ///     be <tt>boost::result_of\<make\<U\<Y0,Y1,...\> \>(Expr, State, Data)\>::type</tt>
    ///     (which evaluates this procedure recursively). Note whether any
    ///     substitutions took place during this operation.
    /// \li Otherwise, if \c X is a transform, then let <tt>X'</tt> be
    ///     <tt>boost::result_of\<when\<_, X\>(Expr, State, Data)\>::type</tt>.
    ///     Note that a substitution took place.
    /// \li Otherwise, let <tt>X'</tt> be \c X, and note that no substitution
    ///     took place.
    /// \li If any substitutions took place in any of the above steps and
    ///     <tt>T\<X0',X1',...\></tt> has a nested <tt>::type</tt> typedef,
    ///     the result type is <tt>T\<X0',X1',...\>::type</tt>.
    /// \li Otherwise, the result type is <tt>T\<X0',X1',...\></tt>.
    ///
    /// Note that <tt>when\<\></tt> is implemented in terms of <tt>call\<\></tt>
    /// and <tt>make\<\></tt>, so the above procedure is evaluated recursively.
    template<typename Object>
    struct make : transform<make<Object> >
    {
        template<typename Expr, typename State, typename Data>
        struct impl : transform_impl<Expr, State, Data>
        {
            typedef typename detail::make_if_<Object, Expr, State, Data>::type result_type;

            /// \return <tt>result_type()</tt>
            BOOST_FORCEINLINE
            result_type operator ()(
                typename impl::expr_param
              , typename impl::state_param
              , typename impl::data_param
            ) const
            {
                return result_type();
            }
        };
    };

    /// INTERNAL ONLY
    template<typename Fun>
    struct make<detail::msvc_fun_workaround<Fun> >
      : make<Fun>
    {};

    // Other specializations generated by the preprocessor.
    #include <boost/proto/transform/detail/make.hpp>
    #include <boost/proto/transform/detail/make_gcc_workaround.hpp>

    /// INTERNAL ONLY
    ///
    template<typename Object>
    struct is_callable<make<Object> >
      : mpl::true_
    {};

    /// INTERNAL ONLY
    ///
    template<typename PrimitiveTransform>
    struct is_callable<protect<PrimitiveTransform> >
      : mpl::true_
    {};

}}

#if defined(_MSC_VER)
# pragma warning(pop)
#endif

#endif

/* make.hpp
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
*/