// Boost.Geometry

// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.

// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.

// This file was modified by Oracle on 2019.
// Modifications copyright (c) 2019 Oracle and/or its affiliates.

// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle

// Use, modification and distribution is subject to the Boost Software License,
// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// This file is converted from GeographicLib, https://geographiclib.sourceforge.io
// GeographicLib is originally written by Charles Karney.

// Author: Charles Karney (2008-2017)

// Last updated version of GeographicLib: 1.49

// Original copyright notice:

// Copyright (c) Charles Karney (2008-2017) <charles@karney.com> and licensed
// under the MIT/X11 License. For more information, see
// https://geographiclib.sourceforge.io

#ifndef BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
#define BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

#include <boost/geometry/core/assert.hpp>
#include <boost/geometry/util/math.hpp>

namespace boost { namespace geometry { namespace series_expansion {

    /*
     Generate and evaluate the series expansion of the following integral

     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )

     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2
     and expand (1 - eps) * I1 retaining terms up to order eps^maxpow
     in A1 and C1[l].

     The resulting series is of the form

     A1 * ( sigma + sum(C1[l] * sin(2*l*sigma), l, 1, maxpow) ).

     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_A1 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;'
    */
    template <size_t SeriesOrder, typename CT>
    inline CT evaluate_A1(CT eps)
    {
        CT eps2 = math::sqr(eps);
        CT t;
        switch (SeriesOrder/2) {
        case 0:
            t = CT(0);
            break;
        case 1:
            t = eps2/CT(4);
            break;
        case 2:
            t = eps2*(eps2+CT(16))/CT(64);
            break;
        case 3:
            t = eps2*(eps2*(eps2+CT(4))+CT(64))/CT(256);
            break;
        case 4:
            t = eps2*(eps2*(eps2*(CT(25)*eps2+CT(64))+CT(256))+CT(4096))/CT(16384);
            break;
        }
        return (t + eps) / (CT(1) - eps);
    }

    /*
     Generate and evaluate the series expansion of the following integral

     I2 = integrate( 1/sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )

     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2
     and expand (1 - eps) * I2 retaining terms up to order eps^maxpow
     in A2 and C2[l].

     The resulting series is of the form

     A2 * ( sigma + sum(C2[l] * sin(2*l*sigma), l, 1, maxpow) )

     The scale factor A2-1 = mean value of (d/dsigma)2 - 1

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_A2 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <size_t SeriesOrder, typename CT>
    inline CT evaluate_A2(CT const& eps)
    {
        CT const eps2 = math::sqr(eps);
        CT t;
        switch (SeriesOrder/2) {
        case 0:
            t = CT(0);
            break;
        case 1:
            t = -CT(3)*eps2/CT(4);
            break;
        case 2:
            t = (-CT(7)*eps2-CT(48))*eps2/CT(64);
            break;
        case 3:
            t = eps2*((-CT(11)*eps2-CT(28))*eps2-CT(192))/CT(256);
            break;
        default:
            t = eps2*(eps2*((-CT(375)*eps2-CT(704))*eps2-CT(1792))-CT(12288))/CT(16384);
            break;
        }
        return (t - eps) / (CT(1) + eps);
    }

    /*
     Express

        I3 = integrate( (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma1)^2)), sigma1, 0, sigma )

     as a series

        A3 * ( sigma + sum(C3[l] * sin(2*l*sigma), l, 1, maxpow-1) )

     valid for f and k2 small.  It is convenient to write k2 = 4 * eps / (1 -
     eps)^2 and f = 2*n/(1+n) and expand in eps and n.  This procedure leads
     to a series where the coefficients of eps^j are terminating series in n.

     The scale factor A3 = mean value of (d/dsigma)I3

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_A3 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_A3(Coeffs &c, CT const& n)
    {
        switch (int(Coeffs::static_size)) {
        case 0:
            break;
        case 1:
            c[0] = CT(1);
            break;
        case 2:
            c[0] = CT(1);
            c[1] = -CT(1)/CT(2);
            break;
        case 3:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = -CT(1)/CT(4);
            break;
        case 4:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (-n-CT(2))/CT(8);
            c[3] = -CT(1)/CT(16);
            break;
        case 5:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (-CT(3)*n-CT(1))/CT(16);
            c[4] = -CT(3)/CT(64);
            break;
        case 6:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = ((-n-CT(3))*n-CT(1))/CT(16);
            c[4] = (-CT(2)*n-CT(3))/CT(64);
            c[5] = -CT(3)/CT(128);
            break;
        case 7:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);
            c[4] = ((-CT(10)*n-CT(2))*n-CT(3))/CT(64);
            c[5] = (-CT(5)*n-CT(3))/CT(128);
            c[6] = -CT(5)/CT(256);
            break;
        default:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);
            c[4] = (n*((-CT(5)*n-CT(20))*n-CT(4))-CT(6))/CT(128);
            c[5] = ((-CT(5)*n-CT(10))*n-CT(6))/CT(256);
            c[6] = (-CT(15)*n-CT(20))/CT(1024);
            c[7] = -CT(25)/CT(2048);
            break;
        }
    }

    /*
     The coefficients C1[l] in the Fourier expansion of B1.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C1 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_C1(Coeffs &c, CT const& eps)
    {
        CT eps2 = math::sqr(eps);
        CT d = eps;
        switch (int(Coeffs::static_size) - 1) {
        case 0:
            break;
        case 1:
            c[1] = -d/CT(2);
            break;
        case 2:
            c[1] = -d/CT(2);
            d *= eps;
            c[2] = -d/CT(16);
            break;
        case 3:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = -d/CT(16);
            d *= eps;
            c[3] = -d/CT(48);
            break;
        case 4:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = -d/CT(48);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            break;
        case 5:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            break;
        case 6:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            break;
        case 7:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            break;
        default:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*((CT(96)-CT(11)*eps2)*eps2-CT(160))/CT(16384);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = d*(CT(9)*eps2-CT(14))/CT(4096);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            d *= eps;
            c[8] = -CT(429)*d/CT(262144);
            break;
        }
    }

    /*
     The coefficients C1p[l] in the Fourier expansion of B1p.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C1p below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_C1p(Coeffs& c, CT const& eps)
    {
        CT const eps2 = math::sqr(eps);
        CT d = eps;
        switch (int(Coeffs::static_size) - 1) {
        case 0:
            break;
        case 1:
            c[1] = d/CT(2);
            break;
        case 2:
            c[1] = d/CT(2);
            d *= eps;
            c[2] = CT(5)*d/CT(16);
            break;
        case 3:
            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);
            d *= eps;
            c[2] = CT(5)*d/CT(16);
            d *= eps;
            c[3] = CT(29)*d/CT(96);
            break;
        case 4:
            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);
            d *= eps;
            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);
            d *= eps;
            c[3] = CT(29)*d/CT(96);
            d *= eps;
            c[4] = CT(539)*d/CT(1536);
            break;
        case 5:
            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);
            d *= eps;
            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);
            d *= eps;
            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);
            d *= eps;
            c[4] = CT(539)*d/CT(1536);
            d *= eps;
            c[5] = CT(3467)*d/CT(7680);
            break;
        case 6:
            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);
            d *= eps;
            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);
            d *= eps;
            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);
            d *= eps;
            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);
            d *= eps;
            c[5] = CT(3467)*d/CT(7680);
            d *= eps;
            c[6] = CT(38081)*d/CT(61440);
            break;
        case 7:
            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);
            d *= eps;
            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);
            d *= eps;
            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);
            d *= eps;
            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);
            d *= eps;
            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);
            d *= eps;
            c[6] = CT(38081)*d/CT(61440);
            d *= eps;
            c[7] = CT(459485)*d/CT(516096);
            break;
        default:
            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);
            d *= eps;
            c[2] = d*(eps2*((CT(120150)-CT(86171)*eps2)*eps2-CT(142080))+CT(115200))/CT(368640);
            d *= eps;
            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);
            d *= eps;
            c[4] = d*(eps2*(CT(1082857)*eps2-CT(688608))+CT(258720))/CT(737280);
            d *= eps;
            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);
            d *= eps;
            c[6] = d*(CT(533134)-CT(2200311)*eps2)/CT(860160);
            d *= eps;
            c[7] = CT(459485)*d/CT(516096);
            d *= eps;
            c[8] = CT(109167851)*d/CT(82575360);
            break;
        }
    }

    /*
     The coefficients C2[l] in the Fourier expansion of B2.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C2 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_C2(Coeffs& c, CT const& eps)
    {
        CT const eps2 = math::sqr(eps);
        CT d = eps;
        switch (int(Coeffs::static_size) - 1) {
        case 0:
            break;
        case 1:
            c[1] = d/CT(2);
            break;
        case 2:
            c[1] = d/CT(2);
            d *= eps;
            c[2] = CT(3)*d/CT(16);
            break;
        case 3:
            c[1] = d*(eps2+CT(8))/CT(16);
            d *= eps;
            c[2] = CT(3)*d/CT(16);
            d *= eps;
            c[3] = CT(5)*d/CT(48);
            break;
        case 4:
            c[1] = d*(eps2+CT(8))/CT(16);
            d *= eps;
            c[2] = d*(eps2+CT(6))/CT(32);
            d *= eps;
            c[3] = CT(5)*d/CT(48);
            d *= eps;
            c[4] = CT(35)*d/CT(512);
            break;
        case 5:
            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2+CT(6))/CT(32);
            d *= eps;
            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);
            d *= eps;
            c[4] = CT(35)*d/CT(512);
            d *= eps;
            c[5] = CT(63)*d/CT(1280);
            break;
        case 6:
            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);
            d *= eps;
            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);
            d *= eps;
            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);
            d *= eps;
            c[5] = CT(63)*d/CT(1280);
            d *= eps;
            c[6] = CT(77)*d/CT(2048);
            break;
        case 7:
            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);
            d *= eps;
            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);
            d *= eps;
            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);
            d *= eps;
            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);
            d *= eps;
            c[6] = CT(77)*d/CT(2048);
            d *= eps;
            c[7] = CT(429)*d/CT(14336);
            break;
        default:
            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(eps2*(CT(47)*eps2+CT(70))+CT(128))+CT(768))/CT(4096);
            d *= eps;
            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);
            d *= eps;
            c[4] = d*(eps2*(CT(133)*eps2+CT(224))+CT(1120))/CT(16384);
            d *= eps;
            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);
            d *= eps;
            c[6] = d*(CT(33)*eps2+CT(154))/CT(4096);
            d *= eps;
            c[7] = CT(429)*d/CT(14336);
            d *= eps;
            c[8] = CT(6435)*d/CT(262144);
            break;
        }
    }

    /*
     The coefficients C3[l] in the Fourier expansion of B3.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C3 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <size_t SeriesOrder, typename Coeffs, typename CT>
    inline void evaluate_coeffs_C3x(Coeffs &c, CT const& n) {
        size_t const coeff_size = Coeffs::static_size;
        size_t const expected_size = (SeriesOrder * (SeriesOrder - 1)) / 2;
        BOOST_GEOMETRY_ASSERT((coeff_size == expected_size));

        const CT n2 = math::sqr(n);
        switch (SeriesOrder) {
        case 0:
            break;
        case 1:
            break;
        case 2:
            c[0] = (CT(1)-n)/CT(4);
            break;
        case 3:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = ((n-CT(3))*n+CT(2))/CT(32);
            break;
        case 4:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = ((n-CT(3))*n+CT(2))/CT(32);
            c[4] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[5] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            break;
        case 5:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = ((n-CT(3))*n+CT(2))/CT(32);
            c[5] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[6] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[7] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[8] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[9] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            break;
        case 6:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);
            c[5] = ((n-CT(3))*n+CT(2))/CT(32);
            c[6] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[7] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[8] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);
            c[9] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[10] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[11] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);
            c[12] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            c[13] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);
            c[14] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);
            break;
        case 7:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);
            c[5] = (CT(10)*n+CT(21))/CT(1024);
            c[6] = ((n-CT(3))*n+CT(2))/CT(32);
            c[7] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[8] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[9] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);
            c[10] = (CT(69)*n+CT(108))/CT(8192);
            c[11] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[12] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[13] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);
            c[14] = (CT(12)-n)/CT(1024);
            c[15] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            c[16] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);
            c[17] = (CT(72)-CT(43)*n)/CT(8192);
            c[18] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);
            c[19] = (CT(9)-CT(15)*n)/CT(1024);
            c[20] = (CT(44)-CT(99)*n)/CT(8192);
            break;
        default:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);
            c[5] = (CT(10)*n+CT(21))/CT(1024);
            c[6] = CT(243)/CT(16384);
            c[7] = ((n-CT(3))*n+CT(2))/CT(32);
            c[8] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[9] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[10] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);
            c[11] = (CT(69)*n+CT(108))/CT(8192);
            c[12] = CT(187)/CT(16384);
            c[13] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[14] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[15] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);
            c[16] = (CT(12)-n)/CT(1024);
            c[17] = CT(139)/CT(16384);
            c[18] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            c[19] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);
            c[20] = (CT(72)-CT(43)*n)/CT(8192);
            c[21] = CT(127)/CT(16384);
            c[22] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);
            c[23] = (CT(9)-CT(15)*n)/CT(1024);
            c[24] = CT(99)/CT(16384);
            c[25] = (CT(44)-CT(99)*n)/CT(8192);
            c[26] = CT(99)/CT(16384);
            c[27] = CT(429)/CT(114688);
            break;
        }
    }

    /*
    \brief Given the set of coefficients coeffs2[] evaluate on
      C3 and return the set of coefficients coeffs1[].

      Elements coeffs1[1] through coeffs1[SeriesOrder - 1] are set.
    */
    template <typename Coeffs1, typename Coeffs2, typename CT>
    inline void evaluate_coeffs_C3(Coeffs1 &coeffs1, Coeffs2 &coeffs2, CT const& eps)
    {
        CT mult = 1;
        size_t offset = 0;

        // i is the index of C3[i].
        for (size_t i = 1; i < Coeffs1::static_size; ++i)
        {
            // Order of polynomial in eps.
            size_t m = Coeffs1::static_size - i;
            mult *= eps;

            coeffs1[i] = mult * math::horner_evaluate(eps, coeffs2.begin() + offset,
                                                           coeffs2.begin() + offset + m);

            offset += m;
        }
        // Post condition: offset == coeffs_C3_size
    }

    /*
    \brief Evaluate the following:

     y = sum(c[i] * sin(2*i * x), i, 1, n)

     using Clenshaw summation.
    */
    template <typename CT, typename Coeffs>
    inline CT sin_cos_series(CT const& sinx, CT const& cosx, Coeffs const& coeffs)
    {
        size_t n = Coeffs::static_size - 1;
        size_t index = 0;

        // Point to one beyond last element.
        index += (n + 1);
        CT ar = 2 * (cosx - sinx) * (cosx + sinx);

        // If n is odd, get the last element.
        CT k0 = n & 1 ? coeffs[--index] : 0;
        CT k1 = 0;

        // Make n even.
        n /= 2;
        while (n--) {
            // Unroll loop x 2, so accumulators return to their original role.
            k1 = ar * k0 - k1 + coeffs[--index];
            k0 = ar * k1 - k0 + coeffs[--index];
        }

        return 2 * sinx * cosx * k0;
    }

    /*
     The coefficient containers for the series expansions.
     These structs allow the caller to only know the series order.
    */
    template <size_t SeriesOrder, typename CT>
    struct coeffs_C1 : boost::array<CT, SeriesOrder + 1>
    {
        coeffs_C1(CT const& epsilon)
        {
            evaluate_coeffs_C1(*this, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C1p : boost::array<CT, SeriesOrder + 1>
    {
        coeffs_C1p(CT const& epsilon)
        {
            evaluate_coeffs_C1p(*this, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C2 : boost::array<CT, SeriesOrder + 1>
    {
        coeffs_C2(CT const& epsilon)
        {
            evaluate_coeffs_C2(*this, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C3x : boost::array<CT, (SeriesOrder * (SeriesOrder - 1)) / 2>
    {
        coeffs_C3x(CT const& n)
        {
            evaluate_coeffs_C3x<SeriesOrder>(*this, n);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C3 : boost::array<CT, SeriesOrder>
    {
        coeffs_C3(CT const& n, CT const& epsilon)
        {
            coeffs_C3x<SeriesOrder, CT> coeffs_C3x(n);

            evaluate_coeffs_C3(*this, coeffs_C3x, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_A3 : boost::array<CT, SeriesOrder>
    {
        coeffs_A3(CT const& n)
        {
            evaluate_coeffs_A3(*this, n);
        }
    };

}}} // namespace boost::geometry::series_expansion

#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

/* series_expansion.hpp
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
*/