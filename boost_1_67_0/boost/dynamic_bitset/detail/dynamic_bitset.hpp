// -----------------------------------------------------------
//
//   Copyright (c) 2001-2002 Chuck Allison and Jeremy Siek
//   Copyright (c) 2003-2006, 2008 Gennaro Prota
//   Copyright (c) 2014 Glen Joseph Fernandes
//       (glenjofe@gmail.com)
//   Copyright (c) 2018 Evgeny Shulgin
//   Copyright (c) 2019 Andrey Semashev
//
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//
// -----------------------------------------------------------

#ifndef BOOST_DETAIL_DYNAMIC_BITSET_HPP
#define BOOST_DETAIL_DYNAMIC_BITSET_HPP

#include <memory>
#include <cstddef>
#include "boost/config.hpp"
#include "boost/detail/workaround.hpp"

#if ((defined(BOOST_MSVC) && (BOOST_MSVC >= 1600)) || (defined(__clang__) && defined(__c2__)) || (defined(BOOST_INTEL) && defined(_MSC_VER))) && (defined(_M_IX86) || defined(_M_X64))
#include <intrin.h>
#endif

namespace boost {

  namespace detail {
  namespace dynamic_bitset_impl {

    template<class T>
    struct max_limit {
        BOOST_STATIC_CONSTEXPR T value = static_cast<T>(-1);
    };

    template<class T>
    BOOST_CONSTEXPR_OR_CONST T max_limit<T>::value;

    // Gives (read-)access to the object representation
    // of an object of type T (3.9p4). CANNOT be used
    // on a base sub-object
    //
    template <typename T>
    inline const unsigned char * object_representation (T* p)
    {
        return static_cast<const unsigned char *>(static_cast<const void *>(p));
    }

    template<typename T, int amount, int width /* = default */>
    struct shifter
    {
        static void left_shift(T & v) {
            amount >= width ? (v = 0)
                : (v >>= BOOST_DYNAMIC_BITSET_WRAP_CONSTANT(amount));
        }
    };

    // ------- count function implementation --------------

    typedef unsigned char byte_type;

    // These two entities
    //
    //     enum mode { access_by_bytes, access_by_blocks };
    //     template <mode> struct mode_to_type {};
    //
    // were removed, since the regression logs (as of 24 Aug 2008)
    // showed that several compilers had troubles with recognizing
    //
    //   const mode m = access_by_bytes
    //
    // as a constant expression
    //
    // * So, we'll use bool, instead of enum *.
    //
    template <bool value>
    struct value_to_type
    {
        value_to_type() {}
    };
    const bool access_by_bytes = true;
    const bool access_by_blocks = false;


    // the table: wrapped in a class template, so
    // that it is only instantiated if/when needed
    //
    template <bool dummy_name = true>
    struct count_table { static const byte_type table[]; };

    template <>
    struct count_table<false> { /* no table */ };


    const unsigned int table_width = 8;
    template <bool b>
    const byte_type count_table<b>::table[] =
    {
        // Automatically generated by GPTableGen.exe v.1.0
        //
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    // Some platforms have fast popcount operation, that allow us to implement
    // counting bits much more efficiently
    //
    template <typename ValueType>
    BOOST_FORCEINLINE std::size_t popcount(ValueType value) BOOST_NOEXCEPT
    {
        std::size_t num = 0u;
        while (value) {
            num += count_table<>::table[value & ((1u<<table_width) - 1)];
            value >>= table_width;
        }
        return num;
    }

#if (((defined(BOOST_MSVC) && (BOOST_MSVC >= 1600)) || (defined(__clang__) && defined(__c2__)) || (defined(BOOST_INTEL) && defined(_MSC_VER))) && (defined(_M_IX86) || defined(_M_X64))) \
    && (defined(__POPCNT__) || defined(__AVX__))

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned short>(unsigned short value) BOOST_NOEXCEPT
    {
        return static_cast<std::size_t>(__popcnt16(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned int>(unsigned int value) BOOST_NOEXCEPT
    {
        return static_cast<std::size_t>(__popcnt(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned __int64>(unsigned __int64 value) BOOST_NOEXCEPT
    {
#if defined(_M_X64)
        return static_cast<std::size_t>(__popcnt64(value));
#else
        return static_cast<std::size_t>(__popcnt(static_cast< unsigned int >(value))) + static_cast<std::size_t>(__popcnt(static_cast< unsigned int >(value >> 32)));
#endif
    }

#elif defined(BOOST_GCC) || defined(__clang__) || (defined(BOOST_INTEL) && defined(__GNUC__))

    // Note: gcc builtins are implemented by compiler runtime when the target CPU may not support the necessary instructions
    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned short>(unsigned short value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcount(static_cast<unsigned int>(value)));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned int>(unsigned int value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcount(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned long>(unsigned long value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcountl(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<boost::ulong_long_type>(boost::ulong_long_type value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcountll(value));
    }

#endif

    // overload for access by blocks
    //
    template <typename Iterator, typename ValueType>
    inline std::size_t do_count(Iterator first, std::size_t length, ValueType,
                                value_to_type<access_by_blocks>*)
    {
        std::size_t num1 = 0u, num2 = 0u;
        while (length >= 2u) {
            num1 += popcount<ValueType>(*first);
            ++first;
            num2 += popcount<ValueType>(*first);
            ++first;
            length -= 2u;
        }

        if (length > 0u)
            num1 += popcount<ValueType>(*first);

        return num1 + num2;
    }

    // overload for access by bytes
    //
    template <typename Iterator>
    inline std::size_t do_count(Iterator first, std::size_t length,
                                int /*dummy param*/,
                                value_to_type<access_by_bytes>*)
    {
        if (length > 0u) {
            const byte_type* p = object_representation(&*first);
            length *= sizeof(*first);

            return do_count(p, length, static_cast<byte_type>(0u),
                static_cast< value_to_type<access_by_blocks>* >(0));
        }

        return 0u;
    }

    // -------------------------------------------------------


    // Some library implementations simply return a dummy
    // value such as
    //
    //   size_type(-1) / sizeof(T)
    //
    // from vector<>::max_size. This tries to get more
    // meaningful info.
    //
    template <typename T>
    inline typename T::size_type vector_max_size_workaround(const T & v)
        BOOST_NOEXCEPT
    {
        typedef typename T::allocator_type allocator_type;

        const allocator_type& alloc = v.get_allocator();

#if !defined(BOOST_NO_CXX11_ALLOCATOR)
        typedef std::allocator_traits<allocator_type> allocator_traits;

        const typename allocator_traits::size_type alloc_max =
            allocator_traits::max_size(alloc);
#else
        const typename allocator_type::size_type alloc_max = alloc.max_size();
#endif

        const typename T::size_type container_max = v.max_size();

        return alloc_max < container_max ? alloc_max : container_max;
    }

    // for static_asserts
    template <typename T>
    struct allowed_block_type {
        enum { value = T(-1) > 0 }; // ensure T has no sign
    };

    template <>
    struct allowed_block_type<bool> {
        enum { value = false };
    };


    template <typename T>
    struct is_numeric {
        enum { value = false };
    };

#   define BOOST_dynamic_bitset_is_numeric(x)       \
                template<>                          \
                struct is_numeric< x > {            \
                    enum { value = true };          \
                }                                /**/

    BOOST_dynamic_bitset_is_numeric(bool);
    BOOST_dynamic_bitset_is_numeric(char);

#if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
    BOOST_dynamic_bitset_is_numeric(wchar_t);
#endif

    BOOST_dynamic_bitset_is_numeric(signed char);
    BOOST_dynamic_bitset_is_numeric(short int);
    BOOST_dynamic_bitset_is_numeric(int);
    BOOST_dynamic_bitset_is_numeric(long int);

    BOOST_dynamic_bitset_is_numeric(unsigned char);
    BOOST_dynamic_bitset_is_numeric(unsigned short);
    BOOST_dynamic_bitset_is_numeric(unsigned int);
    BOOST_dynamic_bitset_is_numeric(unsigned long);

#if defined(BOOST_HAS_LONG_LONG)
    BOOST_dynamic_bitset_is_numeric(::boost::long_long_type);
    BOOST_dynamic_bitset_is_numeric(::boost::ulong_long_type);
#endif

    // intentionally omitted
    //BOOST_dynamic_bitset_is_numeric(float);
    //BOOST_dynamic_bitset_is_numeric(double);
    //BOOST_dynamic_bitset_is_numeric(long double);

#undef BOOST_dynamic_bitset_is_numeric

  } // dynamic_bitset_impl
  } // namespace detail

} // namespace boost

#endif // include guard


/* dynamic_bitset.hpp
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
*/