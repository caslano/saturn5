/*=============================================================================
    Copyright (c) 2001-2011 Joel de Guzman

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    This is an auto-generated file. Do not edit!
==============================================================================*/
namespace boost { namespace fusion { namespace detail
{
BOOST_FUSION_BARRIER_BEGIN
    template <bool is_assoc>
    struct as_map<1, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0;
            typedef map<T0> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            
            return result(gen::D0::call(i0));
        }
    };
    template <bool is_assoc>
    struct as_map<2, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1;
            typedef map<T0 , T1> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0);
            return result(gen::D0::call(i0) , gen::D1::call(i1));
        }
    };
    template <bool is_assoc>
    struct as_map<3, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2;
            typedef map<T0 , T1 , T2> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2));
        }
    };
    template <bool is_assoc>
    struct as_map<4, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3;
            typedef map<T0 , T1 , T2 , T3> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3));
        }
    };
    template <bool is_assoc>
    struct as_map<5, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4;
            typedef map<T0 , T1 , T2 , T3 , T4> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4));
        }
    };
    template <bool is_assoc>
    struct as_map<6, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5));
        }
    };
    template <bool is_assoc>
    struct as_map<7, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6));
        }
    };
    template <bool is_assoc>
    struct as_map<8, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7));
        }
    };
    template <bool is_assoc>
    struct as_map<9, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8));
        }
    };
    template <bool is_assoc>
    struct as_map<10, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9));
        }
    };
    template <bool is_assoc>
    struct as_map<11, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10));
        }
    };
    template <bool is_assoc>
    struct as_map<12, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11));
        }
    };
    template <bool is_assoc>
    struct as_map<13, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12));
        }
    };
    template <bool is_assoc>
    struct as_map<14, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12; typedef typename fusion::result_of::next<I12>::type I13;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12; typedef pair_from<I13, is_assoc> D13; typedef typename D13::type T13;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11); typename gen::I13 i13 = fusion::next(i12);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12) , gen::D13::call(i13));
        }
    };
    template <bool is_assoc>
    struct as_map<15, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12; typedef typename fusion::result_of::next<I12>::type I13; typedef typename fusion::result_of::next<I13>::type I14;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12; typedef pair_from<I13, is_assoc> D13; typedef typename D13::type T13; typedef pair_from<I14, is_assoc> D14; typedef typename D14::type T14;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11); typename gen::I13 i13 = fusion::next(i12); typename gen::I14 i14 = fusion::next(i13);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12) , gen::D13::call(i13) , gen::D14::call(i14));
        }
    };
    template <bool is_assoc>
    struct as_map<16, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12; typedef typename fusion::result_of::next<I12>::type I13; typedef typename fusion::result_of::next<I13>::type I14; typedef typename fusion::result_of::next<I14>::type I15;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12; typedef pair_from<I13, is_assoc> D13; typedef typename D13::type T13; typedef pair_from<I14, is_assoc> D14; typedef typename D14::type T14; typedef pair_from<I15, is_assoc> D15; typedef typename D15::type T15;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11); typename gen::I13 i13 = fusion::next(i12); typename gen::I14 i14 = fusion::next(i13); typename gen::I15 i15 = fusion::next(i14);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12) , gen::D13::call(i13) , gen::D14::call(i14) , gen::D15::call(i15));
        }
    };
    template <bool is_assoc>
    struct as_map<17, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12; typedef typename fusion::result_of::next<I12>::type I13; typedef typename fusion::result_of::next<I13>::type I14; typedef typename fusion::result_of::next<I14>::type I15; typedef typename fusion::result_of::next<I15>::type I16;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12; typedef pair_from<I13, is_assoc> D13; typedef typename D13::type T13; typedef pair_from<I14, is_assoc> D14; typedef typename D14::type T14; typedef pair_from<I15, is_assoc> D15; typedef typename D15::type T15; typedef pair_from<I16, is_assoc> D16; typedef typename D16::type T16;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11); typename gen::I13 i13 = fusion::next(i12); typename gen::I14 i14 = fusion::next(i13); typename gen::I15 i15 = fusion::next(i14); typename gen::I16 i16 = fusion::next(i15);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12) , gen::D13::call(i13) , gen::D14::call(i14) , gen::D15::call(i15) , gen::D16::call(i16));
        }
    };
    template <bool is_assoc>
    struct as_map<18, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12; typedef typename fusion::result_of::next<I12>::type I13; typedef typename fusion::result_of::next<I13>::type I14; typedef typename fusion::result_of::next<I14>::type I15; typedef typename fusion::result_of::next<I15>::type I16; typedef typename fusion::result_of::next<I16>::type I17;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12; typedef pair_from<I13, is_assoc> D13; typedef typename D13::type T13; typedef pair_from<I14, is_assoc> D14; typedef typename D14::type T14; typedef pair_from<I15, is_assoc> D15; typedef typename D15::type T15; typedef pair_from<I16, is_assoc> D16; typedef typename D16::type T16; typedef pair_from<I17, is_assoc> D17; typedef typename D17::type T17;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11); typename gen::I13 i13 = fusion::next(i12); typename gen::I14 i14 = fusion::next(i13); typename gen::I15 i15 = fusion::next(i14); typename gen::I16 i16 = fusion::next(i15); typename gen::I17 i17 = fusion::next(i16);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12) , gen::D13::call(i13) , gen::D14::call(i14) , gen::D15::call(i15) , gen::D16::call(i16) , gen::D17::call(i17));
        }
    };
    template <bool is_assoc>
    struct as_map<19, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12; typedef typename fusion::result_of::next<I12>::type I13; typedef typename fusion::result_of::next<I13>::type I14; typedef typename fusion::result_of::next<I14>::type I15; typedef typename fusion::result_of::next<I15>::type I16; typedef typename fusion::result_of::next<I16>::type I17; typedef typename fusion::result_of::next<I17>::type I18;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12; typedef pair_from<I13, is_assoc> D13; typedef typename D13::type T13; typedef pair_from<I14, is_assoc> D14; typedef typename D14::type T14; typedef pair_from<I15, is_assoc> D15; typedef typename D15::type T15; typedef pair_from<I16, is_assoc> D16; typedef typename D16::type T16; typedef pair_from<I17, is_assoc> D17; typedef typename D17::type T17; typedef pair_from<I18, is_assoc> D18; typedef typename D18::type T18;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11); typename gen::I13 i13 = fusion::next(i12); typename gen::I14 i14 = fusion::next(i13); typename gen::I15 i15 = fusion::next(i14); typename gen::I16 i16 = fusion::next(i15); typename gen::I17 i17 = fusion::next(i16); typename gen::I18 i18 = fusion::next(i17);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12) , gen::D13::call(i13) , gen::D14::call(i14) , gen::D15::call(i15) , gen::D16::call(i16) , gen::D17::call(i17) , gen::D18::call(i18));
        }
    };
    template <bool is_assoc>
    struct as_map<20, is_assoc>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10; typedef typename fusion::result_of::next<I10>::type I11; typedef typename fusion::result_of::next<I11>::type I12; typedef typename fusion::result_of::next<I12>::type I13; typedef typename fusion::result_of::next<I13>::type I14; typedef typename fusion::result_of::next<I14>::type I15; typedef typename fusion::result_of::next<I15>::type I16; typedef typename fusion::result_of::next<I16>::type I17; typedef typename fusion::result_of::next<I17>::type I18; typedef typename fusion::result_of::next<I18>::type I19;
            typedef pair_from<I0, is_assoc> D0; typedef typename D0::type T0; typedef pair_from<I1, is_assoc> D1; typedef typename D1::type T1; typedef pair_from<I2, is_assoc> D2; typedef typename D2::type T2; typedef pair_from<I3, is_assoc> D3; typedef typename D3::type T3; typedef pair_from<I4, is_assoc> D4; typedef typename D4::type T4; typedef pair_from<I5, is_assoc> D5; typedef typename D5::type T5; typedef pair_from<I6, is_assoc> D6; typedef typename D6::type T6; typedef pair_from<I7, is_assoc> D7; typedef typename D7::type T7; typedef pair_from<I8, is_assoc> D8; typedef typename D8::type T8; typedef pair_from<I9, is_assoc> D9; typedef typename D9::type T9; typedef pair_from<I10, is_assoc> D10; typedef typename D10::type T10; typedef pair_from<I11, is_assoc> D11; typedef typename D11::type T11; typedef pair_from<I12, is_assoc> D12; typedef typename D12::type T12; typedef pair_from<I13, is_assoc> D13; typedef typename D13::type T13; typedef pair_from<I14, is_assoc> D14; typedef typename D14::type T14; typedef pair_from<I15, is_assoc> D15; typedef typename D15::type T15; typedef pair_from<I16, is_assoc> D16; typedef typename D16::type T16; typedef pair_from<I17, is_assoc> D17; typedef typename D17::type T17; typedef pair_from<I18, is_assoc> D18; typedef typename D18::type T18; typedef pair_from<I19, is_assoc> D19; typedef typename D19::type T19;
            typedef map<T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19> type;
        };
        template <typename Iterator>
        BOOST_CXX14_CONSTEXPR BOOST_FUSION_GPU_ENABLED
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8); typename gen::I10 i10 = fusion::next(i9); typename gen::I11 i11 = fusion::next(i10); typename gen::I12 i12 = fusion::next(i11); typename gen::I13 i13 = fusion::next(i12); typename gen::I14 i14 = fusion::next(i13); typename gen::I15 i15 = fusion::next(i14); typename gen::I16 i16 = fusion::next(i15); typename gen::I17 i17 = fusion::next(i16); typename gen::I18 i18 = fusion::next(i17); typename gen::I19 i19 = fusion::next(i18);
            return result(gen::D0::call(i0) , gen::D1::call(i1) , gen::D2::call(i2) , gen::D3::call(i3) , gen::D4::call(i4) , gen::D5::call(i5) , gen::D6::call(i6) , gen::D7::call(i7) , gen::D8::call(i8) , gen::D9::call(i9) , gen::D10::call(i10) , gen::D11::call(i11) , gen::D12::call(i12) , gen::D13::call(i13) , gen::D14::call(i14) , gen::D15::call(i15) , gen::D16::call(i16) , gen::D17::call(i17) , gen::D18::call(i18) , gen::D19::call(i19));
        }
    };
BOOST_FUSION_BARRIER_END
}}}

/* as_map20.hpp
UyAZmStAWa2iJi9tERdG4JVM78Mq8Myx7MBhygcjr/7rlf0W8R/xDYCC5kyBsF2LBlfzIMGDp9bra8Mq+g1Sz5e47rdHS/jSSSDBsS8C7MnOAEISGJYRCYacWk+tDj9WpokIB1HF9K/o7YsHZgleF3mfqC0tJ2DEf1YUOvTssAisw/6t6yDB70+tE88+RoUL3CeDbvP4pj/VEfZOIlj8qiVd62BnFwEovO4BMk+twWvDpj1zvOmm9ymg2/hWgU5Z7nFPaU7ZSRoTCBhXNf/cB66709Cd7PIryfyObHUNifMmqgCDHTH0m1xnNCtjbQflAJ651W2J2oA7r1gZ1gH/9ToxDHzTVnRraEEVoNV7gSFHyKhCB/HWzq2k2U4+KS5PTk9oGqRuv4Z8eWP9VhPYEsIobDnuD+RlJgSPCbQP6fYOJ+1RYiiEo1Le+eLXBtA+5P7X+cGY+GYa5hBcWwTIjNRCJW9fx6T30trQsKRDWncYf4yJxQrPnQYJfN1sSYs/Mc8HzmVwiXgiofvrLmwLH2F7Q/wKOt5Z6UqOEpR/JD13msi9QpGuc10x9r1WWG3r33YcEj83loGejafpHtJ1L4qeyrpVUlnRzUqI1DGrwO7/261DhvJbQPnJIHDKUhGGj4uP8EkWpf8sDHCRYLByl3VbgwcfLiWuOj9UabDPZSVyV4tGidnQlBukfhLaCL2A89c9Jjyfc8Dg9K2CsjJuAPJpBT7meV9ckqmqJ6FfdFSyW/2iyTi/9keAyUwYdnfl/8zxSf/2ZMZiH6EKaFDBsHJAe3md/8Xv5HslOwLywnWvbW3OUtNDf23Fxve2vjZy6aXtDERb4wqQcSExTQwAoqx7YaES0wPbqqWtoy1WSd7nNCynNQxFz3FFAuNSt1NICFipWEKsGDN1V8NoBni53NbebSQ7z/0EfEN3eTA1Wei8440hvEeds+1UNE9jEC/DNb81d4gNAmVpqkmLpS9v6Ty9TdTjNkrWr2MSDAAA1aVxY4pb1lHVTrTiHWaqGM9XpYTOTDrzZBU14i4WmhjZJMlJ5tDwHcpFmSWnQHEUAMTJJtDchGlKvTcLS3pOoGOT4vmsXObTw+MJAqTSSictqhYxxWuJtPn1yoT15wGduoTp1xgsACTs/Bnd15TwcWrZujYd4j1yyQrnc2avShRn2QlemNIcb9dEhnKt09IP3mzeWlQ0O4uoE0ECgEmV3YvlSaX3brl/WKts7kjKka0i5FhRD6fKot7AR6zs3nwsJeml2yuEIjJXP9Q/NfjIzZ5+CWj6O5guY/G8LBEz7cfyPOsxQn289Z+mta08V6iaaN0Cy1Nt02JZ9ui8DJsLahOa1UWF7h+pkNYBAPxKLpX7nMqHe+UZaPpch7Y2F0FQfJYs9oILiB5eKQ+oec3ZVjxsFn2oGd/ygvbr3X1m7cPCjztRx+JII4VkCWwUGsF/5cwjd0I3W7BzSP8rO6VwavgHOsbFdJUv78BQH1Nl/amMudg/a9m9c3hmdxwd53e91QSzCfVSzQk0FDt/+0beslg5obXae9vFf4WjiUSu5pViTP7nuub6xlu81h1x2edCyG26S8DCfofKLcLa/XeMJui5Mf+bE2U2bh/zjg7Bt9eaUmIhz91n5gb8VFffHYX7lJE4/pxUAHRv1uH5AEFM3C58x89UGag09UtYnFN+fVfiDV1Je85sZZjma+425Nrkh1KAsH4tzoVWYXh8Ka2976ucx7AjmmM5/iC/+u8J82qOXzCTSSmyvm9YP4MWY4zOZTi1XT4CgHBfEVjkSyHGFFmi/4upt46K6v2ixhVEBKQRBCSkkZKhu7tDEARGaUSkpMGR7s6hQ7okFMmhW7pBujuGmGGY+8PP933X711r/pt9n3tn1jn77D1zzvOIEJ7te3U2lmG4S5Kr8hBusrcqAD93U9V4yv5PE+MQxQVPuPjgmhHZ3cpWA1zae9xVELw1cuGs/cbjGPtQt4Vg3PTScAzCXKD0l/GQYxZkpwAIKe6ebLHfvVv+43PeFiM9eZRQDKcuzvoCxNSSHNelyl/OWsZos7RmdtpdsflkvoF81ANyZQDYqepNhOFCma9Wz2ELT8dk5dO+KNyWsi+xGtT2FfvLmTGOF5R21Fu3R5sVBhQ+l81G5Ud/YwCgk9HEUGvIi45j61US1hirxMyqrQ4HZJkBclBTj3/u93MdY5YFkv0Aa/U52QPIi4zpnnxMyOXx0Um5MZmk62P1a9bpDezx9pE7RZAqabbin/OWdGd/+7XulPv0I+2IlXl4GoixGuBYPA4AWo2AtYGM8eZddYpB62vjs9cOjI4/B/jsifDdjD6lXherJHEPjn4ZPGlIdpsW/G28b7ZhvgYA2EYGswvNp5jHCdd1uH1jVKjvH0Ua3rBWNnFerQbMMZ5okVqskt9n4LxOQdvYyE0A1R0AYVyAsS7wOHXqjo7vl16qvriZiv0ZlgbJSbv3RlEU3yn+Gk5yHukwwPav82CTAMIw/0503Gw07iCmBXS1vw9NNr4BKXSjxM3RAnsK9vT4TosZq68+bl53hE9REjIVSF3wnLtrbjwqFduLmG/Q7Yzwo5RkGKTyJLCnJ5xpF7gBsd+XTGEP6piNesKYyZGbVcpLiPXJptielUxbJ0OvRk9mE9tWZlNCHO7a0JIFz9Wb/12R+zRoI20rUC1psqhNRBISyHNB3jbM6UtJ6gt1vwFNn1r9g3dtIF+JrY9ufKYZWnyhaHnVqzWN06dfgDZEfJ5xVvUJ1bt8xfrDDdaOp6zAfD4jGWgbhzdOr4ZerNiddTJoiKGJpZpvcRZyDuB5PwWE26JC3Dwvu/RIjF+W6yp4BpK7mjckCQzep/CU3K04Lxf59eHrTK83kOEINMWT6OrwFL1Dg93Ug7snUCtTOLjf7xkR3wkJH98WjOtIjFVLZXRiZn1i8hvgOlmEHiOA3PKc/0VxI2PfR0oULhg+MCqK+xvG854wSZnHIxwKPU8yGIMEtyGlZjeApaBI2Vvuu9FTe4O3oZlB4MnR7HhycxcsXhG6r39obgQMTx9IYcO2mYptZM+ql8Y86vMhjiuQSLRfOCqxouhKjQcW/vWhG1x2j5mOoYsm7Knh6mxmlyviO4rcLPxrljgzj1cky9jKHwrbjev53uZqx8KmuaRVexMWqZWXfiWpScc1e0nFLvi40hH1l+focsb3v+v//H79c9VxJQbmfH11Pf2UMT/YoyXYcyxC6Q31ErvEbZmZlptLztF5RouqpkoHPqumceXXL84G5dTADu2M7h80YBxZ/cGqIWXyidtv4qkNdPUXoi0M8cAncUOQoYAnTrQM0pyGxIrWZyE8G93DPSUAqWuoUP5cJ7SB62TTwJoo2dPg2evY32oZA5/WxevC3yKApqqFjph0zbCIv82oHKkN7F+dJrYk6W+l+Hm31ksotDF3fiXZ5HIHNDUXBZO+qzws1+GZ0F4yakkzEl7HcIgazVkN40p0Zs0NL8U0odtMldS05lApkVkQ60ZxdKMsb0C8p1ayZxjXnV29xG1ROgCjpr9a5rfMOLMQkUk+dXe6hBXfrHotyp2V3rxLEK8UJev+82zrJ8eToZQIsXXQ/fr7UyViWUNzpmYylcpKq9FR7UP0BOLxZopWLwy08Fvi/ZJFqWJZzkOlKYWjIOWMo9ffZAAJC0eawIMmE0oOkmeZVNVJKw1NH9gdVRCghu//ypYNuDCmtyB8oMPThK53diE+PlkHQtM2jOEL1bkB/ZXfeJzvjLP8O1bEKhkTvE1ScFbXvWlrLvs6HvGadiHmhvf5nf/s3Mvmb6G3TxgtmWEVr5eNZSE6+SG9my/MXR7zIjg5A0lPrQKcsc/I/P5y/H4H0Ix7mnl7jeJ8Mh1l/4D/Qx/5ioVFiollJQiR7B+pzsB79Che5Enx5zq0JsTiT5RUh/ztsLLMQXBPnJXqy6FdRHJo9/CnJwx7RKQkL1nk16Zoguh+78caT4+mPhfCPrJ/smDI6tP0s/fMDF2pfrz7EpX+KQxn79ReH3yfMxsTBZyPtcR7K/c4YNYEX/8QodI1bwTcTu3N2qu9+tlzPt0I3ENJXoLk14RoH9HZ8PhZ5d/pHYPADDCVY9n5ytFSB47UvCdf/2DeCMxnvlENTc61rH8Gpxg3BHa47rLQo02O1XENtWF+QT3dbSSKUNHqmeo1nK/dDd8rU07KsSl+m43HpPzSaas2c5+Cr2OMq1UuHwItmrRG7RwQsuX3QvPyjUaDSVOfzp/PDr0o00jtZ7dx9oplKX6khy2ibu3cbTq/C7Qo0hrRx0bFKTV9iJ2SE2Z/mSHOkLH5WmuA/lc2c3Hm+18kw1qesg+d3m+7tBMBK7rh6V13DmG/Esv0ad6UUtQTvhyy1MtTZXVl0S2OCHhC1J3ZSdoWhckXiRlyA1NN/nhvFnEuCYyZmb7IpuwFNM4zIx0Oq+xCOYssoWwuqkRoZ9phzhdpRs/vECvSRBkfFPmfyKhDs7y5f4ZPPvxz+GHMFhJom6NYL4UJZklIo3ti1BvYf/K+g8ITf8ghXVhKOdORccRwQ+Ui0xaSYwvB7NxQ6EXgdKOUy3j9PUs8X5975IIspsAdz+widK4fBFUL9i6/mZgtaWkUxRi1ePSV5gACLP3TH34NZ6yNIXzAf8pyyTm9xmbTDg4xKyLJZ4Jy0UUa7H5/070mq7jqNcVdxUugxUyVk2IGr6jq3WSc4l+ihL7b5yEOZS0xhBOHvlsd0ieJziGOPulIbVRU12Q2zmZhodvJkAho+CXG+O5Wo006toPundZqNGkoGLTiWFSmXaOSMm6bOfTk9JUlFE8+w9N8m9e67qETKcHRhNAtJscz5yheEx7n2vAaKxFnzhxbqFp9iyp/s7R6TGiG09PPsg+6g+SixI+ccZdgcrA0b0ipfL4Zm6DGb+IkuZqB0Ow4PNazV9w8FLvMtCyzvP08D3/b0ATcvC+thp5xQA1VpgoPFzh2+MsUh3xtTTzWZi07UBPQgoQeqhJO9tSXD467ruEQGYAaCR4DgtA+8NkxsAIg8G+CJF/KZoxOYaVeDmz3HRI3D+l5dmOz9ORrACrfEqr6UW56Qq1otxrEZyoDwbnzelWu57PPs4EhpfIsN6esMiFHtQQrdSAHriLl1dI4+72y979u3wG/F6m/dJa1aDSaNuYcYzdiedE8zorOAYmZfpnFDmsSlZaZv2VSGkO1OgQ+CpZ66mb2em0Ko9mVnGqc+zj6aPsYLFAQLD3rTO/wq7JuTuYh/ef9oEbhAnAwp+tDtIq4JdTihwFGv1Ho6WnDyhUgdGvoAZo5+L4+gVXwG887bjve97zftB9kZJlIVjvAXqvyyOGBa4qcJbkPKHIc8Mqu4JVd1Di2Xcr0cetM4k+0Ag0wstcXlxApjCEnaRnqPt0A1Jc7JQT4ejT7RQ7tXLVfEjkLDrA8bPlKabKKoxkXlMaQekcejOeLxNBr6vU6749p/VEs2WHb3wzs1J47SuW1amTCZH2ycVVejKPZKqUsXIQYYDTxf0qk5KYE1l7PqhxWLrIMRX1KsPo8bvaSIKdAllZNUEJV/cpC/UDRku/g2uHWYrYOd/bbpC6j6w8WZbUFSQaCFQYCsHWQV4ztCzV+PFZr5HgqdXxHDM9QiRSWkfW3kmkCn/KQuctO6ZSBlxgmDDHMpFxanak4OxmXwaj1wVR7DfAACLO7yp3BEr+gjatWvQCexuj3J+wr3y3tz+rEsdzOtaGbiUgORi0xvLZ2Jkvow36Qg/wPKnG1iLBEwnALoXC+VPohprUnbiQ8a06e+G1xSiaUXsaT1flF+q0iCT54iC18JMcuT2RbghW3Cg9efjV/eSKcRJOnzYlSH2xK0MSFiuYoZX+jsumYbLasx2MWWFQ5rHrp0ajCQwnPR+INq+9Ybi/jNtY6vFuZiWg7t0euzdZ3VpeGgC8yzWjHhjT6QZSn9gmrs93SWU+6GiZSi+tT0cKWUMkbAa44q7LVWfFQcJ1MykAIOFGGxyZPqls6/UmgzRqmWBdW27dCNL9vm0xJBjL72ZAbx7vmtPlbRjuOzTshlepUyumsRFg5txMyK1QP7yzxF2VqngHqSOxU6Hj5q5TGVLbGj4rHlKlPdT30FkblbL+KnO+4nd/SvNfwekAhzDwU1BVwpjD/jNClWQOAuPpmb/6lXMV32BAryQvQtaQfWpI/IvmoUvEpM4iTNKaI53ivyqSR5mzluVTfgLNfhWF93F6ZbU7iyXFBokaG/4LRlHl/4Id6yU1OihYqh0aXAvRzdWhq/Z9h51d2eAM0irXqokdG58pPHdh4/4bOYOEvOgCQOogbhWsAdy2Y4kKkUkbiPqzgEW2/7FCt8gu2C9rGdC4ReJWVwQDwZGOfdoGljO5Z9wXGgk/9LOWz4nGWCUXSUDnbVjvTMJxfGYiekpWRkSJ3345L/MpcLvrspYJWzUNVRlkWktACr1G5MMRyPbe85jvv+b3YyqcVn9s6FNvg5xq16reCRttURwptuXy+xaynl0/zLkPE1tQt6/7CAaG+hpcMKhSSvvi+J1bN/aDE/GpfaOTEkDBSlVzPWOmJOqmjt7O11rfCNpwEfdb6VG9zQ3b90uJTq+OJjTfe6sGYCQ+4mCPaAvaG8ECRfB4fhvSQzqFfGcU600vYBdaISv0kBOKsqiYM79n2URqnzmuNgL2eyB3rGbq5PKkwuTRrs8JnHEZFQW3Z0sONcv9a3LlXGTKleXSW1F5fr/fULYw11OSDeZx17R8evP67nAfDhW4JCLyR0FnsHJb1UclNZbsR6Di1b/FUHfEseTd7z5rY8NlxSCj6FbJ6HKwIPPv3v91Xw5XD0QpLqHs/6GecVUTDAOggw5Jy2tDaOVK8YRJOosIjg+ImuHjntN7wqeud5RSdeUp50DeGjzE9h4Vs8dd6O76N55b3wfgiucSDOPuA0uBSs/0dTryBh376nFp1swrnHTCN/SNJjLPApYw7t4BkIzvf3dCYeYhNivUZOrvpieDq+SzTqFJya26VcNfbGmY09V2OgOubjpRy6wYl/Bd1xl6S3sEe2ov0QybSfA8Z1Mn0U98/5zZjE+va/fHS9c42LAeTrd61+Ccb2aTk2oLgPWmarGE9eVI8HiXPp2wsUV442h3O0bA2GI28Q32ilnon9254VHKZZehLf7/JItmXdTtGow78fImW6hPIQ4+tFdZzkf9N1bq9W9pLqYL+feThcU3EL43x0tYpAGv9kQc+k6eTR7Tbgs9ttqRNlYhNFcK9biZaX+bZXrbUdpbmCfzC4K5s36h6mVAM7+KQc9Q5YjlXanSFsuCo2CGwER01E8fJx4i8OGS3p1ajVj/Aquwn1ghEL2HBvGMiRPv2B15cKDvkTGSzDJGNLxdo5EUX4hddfneTH0ifeQtJmR+iXpB8vs1VrxWVYEU7Zh2fFS9L3cVKoX4wwOH8neIADw2TgTz+ujY833YbsgvbeBpqDcpkGRKnv2WMFAzOjH/u/fR+NSWlr3ozLAiME+VXlMwq31NbEqx1dbLjLswzOROx1MSgyxa7QmG0Ens9D12a2XPAO1FKw5SXJgtk9qrpyLwBnmYQaJwWTyVlYNMwWz12HP5cniUM+6Tf3+PDn+bfFdWlzIxO7j7Kz+zy+/rgbumcesox
*/