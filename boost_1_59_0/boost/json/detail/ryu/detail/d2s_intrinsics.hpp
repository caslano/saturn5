// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.

/*
    This is a derivative work
*/

#ifndef BOOST_JSON_DETAIL_RYU_DETAIL_D2S_INTRINSICS_HPP
#define BOOST_JSON_DETAIL_RYU_DETAIL_D2S_INTRINSICS_HPP

#include <boost/json/detail/config.hpp>

// This sets BOOST_JSON_RYU_32_BIT_PLATFORM as a side effect if applicable.
#include <boost/json/detail/ryu/detail/common.hpp>

#if defined(BOOST_JSON_RYU_HAS_64_BIT_INTRINSICS)
#include <intrin.h>
#endif

BOOST_JSON_NS_BEGIN
namespace detail {

namespace ryu {
namespace detail {

#if defined(BOOST_JSON_RYU_HAS_64_BIT_INTRINSICS)

inline uint64_t umul128(const uint64_t a, const uint64_t b, uint64_t* const productHi) {
  return _umul128(a, b, productHi);
}

inline uint64_t shiftright128(const uint64_t lo, const uint64_t hi, const uint32_t dist) {
  // For the __shiftright128 intrinsic, the shift value is always
  // modulo 64.
  // In the current implementation of the double-precision version
  // of Ryu, the shift value is always < 64. (In the case
  // RYU_OPTIMIZE_SIZE == 0, the shift value is in the range [49, 58].
  // Otherwise in the range [2, 59].)
  // Check this here in case a future change requires larger shift
  // values. In this case this function needs to be adjusted.
  BOOST_ASSERT(dist < 64);
  return __shiftright128(lo, hi, (unsigned char) dist);
}

#else // defined(HAS_64_BIT_INTRINSICS)

inline uint64_t umul128(const uint64_t a, const uint64_t b, uint64_t* const productHi) {
  // The casts here help MSVC to avoid calls to the __allmul library function.
  const uint32_t aLo = (uint32_t)a;
  const uint32_t aHi = (uint32_t)(a >> 32);
  const uint32_t bLo = (uint32_t)b;
  const uint32_t bHi = (uint32_t)(b >> 32);

  const uint64_t b00 = (uint64_t)aLo * bLo;
  const uint64_t b01 = (uint64_t)aLo * bHi;
  const uint64_t b10 = (uint64_t)aHi * bLo;
  const uint64_t b11 = (uint64_t)aHi * bHi;

  const uint32_t b00Lo = (uint32_t)b00;
  const uint32_t b00Hi = (uint32_t)(b00 >> 32);

  const uint64_t mid1 = b10 + b00Hi;
  const uint32_t mid1Lo = (uint32_t)(mid1);
  const uint32_t mid1Hi = (uint32_t)(mid1 >> 32);

  const uint64_t mid2 = b01 + mid1Lo;
  const uint32_t mid2Lo = (uint32_t)(mid2);
  const uint32_t mid2Hi = (uint32_t)(mid2 >> 32);

  const uint64_t pHi = b11 + mid1Hi + mid2Hi;
  const uint64_t pLo = ((uint64_t)mid2Lo << 32) | b00Lo;

  *productHi = pHi;
  return pLo;
}

inline uint64_t shiftright128(const uint64_t lo, const uint64_t hi, const uint32_t dist) {
  // We don't need to handle the case dist >= 64 here (see above).
  BOOST_ASSERT(dist < 64);
#if defined(RYU_OPTIMIZE_SIZE) || !defined(RYU_32_BIT_PLATFORM)
  BOOST_ASSERT(dist > 0);
  return (hi << (64 - dist)) | (lo >> dist);
#else
  // Avoid a 64-bit shift by taking advantage of the range of shift values.
  BOOST_ASSERT(dist >= 32);
  return (hi << (64 - dist)) | ((uint32_t)(lo >> 32) >> (dist - 32));
#endif
}

#endif // defined(HAS_64_BIT_INTRINSICS)

#ifdef RYU_32_BIT_PLATFORM

// Returns the high 64 bits of the 128-bit product of a and b.
inline uint64_t umulh(const uint64_t a, const uint64_t b) {
  // Reuse the umul128 implementation.
  // Optimizers will likely eliminate the instructions used to compute the
  // low part of the product.
  uint64_t hi;
  umul128(a, b, &hi);
  return hi;
}

// On 32-bit platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// NB:
// The multipliers and shift values are the ones generated by clang x64
// for expressions like x/5, x/10, etc.

inline uint64_t div5(const uint64_t x) {
  return umulh(x, 0xCCCCCCCCCCCCCCCDu) >> 2;
}

inline uint64_t div10(const uint64_t x) {
  return umulh(x, 0xCCCCCCCCCCCCCCCDu) >> 3;
}

inline uint64_t div100(const uint64_t x) {
  return umulh(x >> 2, 0x28F5C28F5C28F5C3u) >> 2;
}

inline uint64_t div1e8(const uint64_t x) {
  return umulh(x, 0xABCC77118461CEFDu) >> 26;
}

inline uint64_t div1e9(const uint64_t x) {
  return umulh(x >> 9, 0x44B82FA09B5A53u) >> 11;
}

inline uint32_t mod1e9(const uint64_t x) {
  // Avoid 64-bit math as much as possible.
  // Returning (uint32_t) (x - 1000000000 * div1e9(x)) would
  // perform 32x64-bit multiplication and 64-bit subtraction.
  // x and 1000000000 * div1e9(x) are guaranteed to differ by
  // less than 10^9, so their highest 32 bits must be identical,
  // so we can truncate both sides to uint32_t before subtracting.
  // We can also simplify (uint32_t) (1000000000 * div1e9(x)).
  // We can truncate before multiplying instead of after, as multiplying
  // the highest 32 bits of div1e9(x) can't affect the lowest 32 bits.
  return ((uint32_t) x) - 1000000000 * ((uint32_t) div1e9(x));
}

#else // RYU_32_BIT_PLATFORM

inline uint64_t div5(const uint64_t x) {
  return x / 5;
}

inline uint64_t div10(const uint64_t x) {
  return x / 10;
}

inline uint64_t div100(const uint64_t x) {
  return x / 100;
}

inline uint64_t div1e8(const uint64_t x) {
  return x / 100000000;
}

inline uint64_t div1e9(const uint64_t x) {
  return x / 1000000000;
}

inline uint32_t mod1e9(const uint64_t x) {
  return (uint32_t) (x - 1000000000 * div1e9(x));
}

#endif // RYU_32_BIT_PLATFORM

inline uint32_t pow5Factor(uint64_t value) {
  uint32_t count = 0;
  for (;;) {
    BOOST_ASSERT(value != 0);
    const uint64_t q = div5(value);
    const uint32_t r = ((uint32_t) value) - 5 * ((uint32_t) q);
    if (r != 0) {
      break;
    }
    value = q;
    ++count;
  }
  return count;
}

// Returns true if value is divisible by 5^p.
inline bool multipleOfPowerOf5(const uint64_t value, const uint32_t p) {
  // I tried a case distinction on p, but there was no performance difference.
  return pow5Factor(value) >= p;
}

// Returns true if value is divisible by 2^p.
inline bool multipleOfPowerOf2(const uint64_t value, const uint32_t p) {
  BOOST_ASSERT(value != 0);
  // return __builtin_ctzll(value) >= p;
  return (value & ((1ull << p) - 1)) == 0;
}


} // detail
} // ryu

} // detail
BOOST_JSON_NS_END

#endif

/* d2s_intrinsics.hpp
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
*/