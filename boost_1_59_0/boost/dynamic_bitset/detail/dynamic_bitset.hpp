// -----------------------------------------------------------
//
//   Copyright (c) 2001-2002 Chuck Allison and Jeremy Siek
//   Copyright (c) 2003-2006, 2008 Gennaro Prota
//   Copyright (c) 2014 Glen Joseph Fernandes
//       (glenjofe@gmail.com)
//   Copyright (c) 2018 Evgeny Shulgin
//   Copyright (c) 2019 Andrey Semashev
//
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//
// -----------------------------------------------------------

#ifndef BOOST_DETAIL_DYNAMIC_BITSET_HPP
#define BOOST_DETAIL_DYNAMIC_BITSET_HPP

#include <memory>
#include <cstddef>
#include "boost/config.hpp"
#include "boost/detail/workaround.hpp"
#include <boost/core/allocator_access.hpp>

#if ((defined(BOOST_MSVC) && (BOOST_MSVC >= 1600)) || (defined(__clang__) && defined(__c2__)) || (defined(BOOST_INTEL) && defined(_MSC_VER))) && (defined(_M_IX86) || defined(_M_X64))
#include <intrin.h>
#endif

namespace boost {

  namespace detail {
  namespace dynamic_bitset_impl {

    template<class T>
    struct max_limit {
        BOOST_STATIC_CONSTEXPR T value = static_cast<T>(-1);
    };

    template<class T>
    BOOST_CONSTEXPR_OR_CONST T max_limit<T>::value;

    // Gives (read-)access to the object representation
    // of an object of type T (3.9p4). CANNOT be used
    // on a base sub-object
    //
    template <typename T>
    inline const unsigned char * object_representation (T* p)
    {
        return static_cast<const unsigned char *>(static_cast<const void *>(p));
    }

    template<typename T, int amount, int width /* = default */>
    struct shifter
    {
        static void left_shift(T & v) {
            amount >= width ? (v = 0)
                : (v >>= BOOST_DYNAMIC_BITSET_WRAP_CONSTANT(amount));
        }
    };

    // ------- count function implementation --------------

    typedef unsigned char byte_type;

    // These two entities
    //
    //     enum mode { access_by_bytes, access_by_blocks };
    //     template <mode> struct mode_to_type {};
    //
    // were removed, since the regression logs (as of 24 Aug 2008)
    // showed that several compilers had troubles with recognizing
    //
    //   const mode m = access_by_bytes
    //
    // as a constant expression
    //
    // * So, we'll use bool, instead of enum *.
    //
    template <bool value>
    struct value_to_type
    {
        value_to_type() {}
    };
    const bool access_by_bytes = true;
    const bool access_by_blocks = false;


    // the table: wrapped in a class template, so
    // that it is only instantiated if/when needed
    //
    template <bool dummy_name = true>
    struct count_table { static const byte_type table[]; };

    template <>
    struct count_table<false> { /* no table */ };


    const unsigned int table_width = 8;
    template <bool b>
    const byte_type count_table<b>::table[] =
    {
        // Automatically generated by GPTableGen.exe v.1.0
        //
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    // Some platforms have fast popcount operation, that allow us to implement
    // counting bits much more efficiently
    //
    template <typename ValueType>
    BOOST_FORCEINLINE std::size_t popcount(ValueType value) BOOST_NOEXCEPT
    {
        std::size_t num = 0u;
        while (value) {
            num += count_table<>::table[value & ((1u<<table_width) - 1)];
            value >>= table_width;
        }
        return num;
    }

#if (((defined(BOOST_MSVC) && (BOOST_MSVC >= 1600)) || (defined(__clang__) && defined(__c2__)) || (defined(BOOST_INTEL) && defined(_MSC_VER))) && (defined(_M_IX86) || defined(_M_X64))) \
    && (defined(__POPCNT__) || defined(__AVX__))

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned short>(unsigned short value) BOOST_NOEXCEPT
    {
        return static_cast<std::size_t>(__popcnt16(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned int>(unsigned int value) BOOST_NOEXCEPT
    {
        return static_cast<std::size_t>(__popcnt(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned __int64>(unsigned __int64 value) BOOST_NOEXCEPT
    {
#if defined(_M_X64)
        return static_cast<std::size_t>(__popcnt64(value));
#else
        return static_cast<std::size_t>(__popcnt(static_cast< unsigned int >(value))) + static_cast<std::size_t>(__popcnt(static_cast< unsigned int >(value >> 32)));
#endif
    }

#elif defined(BOOST_GCC) || defined(__clang__) || (defined(BOOST_INTEL) && defined(__GNUC__))

    // Note: gcc builtins are implemented by compiler runtime when the target CPU may not support the necessary instructions
    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned short>(unsigned short value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcount(static_cast<unsigned int>(value)));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned int>(unsigned int value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcount(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<unsigned long>(unsigned long value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcountl(value));
    }

    template <>
    BOOST_FORCEINLINE std::size_t popcount<boost::ulong_long_type>(boost::ulong_long_type value) BOOST_NOEXCEPT
    {
        return static_cast<unsigned int>(__builtin_popcountll(value));
    }

#endif

    // overload for access by blocks
    //
    template <typename Iterator, typename ValueType>
    inline std::size_t do_count(Iterator first, std::size_t length, ValueType,
                                value_to_type<access_by_blocks>*)
    {
        std::size_t num1 = 0u, num2 = 0u;
        while (length >= 2u) {
            num1 += popcount<ValueType>(*first);
            ++first;
            num2 += popcount<ValueType>(*first);
            ++first;
            length -= 2u;
        }

        if (length > 0u)
            num1 += popcount<ValueType>(*first);

        return num1 + num2;
    }

    // overload for access by bytes
    //
    template <typename Iterator>
    inline std::size_t do_count(Iterator first, std::size_t length,
                                int /*dummy param*/,
                                value_to_type<access_by_bytes>*)
    {
        if (length > 0u) {
            const byte_type* p = object_representation(&*first);
            length *= sizeof(*first);

            return do_count(p, length, static_cast<byte_type>(0u),
                static_cast< value_to_type<access_by_blocks>* >(0));
        }

        return 0u;
    }

    // -------------------------------------------------------


    // Some library implementations simply return a dummy
    // value such as
    //
    //   size_type(-1) / sizeof(T)
    //
    // from vector<>::max_size. This tries to get more
    // meaningful info.
    //
    template <typename T>
    inline typename T::size_type vector_max_size_workaround(const T & v)
        BOOST_NOEXCEPT
    {
        typedef typename T::allocator_type allocator_type;

        const allocator_type& alloc = v.get_allocator();

        typename boost::allocator_size_type<allocator_type>::type alloc_max =
            boost::allocator_max_size(alloc);

        const typename T::size_type container_max = v.max_size();

        return alloc_max < container_max ? alloc_max : container_max;
    }

    // for static_asserts
    template <typename T>
    struct allowed_block_type {
        enum { value = T(-1) > 0 }; // ensure T has no sign
    };

    template <>
    struct allowed_block_type<bool> {
        enum { value = false };
    };


    template <typename T>
    struct is_numeric {
        enum { value = false };
    };

#   define BOOST_dynamic_bitset_is_numeric(x)       \
                template<>                          \
                struct is_numeric< x > {            \
                    enum { value = true };          \
                }                                /**/

    BOOST_dynamic_bitset_is_numeric(bool);
    BOOST_dynamic_bitset_is_numeric(char);

#if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
    BOOST_dynamic_bitset_is_numeric(wchar_t);
#endif

    BOOST_dynamic_bitset_is_numeric(signed char);
    BOOST_dynamic_bitset_is_numeric(short int);
    BOOST_dynamic_bitset_is_numeric(int);
    BOOST_dynamic_bitset_is_numeric(long int);

    BOOST_dynamic_bitset_is_numeric(unsigned char);
    BOOST_dynamic_bitset_is_numeric(unsigned short);
    BOOST_dynamic_bitset_is_numeric(unsigned int);
    BOOST_dynamic_bitset_is_numeric(unsigned long);

#if defined(BOOST_HAS_LONG_LONG)
    BOOST_dynamic_bitset_is_numeric(::boost::long_long_type);
    BOOST_dynamic_bitset_is_numeric(::boost::ulong_long_type);
#endif

    // intentionally omitted
    //BOOST_dynamic_bitset_is_numeric(float);
    //BOOST_dynamic_bitset_is_numeric(double);
    //BOOST_dynamic_bitset_is_numeric(long double);

#undef BOOST_dynamic_bitset_is_numeric

  } // dynamic_bitset_impl
  } // namespace detail

} // namespace boost

#endif // include guard


/* dynamic_bitset.hpp
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
*/