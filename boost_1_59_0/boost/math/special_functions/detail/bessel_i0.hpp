//  Copyright (c) 2006 Xiaogang Zhang
//  Copyright (c) 2017 John Maddock
//  Use, modification and distribution are subject to the
//  Boost Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_MATH_BESSEL_I0_HPP
#define BOOST_MATH_BESSEL_I0_HPP

#ifdef _MSC_VER
#pragma once
#endif

#include <boost/math/tools/rational.hpp>
#include <boost/math/tools/big_constant.hpp>
#include <boost/math/tools/assert.hpp>

#if defined(__GNUC__) && defined(BOOST_MATH_USE_FLOAT128)
//
// This is the only way we can avoid
// warning: non-standard suffix on floating constant [-Wpedantic]
// when building with -Wall -pedantic.  Neither __extension__
// nor #pragma diagnostic ignored work :(
//
#pragma GCC system_header
#endif

// Modified Bessel function of the first kind of order zero
// we use the approximating forms derived in:
// "Rational Approximations for the Modified Bessel Function of the First Kind - I0(x) for Computations with Double Precision"
// by Pavel Holoborodko, 
// see http://www.advanpix.com/2015/11/11/rational-approximations-for-the-modified-bessel-function-of-the-first-kind-i0-computations-double-precision
// The actual coefficients used are our own, and extend Pavel's work to precision's other than double.

namespace boost { namespace math { namespace detail{

template <typename T>
T bessel_i0(const T& x);

template <class T, class tag>
struct bessel_i0_initializer
{
   struct init
   {
      init()
      {
         do_init(tag());
      }
      static void do_init(const std::integral_constant<int, 64>&)
      {
         bessel_i0(T(1));
         bessel_i0(T(8));
         bessel_i0(T(12));
         bessel_i0(T(40));
         bessel_i0(T(101));
      }
      static void do_init(const std::integral_constant<int, 113>&)
      {
         bessel_i0(T(1));
         bessel_i0(T(10));
         bessel_i0(T(20));
         bessel_i0(T(40));
         bessel_i0(T(101));
      }
      template <class U>
      static void do_init(const U&) {}
      void force_instantiate()const {}
   };
   static const init initializer;
   static void force_instantiate()
   {
      initializer.force_instantiate();
   }
};

template <class T, class tag>
const typename bessel_i0_initializer<T, tag>::init bessel_i0_initializer<T, tag>::initializer;

template <typename T, int N>
T bessel_i0_imp(const T&, const std::integral_constant<int, N>&)
{
   BOOST_MATH_ASSERT(0);
   return 0;
}

template <typename T>
T bessel_i0_imp(const T& x, const std::integral_constant<int, 24>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Max error in interpolated form: 3.929e-08
      // Max Error found at float precision = Poly: 1.991226e-07
      static const float P[] = {
         1.00000003928615375e+00f,
         2.49999576572179639e-01f,
         2.77785268558399407e-02f,
         1.73560257755821695e-03f,
         6.96166518788906424e-05f,
         1.89645733877137904e-06f,
         4.29455004657565361e-08f,
         3.90565476357034480e-10f,
         1.48095934745267240e-11f
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 50)
   {
      // Max error in interpolated form: 5.195e-08
      // Max Error found at float precision = Poly: 8.502534e-08
      static const float P[] = {
         3.98942651588301770e-01f,
         4.98327234176892844e-02f,
         2.91866904423115499e-02f,
         1.35614940793742178e-02f,
         1.31409251787866793e-01f
      };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else
   {
      // Max error in interpolated form: 1.782e-09
      // Max Error found at float precision = Poly: 6.473568e-08
      static const float P[] = {
         3.98942391532752700e-01f,
         4.98455950638200020e-02f,
         2.94835666900682535e-02f
      };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const std::integral_constant<int, 53>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Bessel I0 over[10 ^ -16, 7.75]
      // Max error in interpolated form : 3.042e-18
      // Max Error found at double precision = Poly : 5.106609e-16 Cheb : 5.239199e-16
      static const double P[] = {
         1.00000000000000000e+00,
         2.49999999999999909e-01,
         2.77777777777782257e-02,
         1.73611111111023792e-03,
         6.94444444453352521e-05,
         1.92901234513219920e-06,
         3.93675991102510739e-08,
         6.15118672704439289e-10,
         7.59407002058973446e-12,
         7.59389793369836367e-14,
         6.27767773636292611e-16,
         4.34709704153272287e-18,
         2.63417742690109154e-20,
         1.13943037744822825e-22,
         9.07926920085624812e-25
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 500)
   {
      // Max error in interpolated form : 1.685e-16
      // Max Error found at double precision = Poly : 2.575063e-16 Cheb : 2.247615e+00
      static const double P[] = {
         3.98942280401425088e-01,
         4.98677850604961985e-02,
         2.80506233928312623e-02,
         2.92211225166047873e-02,
         4.44207299493659561e-02,
         1.30970574605856719e-01,
         -3.35052280231727022e+00,
         2.33025711583514727e+02,
         -1.13366350697172355e+04,
         4.24057674317867331e+05,
         -1.23157028595698731e+07,
         2.80231938155267516e+08,
         -5.01883999713777929e+09,
         7.08029243015109113e+10,
         -7.84261082124811106e+11,
         6.76825737854096565e+12,
         -4.49034849696138065e+13,
         2.24155239966958995e+14,
         -8.13426467865659318e+14,
         2.02391097391687777e+15,
         -3.08675715295370878e+15,
         2.17587543863819074e+15
      };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else
   {
      // Max error in interpolated form : 2.437e-18
      // Max Error found at double precision = Poly : 1.216719e-16
      static const double P[] = {
         3.98942280401432905e-01,
         4.98677850491434560e-02,
         2.80506308916506102e-02,
         2.92179096853915176e-02,
         4.53371208762579442e-02
      };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const std::integral_constant<int, 64>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Bessel I0 over[10 ^ -16, 7.75]
      // Max error in interpolated form : 3.899e-20
      // Max Error found at float80 precision = Poly : 1.770840e-19
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.99999999999999999961011629e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.50000000000000001321873912e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.77777777777777703400424216e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.73611111111112764793802701e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.94444444444251461247253525e-05),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.92901234569262206386118739e-06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.93675988851131457141005209e-08),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.15118734688297476454205352e-10),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.59405797058091016449222685e-12),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.59406599631719800679835140e-14),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.27598961062070013516660425e-16),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.35920318970387940278362992e-18),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.57372492687715452949437981e-20),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.33908663475949906992942204e-22),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.15976668870980234582896010e-25),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.46240478946376069211156548e-27)
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 10)
   {
      // Maximum Deviation Found:                     6.906e-21
      // Expected Error Term : -6.903e-21
      // Maximum Relative Change in Control Points : 1.631e-04
      // Max Error found at float80 precision = Poly : 7.811948e-21
      static const T Y = 4.051098823547363281250e-01f;
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, -6.158081780620616479492e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.883635969834048766148e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.892782002476195771920e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.478784996478070170327e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.988611837308006851257e+01),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.140133766747436806179e+02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.117316447921276453271e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.942353667455141676001e+04),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.493482682461387081534e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, -5.228100538921466124653e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.195279248600467989454e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.601530760654337045917e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.504921137873298402679e+05)
      };
      return exp(x) * (boost::math::tools::evaluate_polynomial(P, T(1 / x)) + Y) / sqrt(x);
   }
   else if(x < 15)
   {
      // Maximum Deviation Found:                     4.083e-21
      // Expected Error Term : -4.025e-21
      // Maximum Relative Change in Control Points : 1.304e-03
      // Max Error found at float80 precision = Poly : 2.303527e-20
      static const T Y = 4.033188819885253906250e-01f;
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.376373876116109401062e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.982899138682911273321e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.109477529533515397644e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.163760580110576407673e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.776501832837367371883e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.101478069227776656318e+02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.892071912448960299773e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.417739279982328117483e+04),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.296963447724067390552e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, -1.598589306710589358747e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.903662411851774878322e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.622677059040339516093e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.227776578828667629347e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.727797957441040896878e+07)
      };
      return exp(x) * (boost::math::tools::evaluate_polynomial(P, T(1 / x)) + Y) / sqrt(x);
   }
   else if(x < 50)
   {
      // Max error in interpolated form: 1.035e-21
      // Max Error found at float80 precision = Poly: 1.885872e-21
      static const T Y = 4.011702537536621093750e-01f;
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.227973351806078464328e-03),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.986778486088017419036e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.805066823812285310011e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.921443721160964964623e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.517504941996594744052e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.316922639868793684401e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.535891099168810015433e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.706078229522448308087e+01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.351015763079160914632e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.948809013999277355098e+04),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.967598958582595361757e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, -6.346924657995383019558e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.998794574259956613472e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.016371355801690142095e+08),
         BOOST_MATH_BIG_CONSTANT(T, 64, 1.768791455631826490838e+09),
         BOOST_MATH_BIG_CONSTANT(T, 64, -4.441995678177349895640e+09),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.482292669974971387738e+09)
      };
      return exp(x) * (boost::math::tools::evaluate_polynomial(P, T(1 / x)) + Y) / sqrt(x);
   }
   else
   {
      // Bessel I0 over[50, INF]
      // Max error in interpolated form : 5.587e-20
      // Max Error found at float80 precision = Poly : 8.776852e-20
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.98942280401432677955074061e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.98677850501789875615574058e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.80506290908675604202206833e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.92194052159035901631494784e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 4.47422430732256364094681137e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.05971614435738691235525172e-02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 2.29180522595459823234266708e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 6.15122547776140254569073131e-01),
         BOOST_MATH_BIG_CONSTANT(T, 64, 7.48491812136365376477357324e+00),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.45569740166506688169730713e+02),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.66857566379480730407063170e+03),
         BOOST_MATH_BIG_CONSTANT(T, 64, -2.71924083955641197750323901e+05),
         BOOST_MATH_BIG_CONSTANT(T, 64, 5.74276685704579268845870586e+06),
         BOOST_MATH_BIG_CONSTANT(T, 64, -8.89753803265734681907148778e+07),
         BOOST_MATH_BIG_CONSTANT(T, 64, 9.82590905134996782086242180e+08),
         BOOST_MATH_BIG_CONSTANT(T, 64, -7.30623197145529889358596301e+09),
         BOOST_MATH_BIG_CONSTANT(T, 64, 3.27310000726207055200805893e+10),
         BOOST_MATH_BIG_CONSTANT(T, 64, -6.64365417189215599168817064e+10)
      };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const std::integral_constant<int, 113>&)
{
   BOOST_MATH_STD_USING
   if(x < 7.75)
   {
      // Bessel I0 over[10 ^ -34, 7.75]
      // Max error in interpolated form : 1.274e-34
      // Max Error found at float128 precision = Poly : 3.096091e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.0000000000000000000000000000000001273856e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4999999999999999999999999999999107477496e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7777777777777777777777777777881795230918e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.7361111111111111111111111106290091648808e-03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.9444444444444444444444445629960334523101e-05),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.9290123456790123456790105563456483249753e-06),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9367598891408415217940836339080514004844e-08),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.1511873267825648777900014857992724731476e-10),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281266233066162999610732449709209e-12),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281266232783124723601470051895304e-14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.2760813455591936763439337059117957836078e-16),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.3583898233049738471136482147779094353096e-18),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5789288895299965395422423848480340736308e-20),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.3157800456718804437960453545507623434606e-22),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.8479113149412360748032684260932041506493e-25),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2843403488398038539283241944594140493394e-27),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.9042925594356556196790242908697582021825e-30),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4395919891312152120710245152115597111101e-32),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.7580986145276689333214547502373003196707e-35),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.6886514018062348877723837017198859723889e-37),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.8540558465757554512570197585002702777999e-40),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.4684706070226893763741850944911705726436e-43),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.0210715309399646335858150349406935414314e-45)
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 15)
   {
      // Bessel I0 over[7.75, 15]
      // Max error in interpolated form : 7.534e-35
      // Max Error found at float128 precision = Poly : 6.123912e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.9999999999999999992388573069504617493518e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5000000000000000007304739268173096975340e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7777777777777777744261405400543564492074e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.7361111111111111209006987259719750726867e-03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.9444444444444442399703186871329381908321e-05),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.9290123456790126709286741580242189785431e-06),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9367598891408374246503061422528266924389e-08),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.1511873267826068395343047827801353170966e-10),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281262673459688011737168286944521e-12),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5940584281291583769928563167645746144508e-14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.2760813455438840231126529638737436950274e-16),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.3583898233839583885132809584770578894948e-18),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5789288891798658971960571838369339742994e-20),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.3157800470129311623308216856009970266088e-22),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.8479112701534604520063520412207286692581e-25),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2843404822552330714586265081801727491890e-27),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.9042888166225242675881424439818162458179e-30),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4396027771820721384198604723320045236973e-32),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.7577659910606076328136207973456511895030e-35),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.6896548123724136624716224328803899914646e-37),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.8285850162160539150210466453921758781984e-40),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.9419071894227736216423562425429524883562e-43),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.4720374049498608905571855665134539425038e-45),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7763533278527958112907118930154738930378e-48),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.1213839473168678646697528580511702663617e-51),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.0648035313124146852372607519737686740964e-53),
         -BOOST_MATH_BIG_CONSTANT(T, 113, 5.1255595184052024349371058585102280860878e-57),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.4652470895944157957727948355523715335882e-59)
      };
      T a = x * x / 4;
      return a * boost::math::tools::evaluate_polynomial(P, a) + 1;
   }
   else if(x < 30)
   {
      // Max error in interpolated form : 1.808e-34
      // Max Error found at float128 precision = Poly : 2.399403e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9894228040870793650581242239624530714032e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.9867780576714783790784348982178607842250e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8051948347934462928487999569249907599510e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8971143420388958551176254291160976367263e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.8197359701715582763961322341827341098897e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.3430484862908317377522273217643346601271e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.7884507603213662610604413960838990199224e+02),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.8304926482356755790062999202373909300514e+04),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.8867173178574875515293357145875120137676e+05),
         BOOST_MATH_BIG_CONSTANT(T, 113, -4.4261178812193528551544261731796888257644e+07),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.6453010340778116475788083817762403540097e+09),
         BOOST_MATH_BIG_CONSTANT(T, 113, -5.0432401330113978669454035365747869477960e+10),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.2462165331309799059332310595587606836357e+12),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.3299800389951335932792950236410844978273e+13),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.5748218240248714177527965706790413406639e+14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.8330014378766930869945511450377736037385e+15),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.8494610073827453236940544799030787866218e+17),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.7244661371420647691301043350229977856476e+18),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.2386378807889388140099109087465781254321e+20),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.1104000573102013529518477353943384110982e+21),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.9426541092239879262282594572224300191016e+22),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.4061439136301913488512592402635688101020e+23),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.2836554760521986358980180942859101564671e+24),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.6270285589905206294944214795661236766988e+25),
         BOOST_MATH_BIG_CONSTANT(T, 113, -1.7278631455211972017740134341610659484259e+26),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.1971734473772196124736986948034978906801e+26),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.8669270707172568763908838463689093500098e+27),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.2368879358870281916900125550129211146626e+28),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.8296235063297831758204519071113999839858e+28),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.1253861666023020670144616019148954773662e+28),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.8809536950051955163648980306847791014734e+28) };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else if(x < 100)
   {
      // Bessel I0 over[30, 100]
      // Max error in interpolated form : 1.487e-34
      // Max Error found at float128 precision = Poly : 1.929924e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9894228040143267793996798658172135362278e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.9867785050179084714910130342157246539820e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8050629090725751585266360464766768437048e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.9219405302833158254515212437025679637597e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.4742214371598631578107310396249912330627e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.0602983776478659136184969363625092585520e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2839507231977478205885469900971893734770e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.8925739165733823730525449511456529001868e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4238082222874015159424842335385854632223e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.6759648427182491050716309699208988458050e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.7292246491169360014875196108746167872215e+01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.1001411442786230340015781205680362993575e+01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.8277628835804873490331739499978938078848e+03),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.1208326312801432038715638596517882759639e+05),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.4813611580683862051838126076298945680803e+06),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.1278197693321821164135890132925119054391e+08),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.3190303792682886967459489059860595063574e+09),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.1580767338646580750893606158043485767644e+10),
         BOOST_MATH_BIG_CONSTANT(T, 113, -5.0256008808415702780816006134784995506549e+11),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.9044186472918017896554580836514681614475e+13),
         BOOST_MATH_BIG_CONSTANT(T, 113, -3.2521078890073151875661384381880225635135e+14),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.3620352486836976842181057590770636605454e+15),
         BOOST_MATH_BIG_CONSTANT(T, 113, -2.0375525734060401555856465179734887312420e+16),
         BOOST_MATH_BIG_CONSTANT(T, 113, 5.6392664899881014534361728644608549445131e+16)
      };
      return exp(x) * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
   }
   else
   {
      // Bessel I0 over[100, INF]
      // Max error in interpolated form : 5.459e-35
      // Max Error found at float128 precision = Poly : 1.472240e-34
      static const T P[] = {
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.9894228040143267793994605993438166526772e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.9867785050179084742493257495245185241487e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.8050629090725735167652437695397756897920e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.9219405302839307466358297347675795965363e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.4742214369972689474366968442268908028204e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.0602984099194778006610058410222616383078e-02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.2839502241666629677015839125593079416327e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.8926354981801627920292655818232972385750e-01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.4231921590621824187100989532173995000655e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 9.7264260959693775207585700654645245723497e+00),
         BOOST_MATH_BIG_CONSTANT(T, 113, 4.3890136225398811195878046856373030127018e+01),
         BOOST_MATH_BIG_CONSTANT(T, 113, 2.1999720924619285464910452647408431234369e+02),
         BOOST_MATH_BIG_CONSTANT(T, 113, 1.2076909538525038580501368530598517194748e+03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 7.5684635141332367730007149159063086133399e+03),
         BOOST_MATH_BIG_CONSTANT(T, 113, 3.5178192543258299267923025833141286569141e+04),
         BOOST_MATH_BIG_CONSTANT(T, 113, 6.2966297919851965784482163987240461837728e+05) };
      T ex = exp(x / 2);
      T result = ex * boost::math::tools::evaluate_polynomial(P, T(1 / x)) / sqrt(x);
      result *= ex;
      return result;
   }
}

template <typename T>
T bessel_i0_imp(const T& x, const std::integral_constant<int, 0>&)
{
   if(boost::math::tools::digits<T>() <= 24)
      return bessel_i0_imp(x, std::integral_constant<int, 24>());
   else if(boost::math::tools::digits<T>() <= 53)
      return bessel_i0_imp(x, std::integral_constant<int, 53>());
   else if(boost::math::tools::digits<T>() <= 64)
      return bessel_i0_imp(x, std::integral_constant<int, 64>());
   else if(boost::math::tools::digits<T>() <= 113)
      return bessel_i0_imp(x, std::integral_constant<int, 113>());
   BOOST_MATH_ASSERT(0);
   return 0;
}

template <typename T>
inline T bessel_i0(const T& x)
{
   typedef std::integral_constant<int,
      ((std::numeric_limits<T>::digits == 0) || (std::numeric_limits<T>::radix != 2)) ?
      0 :
      std::numeric_limits<T>::digits <= 24 ?
      24 :
      std::numeric_limits<T>::digits <= 53 ?
      53 :
      std::numeric_limits<T>::digits <= 64 ?
      64 :
      std::numeric_limits<T>::digits <= 113 ?
      113 : -1
   > tag_type;

   bessel_i0_initializer<T, tag_type>::force_instantiate();
   return bessel_i0_imp(x, tag_type());
}

}}} // namespaces

#endif // BOOST_MATH_BESSEL_I0_HPP


/* bessel_i0.hpp
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
*/