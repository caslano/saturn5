///////////////////////////////////////////////////////////////////////////////
/// \file make.hpp
/// Contains definition of the make<> transform.
//
//  Copyright 2008 Eric Niebler. Distributed under the Boost
//  Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_PROTO_TRANSFORM_MAKE_HPP_EAN_12_02_2007
#define BOOST_PROTO_TRANSFORM_MAKE_HPP_EAN_12_02_2007

#include <boost/detail/workaround.hpp>
#include <boost/preprocessor/repetition/enum.hpp>
#include <boost/preprocessor/repetition/enum_params.hpp>
#include <boost/preprocessor/repetition/enum_trailing_params.hpp>
#include <boost/preprocessor/repetition/enum_binary_params.hpp>
#include <boost/preprocessor/repetition/enum_params_with_a_default.hpp>
#include <boost/preprocessor/repetition/repeat_from_to.hpp>
#include <boost/preprocessor/facilities/intercept.hpp>
#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/iteration/iterate.hpp>
#include <boost/preprocessor/selection/max.hpp>
#include <boost/preprocessor/arithmetic/inc.hpp>
#include <boost/mpl/and.hpp>
#include <boost/mpl/aux_/has_type.hpp>
#include <boost/proto/detail/template_arity.hpp>
#include <boost/utility/result_of.hpp>
#include <boost/proto/proto_fwd.hpp>
#include <boost/proto/traits.hpp>
#include <boost/proto/args.hpp>
#include <boost/proto/transform/impl.hpp>
#include <boost/proto/transform/detail/pack.hpp>
#include <boost/proto/detail/as_lvalue.hpp>
#include <boost/proto/detail/ignore_unused.hpp>

#if defined(_MSC_VER)
# pragma warning(push)
# pragma warning(disable : 4714) // function 'xxx' marked as __forceinline not inlined
#endif

namespace boost { namespace proto
{
    namespace detail
    {
        template<typename T>
        struct is_applyable
          : mpl::and_<is_callable<T>, is_transform<T> >
        {};

        template<typename T, bool HasType = mpl::aux::has_type<T>::value>
        struct nested_type
        {
            typedef typename T::type type;
        };

        template<typename T>
        struct nested_type<T, false>
        {
            typedef T type;
        };

        template<typename T, bool Applied>
        struct nested_type_if
        {
            typedef T type;
            static bool const applied = false;
        };

        template<typename T>
        struct nested_type_if<T, true>
          : nested_type<T>
        {
            static bool const applied = true;
        };

        template<
            typename R
          , typename Expr, typename State, typename Data
            BOOST_PROTO_TEMPLATE_ARITY_PARAM(long Arity = detail::template_arity<R>::value)
        >
        struct make_
        {
            typedef R type;
            static bool const applied = false;
        };

        template<
            typename R
          , typename Expr, typename State, typename Data
          , bool IsApplyable = is_applyable<R>::value
        >
        struct make_if_
          : make_<R, Expr, State, Data>
        {};

        template<typename R, typename Expr, typename State, typename Data>
        struct make_if_<R, Expr, State, Data, true>
          : uncvref<typename when<_, R>::template impl<Expr, State, Data>::result_type>
        {
            static bool const applied = true;
        };

        #if BOOST_WORKAROUND(__GNUC__, == 3) || (BOOST_WORKAROUND(__GNUC__, == 4) && __GNUC_MINOR__ == 0)
        // work around GCC bug
        template<typename Tag, typename Args, long N, typename Expr, typename State, typename Data>
        struct make_if_<proto::expr<Tag, Args, N>, Expr, State, Data, false>
        {
            typedef proto::expr<Tag, Args, N> type;
            static bool const applied = false;
        };

        // work around GCC bug
        template<typename Tag, typename Args, long N, typename Expr, typename State, typename Data>
        struct make_if_<proto::basic_expr<Tag, Args, N>, Expr, State, Data, false>
        {
            typedef proto::basic_expr<Tag, Args, N> type;
            static bool const applied = false;
        };
        #endif

        template<typename Type, bool IsAggregate = detail::is_aggregate_<Type>::value>
        struct construct_
        {
            typedef Type result_type;

            BOOST_FORCEINLINE
            Type operator ()() const
            {
                return Type();
            }

            // Other overloads generated by the preprocessor
            #include <boost/proto/transform/detail/construct_funop.hpp>
        };

        template<typename Type>
        struct construct_<Type, true>
        {
            typedef Type result_type;

            BOOST_FORCEINLINE
            Type operator ()() const
            {
                return Type();
            }

            // Other overloads generated by the preprocessor
            #include <boost/proto/transform/detail/construct_pod_funop.hpp>
        };

    }

    /// \brief A PrimitiveTransform which prevents another PrimitiveTransform
    /// from being applied in an \c ObjectTransform.
    ///
    /// When building higher order transforms with <tt>make\<\></tt> or
    /// <tt>lazy\<\></tt>, you sometimes would like to build types that
    /// are parameterized with Proto transforms. In such lambda-style
    /// transforms, Proto will unhelpfully find all nested transforms
    /// and apply them, even if you don't want them to be applied. Consider
    /// the following transform, which will replace the \c _ in
    /// <tt>Bar<_>()</tt> with <tt>proto::terminal\<int\>::type</tt>:
    ///
    /// \code
    /// template<typename T>
    /// struct Bar
    /// {};
    /// 
    /// struct Foo
    ///   : proto::when<_, Bar<_>() >
    /// {};
    /// 
    /// proto::terminal<int>::type i = {0};
    /// 
    /// int main()
    /// {
    ///     Foo()(i);
    ///     std::cout << typeid(Foo()(i)).name() << std::endl;
    /// }
    /// \endcode
    ///
    /// If you actually wanted to default-construct an object of type
    /// <tt>Bar\<_\></tt>, you would have to protect the \c _ to prevent
    /// it from being applied. You can use <tt>proto::protect\<\></tt>
    /// as follows:
    ///
    /// \code
    /// // OK: replace anything with Bar<_>()
    /// struct Foo
    ///   : proto::when<_, Bar<protect<_> >() >
    /// {};
    /// \endcode
    template<typename PrimitiveTransform>
    struct protect : transform<protect<PrimitiveTransform> >
    {
        template<typename, typename, typename>
        struct impl
        {
            typedef PrimitiveTransform result_type;
        };
    };

    /// \brief A PrimitiveTransform which computes a type by evaluating any
    /// nested transforms and then constructs an object of that type.
    ///
    /// The <tt>make\<\></tt> transform checks to see if \c Object is a template.
    /// If it is, the template type is disassembled to find nested transforms.
    /// Proto considers the following types to represent transforms:
    ///
    /// \li Function types
    /// \li Function pointer types
    /// \li Types for which <tt>proto::is_callable\< type \>::value</tt> is \c true
    ///
    /// <tt>boost::result_of\<make\<T\<X0,X1,...\> \>(Expr, State, Data)\>::type</tt>
    /// is evaluated as follows. For each \c X in <tt>X0,X1,...</tt>, do:
    ///
    /// \li If \c X is a template like <tt>U\<Y0,Y1,...\></tt>, then let <tt>X'</tt>
    ///     be <tt>boost::result_of\<make\<U\<Y0,Y1,...\> \>(Expr, State, Data)\>::type</tt>
    ///     (which evaluates this procedure recursively). Note whether any
    ///     substitutions took place during this operation.
    /// \li Otherwise, if \c X is a transform, then let <tt>X'</tt> be
    ///     <tt>boost::result_of\<when\<_, X\>(Expr, State, Data)\>::type</tt>.
    ///     Note that a substitution took place.
    /// \li Otherwise, let <tt>X'</tt> be \c X, and note that no substitution
    ///     took place.
    /// \li If any substitutions took place in any of the above steps and
    ///     <tt>T\<X0',X1',...\></tt> has a nested <tt>::type</tt> typedef,
    ///     the result type is <tt>T\<X0',X1',...\>::type</tt>.
    /// \li Otherwise, the result type is <tt>T\<X0',X1',...\></tt>.
    ///
    /// Note that <tt>when\<\></tt> is implemented in terms of <tt>call\<\></tt>
    /// and <tt>make\<\></tt>, so the above procedure is evaluated recursively.
    template<typename Object>
    struct make : transform<make<Object> >
    {
        template<typename Expr, typename State, typename Data>
        struct impl : transform_impl<Expr, State, Data>
        {
            typedef typename detail::make_if_<Object, Expr, State, Data>::type result_type;

            /// \return <tt>result_type()</tt>
            BOOST_FORCEINLINE
            result_type operator ()(
                typename impl::expr_param
              , typename impl::state_param
              , typename impl::data_param
            ) const
            {
                return result_type();
            }
        };
    };

    /// INTERNAL ONLY
    template<typename Fun>
    struct make<detail::msvc_fun_workaround<Fun> >
      : make<Fun>
    {};

    // Other specializations generated by the preprocessor.
    #include <boost/proto/transform/detail/make.hpp>
    #include <boost/proto/transform/detail/make_gcc_workaround.hpp>

    /// INTERNAL ONLY
    ///
    template<typename Object>
    struct is_callable<make<Object> >
      : mpl::true_
    {};

    /// INTERNAL ONLY
    ///
    template<typename PrimitiveTransform>
    struct is_callable<protect<PrimitiveTransform> >
      : mpl::true_
    {};

}}

#if defined(_MSC_VER)
# pragma warning(pop)
#endif

#endif

/* make.hpp
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
*/