// Boost.Geometry

// Copyright (c) 2018 Adeel Ahmad, Islamabad, Pakistan.

// Contributed and/or modified by Adeel Ahmad, as part of Google Summer of Code 2018 program.

// This file was modified by Oracle on 2019.
// Modifications copyright (c) 2019 Oracle and/or its affiliates.

// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle

// Use, modification and distribution is subject to the Boost Software License,
// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// This file is converted from GeographicLib, https://geographiclib.sourceforge.io
// GeographicLib is originally written by Charles Karney.

// Author: Charles Karney (2008-2017)

// Last updated version of GeographicLib: 1.49

// Original copyright notice:

// Copyright (c) Charles Karney (2008-2017) <charles@karney.com> and licensed
// under the MIT/X11 License. For more information, see
// https://geographiclib.sourceforge.io

#ifndef BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
#define BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

#include <boost/geometry/core/assert.hpp>
#include <boost/geometry/util/math.hpp>

namespace boost { namespace geometry { namespace series_expansion {

    /*
     Generate and evaluate the series expansion of the following integral

     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )

     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2
     and expand (1 - eps) * I1 retaining terms up to order eps^maxpow
     in A1 and C1[l].

     The resulting series is of the form

     A1 * ( sigma + sum(C1[l] * sin(2*l*sigma), l, 1, maxpow) ).

     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_A1 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;'
    */
    template <size_t SeriesOrder, typename CT>
    inline CT evaluate_A1(CT eps)
    {
        CT eps2 = math::sqr(eps);
        CT t;
        switch (SeriesOrder/2)
        {
        case 0:
            t = CT(0);
            break;
        case 1:
            t = eps2/CT(4);
            break;
        case 2:
            t = eps2*(eps2+CT(16))/CT(64);
            break;
        case 3:
            t = eps2*(eps2*(eps2+CT(4))+CT(64))/CT(256);
            break;
        case 4:
            t = eps2*(eps2*(eps2*(CT(25)*eps2+CT(64))+CT(256))+CT(4096))/CT(16384);
            break;
        }
        return (t + eps) / (CT(1) - eps);
    }

    /*
     Generate and evaluate the series expansion of the following integral

     I2 = integrate( 1/sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )

     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2
     and expand (1 - eps) * I2 retaining terms up to order eps^maxpow
     in A2 and C2[l].

     The resulting series is of the form

     A2 * ( sigma + sum(C2[l] * sin(2*l*sigma), l, 1, maxpow) )

     The scale factor A2-1 = mean value of (d/dsigma)2 - 1

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_A2 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <size_t SeriesOrder, typename CT>
    inline CT evaluate_A2(CT const& eps)
    {
        CT const eps2 = math::sqr(eps);
        CT t;
        switch (SeriesOrder/2)
        {
        case 0:
            t = CT(0);
            break;
        case 1:
            t = -CT(3)*eps2/CT(4);
            break;
        case 2:
            t = (-CT(7)*eps2-CT(48))*eps2/CT(64);
            break;
        case 3:
            t = eps2*((-CT(11)*eps2-CT(28))*eps2-CT(192))/CT(256);
            break;
        default:
            t = eps2*(eps2*((-CT(375)*eps2-CT(704))*eps2-CT(1792))-CT(12288))/CT(16384);
            break;
        }
        return (t - eps) / (CT(1) + eps);
    }

    /*
     Express

        I3 = integrate( (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma1)^2)), sigma1, 0, sigma )

     as a series

        A3 * ( sigma + sum(C3[l] * sin(2*l*sigma), l, 1, maxpow-1) )

     valid for f and k2 small.  It is convenient to write k2 = 4 * eps / (1 -
     eps)^2 and f = 2*n/(1+n) and expand in eps and n.  This procedure leads
     to a series where the coefficients of eps^j are terminating series in n.

     The scale factor A3 = mean value of (d/dsigma)I3

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_A3 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_A3(Coeffs &c, CT const& n)
    {
        switch (int(Coeffs::static_size))
        {
        case 0:
            break;
        case 1:
            c[0] = CT(1);
            break;
        case 2:
            c[0] = CT(1);
            c[1] = -CT(1)/CT(2);
            break;
        case 3:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = -CT(1)/CT(4);
            break;
        case 4:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (-n-CT(2))/CT(8);
            c[3] = -CT(1)/CT(16);
            break;
        case 5:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (-CT(3)*n-CT(1))/CT(16);
            c[4] = -CT(3)/CT(64);
            break;
        case 6:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = ((-n-CT(3))*n-CT(1))/CT(16);
            c[4] = (-CT(2)*n-CT(3))/CT(64);
            c[5] = -CT(3)/CT(128);
            break;
        case 7:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);
            c[4] = ((-CT(10)*n-CT(2))*n-CT(3))/CT(64);
            c[5] = (-CT(5)*n-CT(3))/CT(128);
            c[6] = -CT(5)/CT(256);
            break;
        default:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);
            c[4] = (n*((-CT(5)*n-CT(20))*n-CT(4))-CT(6))/CT(128);
            c[5] = ((-CT(5)*n-CT(10))*n-CT(6))/CT(256);
            c[6] = (-CT(15)*n-CT(20))/CT(1024);
            c[7] = -CT(25)/CT(2048);
            break;
        }
    }

    /*
     The coefficients C1[l] in the Fourier expansion of B1.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C1 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_C1(Coeffs &c, CT const& eps)
    {
        CT eps2 = math::sqr(eps);
        CT d = eps;
        switch (int(Coeffs::static_size) - 1)
        {
        case 0:
            break;
        case 1:
            c[1] = -d/CT(2);
            break;
        case 2:
            c[1] = -d/CT(2);
            d *= eps;
            c[2] = -d/CT(16);
            break;
        case 3:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = -d/CT(16);
            d *= eps;
            c[3] = -d/CT(48);
            break;
        case 4:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = -d/CT(48);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            break;
        case 5:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            break;
        case 6:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            break;
        case 7:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            break;
        default:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*((CT(96)-CT(11)*eps2)*eps2-CT(160))/CT(16384);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = d*(CT(9)*eps2-CT(14))/CT(4096);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            d *= eps;
            c[8] = -CT(429)*d/CT(262144);
            break;
        }
    }

    /*
     The coefficients C1p[l] in the Fourier expansion of B1p.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C1p below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_C1p(Coeffs& c, CT const& eps)
    {
        CT const eps2 = math::sqr(eps);
        CT d = eps;
        switch (int(Coeffs::static_size) - 1)
        {
        case 0:
            break;
        case 1:
            c[1] = d/CT(2);
            break;
        case 2:
            c[1] = d/CT(2);
            d *= eps;
            c[2] = CT(5)*d/CT(16);
            break;
        case 3:
            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);
            d *= eps;
            c[2] = CT(5)*d/CT(16);
            d *= eps;
            c[3] = CT(29)*d/CT(96);
            break;
        case 4:
            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);
            d *= eps;
            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);
            d *= eps;
            c[3] = CT(29)*d/CT(96);
            d *= eps;
            c[4] = CT(539)*d/CT(1536);
            break;
        case 5:
            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);
            d *= eps;
            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);
            d *= eps;
            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);
            d *= eps;
            c[4] = CT(539)*d/CT(1536);
            d *= eps;
            c[5] = CT(3467)*d/CT(7680);
            break;
        case 6:
            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);
            d *= eps;
            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);
            d *= eps;
            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);
            d *= eps;
            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);
            d *= eps;
            c[5] = CT(3467)*d/CT(7680);
            d *= eps;
            c[6] = CT(38081)*d/CT(61440);
            break;
        case 7:
            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);
            d *= eps;
            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);
            d *= eps;
            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);
            d *= eps;
            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);
            d *= eps;
            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);
            d *= eps;
            c[6] = CT(38081)*d/CT(61440);
            d *= eps;
            c[7] = CT(459485)*d/CT(516096);
            break;
        default:
            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);
            d *= eps;
            c[2] = d*(eps2*((CT(120150)-CT(86171)*eps2)*eps2-CT(142080))+CT(115200))/CT(368640);
            d *= eps;
            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);
            d *= eps;
            c[4] = d*(eps2*(CT(1082857)*eps2-CT(688608))+CT(258720))/CT(737280);
            d *= eps;
            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);
            d *= eps;
            c[6] = d*(CT(533134)-CT(2200311)*eps2)/CT(860160);
            d *= eps;
            c[7] = CT(459485)*d/CT(516096);
            d *= eps;
            c[8] = CT(109167851)*d/CT(82575360);
            break;
        }
    }

    /*
     The coefficients C2[l] in the Fourier expansion of B2.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C2 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <typename Coeffs, typename CT>
    inline void evaluate_coeffs_C2(Coeffs& c, CT const& eps)
    {
        CT const eps2 = math::sqr(eps);
        CT d = eps;
        switch (int(Coeffs::static_size) - 1)
        {
        case 0:
            break;
        case 1:
            c[1] = d/CT(2);
            break;
        case 2:
            c[1] = d/CT(2);
            d *= eps;
            c[2] = CT(3)*d/CT(16);
            break;
        case 3:
            c[1] = d*(eps2+CT(8))/CT(16);
            d *= eps;
            c[2] = CT(3)*d/CT(16);
            d *= eps;
            c[3] = CT(5)*d/CT(48);
            break;
        case 4:
            c[1] = d*(eps2+CT(8))/CT(16);
            d *= eps;
            c[2] = d*(eps2+CT(6))/CT(32);
            d *= eps;
            c[3] = CT(5)*d/CT(48);
            d *= eps;
            c[4] = CT(35)*d/CT(512);
            break;
        case 5:
            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2+CT(6))/CT(32);
            d *= eps;
            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);
            d *= eps;
            c[4] = CT(35)*d/CT(512);
            d *= eps;
            c[5] = CT(63)*d/CT(1280);
            break;
        case 6:
            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);
            d *= eps;
            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);
            d *= eps;
            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);
            d *= eps;
            c[5] = CT(63)*d/CT(1280);
            d *= eps;
            c[6] = CT(77)*d/CT(2048);
            break;
        case 7:
            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);
            d *= eps;
            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);
            d *= eps;
            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);
            d *= eps;
            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);
            d *= eps;
            c[6] = CT(77)*d/CT(2048);
            d *= eps;
            c[7] = CT(429)*d/CT(14336);
            break;
        default:
            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(eps2*(CT(47)*eps2+CT(70))+CT(128))+CT(768))/CT(4096);
            d *= eps;
            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);
            d *= eps;
            c[4] = d*(eps2*(CT(133)*eps2+CT(224))+CT(1120))/CT(16384);
            d *= eps;
            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);
            d *= eps;
            c[6] = d*(CT(33)*eps2+CT(154))/CT(4096);
            d *= eps;
            c[7] = CT(429)*d/CT(14336);
            d *= eps;
            c[8] = CT(6435)*d/CT(262144);
            break;
        }
    }

    /*
     The coefficients C3[l] in the Fourier expansion of B3.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C3 below) is
     generated by the following Maxima script:
     geometry/doc/other/maxima/geod.mac
    */
    template <size_t SeriesOrder, typename Coeffs, typename CT>
    inline void evaluate_coeffs_C3x(Coeffs &c, CT const& n) {
        BOOST_GEOMETRY_ASSERT((Coeffs::static_size == (SeriesOrder * (SeriesOrder - 1)) / 2));

        CT const n2 = math::sqr(n);
        switch (SeriesOrder)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            c[0] = (CT(1)-n)/CT(4);
            break;
        case 3:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = ((n-CT(3))*n+CT(2))/CT(32);
            break;
        case 4:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = ((n-CT(3))*n+CT(2))/CT(32);
            c[4] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[5] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            break;
        case 5:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = ((n-CT(3))*n+CT(2))/CT(32);
            c[5] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[6] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[7] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[8] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[9] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            break;
        case 6:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);
            c[5] = ((n-CT(3))*n+CT(2))/CT(32);
            c[6] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[7] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[8] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);
            c[9] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[10] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[11] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);
            c[12] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            c[13] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);
            c[14] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);
            break;
        case 7:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);
            c[5] = (CT(10)*n+CT(21))/CT(1024);
            c[6] = ((n-CT(3))*n+CT(2))/CT(32);
            c[7] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[8] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[9] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);
            c[10] = (CT(69)*n+CT(108))/CT(8192);
            c[11] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[12] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[13] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);
            c[14] = (CT(12)-n)/CT(1024);
            c[15] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            c[16] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);
            c[17] = (CT(72)-CT(43)*n)/CT(8192);
            c[18] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);
            c[19] = (CT(9)-CT(15)*n)/CT(1024);
            c[20] = (CT(44)-CT(99)*n)/CT(8192);
            break;
        default:
            c[0] = (CT(1)-n)/CT(4);
            c[1] = (CT(1)-n2)/CT(8);
            c[2] = (n*((-CT(5)*n-CT(1))*n+CT(3))+CT(3))/CT(64);
            c[3] = (n*((CT(2)-CT(2)*n)*n+CT(2))+CT(5))/CT(128);
            c[4] = (n*(CT(3)*n+CT(11))+CT(12))/CT(512);
            c[5] = (CT(10)*n+CT(21))/CT(1024);
            c[6] = CT(243)/CT(16384);
            c[7] = ((n-CT(3))*n+CT(2))/CT(32);
            c[8] = (n*(n*(CT(2)*n-CT(3))-CT(2))+CT(3))/CT(64);
            c[9] = (n*((-CT(6)*n-CT(9))*n+CT(2))+CT(6))/CT(256);
            c[10] = ((CT(1)-CT(2)*n)*n+CT(5))/CT(256);
            c[11] = (CT(69)*n+CT(108))/CT(8192);
            c[12] = CT(187)/CT(16384);
            c[13] = (n*((CT(5)-n)*n-CT(9))+CT(5))/CT(192);
            c[14] = (n*(n*(CT(10)*n-CT(6))-CT(10))+CT(9))/CT(384);
            c[15] = ((-CT(77)*n-CT(8))*n+CT(42))/CT(3072);
            c[16] = (CT(12)-n)/CT(1024);
            c[17] = CT(139)/CT(16384);
            c[18] = (n*((CT(20)-CT(7)*n)*n-CT(28))+CT(14))/CT(1024);
            c[19] = ((-CT(7)*n-CT(40))*n+CT(28))/CT(2048);
            c[20] = (CT(72)-CT(43)*n)/CT(8192);
            c[21] = CT(127)/CT(16384);
            c[22] = (n*(CT(75)*n-CT(90))+CT(42))/CT(5120);
            c[23] = (CT(9)-CT(15)*n)/CT(1024);
            c[24] = CT(99)/CT(16384);
            c[25] = (CT(44)-CT(99)*n)/CT(8192);
            c[26] = CT(99)/CT(16384);
            c[27] = CT(429)/CT(114688);
            break;
        }
    }

    /*
    \brief Given the set of coefficients coeffs2[] evaluate on
      C3 and return the set of coefficients coeffs1[].

      Elements coeffs1[1] through coeffs1[SeriesOrder - 1] are set.
    */
    template <typename Coeffs1, typename Coeffs2, typename CT>
    inline void evaluate_coeffs_C3(Coeffs1 &coeffs1, Coeffs2 &coeffs2, CT const& eps)
    {
        CT mult = 1;
        size_t offset = 0;

        // i is the index of C3[i].
        for (size_t i = 1; i < Coeffs1::static_size; ++i)
        {
            // Order of polynomial in eps.
            size_t m = Coeffs1::static_size - i;
            mult *= eps;

            coeffs1[i] = mult * math::horner_evaluate(eps, coeffs2.begin() + offset,
                                                           coeffs2.begin() + offset + m);

            offset += m;
        }
        // Post condition: offset == coeffs_C3_size
    }

    /*
    \brief Evaluate the following:

     y = sum(c[i] * sin(2*i * x), i, 1, n)

     using Clenshaw summation.
    */
    template <typename CT, typename Coeffs>
    inline CT sin_cos_series(CT const& sinx, CT const& cosx, Coeffs const& coeffs)
    {
        size_t n = Coeffs::static_size - 1;
        size_t index = 0;

        // Point to one beyond last element.
        index += (n + 1);
        CT ar = 2 * (cosx - sinx) * (cosx + sinx);

        // If n is odd, get the last element.
        CT k0 = n & 1 ? coeffs[--index] : 0;
        CT k1 = 0;

        // Make n even.
        n /= 2;
        while (n--) {
            // Unroll loop x 2, so accumulators return to their original role.
            k1 = ar * k0 - k1 + coeffs[--index];
            k0 = ar * k1 - k0 + coeffs[--index];
        }

        return 2 * sinx * cosx * k0;
    }

    /*
     The coefficient containers for the series expansions.
     These structs allow the caller to only know the series order.
    */
    template <size_t SeriesOrder, typename CT>
    struct coeffs_C1 : boost::array<CT, SeriesOrder + 1>
    {
        coeffs_C1(CT const& epsilon)
        {
            evaluate_coeffs_C1(*this, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C1p : boost::array<CT, SeriesOrder + 1>
    {
        coeffs_C1p(CT const& epsilon)
        {
            evaluate_coeffs_C1p(*this, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C2 : boost::array<CT, SeriesOrder + 1>
    {
        coeffs_C2(CT const& epsilon)
        {
            evaluate_coeffs_C2(*this, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C3x : boost::array<CT, (SeriesOrder * (SeriesOrder - 1)) / 2>
    {
        coeffs_C3x(CT const& n)
        {
            evaluate_coeffs_C3x<SeriesOrder>(*this, n);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_C3 : boost::array<CT, SeriesOrder>
    {
        coeffs_C3(CT const& n, CT const& epsilon)
        {
            coeffs_C3x<SeriesOrder, CT> coeffs_C3x(n);

            evaluate_coeffs_C3(*this, coeffs_C3x, epsilon);
        }
    };

    template <size_t SeriesOrder, typename CT>
    struct coeffs_A3 : boost::array<CT, SeriesOrder>
    {
        coeffs_A3(CT const& n)
        {
            evaluate_coeffs_A3(*this, n);
        }
    };

}}} // namespace boost::geometry::series_expansion

#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

/* series_expansion.hpp
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
*/