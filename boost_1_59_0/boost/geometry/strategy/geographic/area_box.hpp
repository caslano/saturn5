// Boost.Geometry

// Copyright (c) 2021, Oracle and/or its affiliates.

// Contributed and/or modified by Adam Wulkiewicz, on behalf of Oracle

// Licensed under the Boost Software License version 1.0.
// http://www.boost.org/users/license.html

#ifndef BOOST_GEOMETRY_STRATEGY_GEOGRAPHIC_AREA_BOX_HPP
#define BOOST_GEOMETRY_STRATEGY_GEOGRAPHIC_AREA_BOX_HPP


#include <boost/geometry/core/radian_access.hpp>
#include <boost/geometry/srs/spheroid.hpp>
#include <boost/geometry/strategies/spherical/get_radius.hpp>
#include <boost/geometry/strategy/area.hpp>
#include <boost/geometry/util/normalize_spheroidal_box_coordinates.hpp>


namespace boost { namespace geometry
{

namespace strategy { namespace area
{

// Based on the approach for spherical coordinate system:
// https://math.stackexchange.com/questions/131735/surface-element-in-spherical-coordinates
// http://www.cs.cmu.edu/afs/cs/academic/class/16823-s16/www/pdfs/appearance-modeling-3.pdf
// https://www.astronomyclub.xyz/celestial-sphere-2/solid-angle-on-the-celestial-sphere.html
// https://mathworld.wolfram.com/SolidAngle.html
// https://en.wikipedia.org/wiki/Spherical_coordinate_system
// and equations for spheroid:
// https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
// https://en.wikipedia.org/wiki/Meridian_arc
// Note that the equations use geodetic latitudes so we do not have to convert them.
// assume(y_max > y_min);
// assume(x_max > x_min);
// M: a*(1-e^2) / (1-e^2*sin(y)^2)^(3/2);
// N: a / sqrt(1-e^2*sin(y)^2);
// O: N*cos(y)*M;
// tellsimp(log(abs(e*sin(y_min)+1)), p_min);
// tellsimp(log(abs(e*sin(y_min)-1)), m_min);
// tellsimp(log(abs(e*sin(y_max)+1)), p_max);
// tellsimp(log(abs(e*sin(y_max)-1)), m_max);
// S: integrate(integrate(O, y, y_min, y_max), x, x_min, x_max);
// combine(S);
//
// An alternative solution to the above formula was suggested by Charles Karney
// https://github.com/boostorg/geometry/pull/832
// The following are formulas for area of a box defined by the equator and some latitude,
// not arbitrary box.
// For e^2 > 0
// dlambda*b^2*sin(phi)/2*(1/(1-e^2*sin(phi)^2) + atanh(e*sin(phi))/(e*sin(phi)))
// For e^2 < 0
// dlambda*b^2*sin(phi)/2*(1/(1-e^2*sin(phi)^2) + atan(ea*sin(phi))/(ea*sin(phi)))
// where ea = sqrt(-e^2)
template
<
    typename Spheroid = srs::spheroid<double>,
    typename CalculationType = void
>
class geographic_box
{
public:
    template <typename Box>
    struct result_type
        : strategy::area::detail::result_type
            <
                Box,
                CalculationType
            >
    {};

    geographic_box() = default;

    explicit geographic_box(Spheroid const& spheroid)
        : m_spheroid(spheroid)
    {}
    
    template <typename Box>
    inline auto apply(Box const& box) const
    {
        typedef typename result_type<Box>::type return_type;

        return_type const c0 = 0;
        
        return_type x_min = get_as_radian<min_corner, 0>(box); // lon
        return_type y_min = get_as_radian<min_corner, 1>(box); // lat
        return_type x_max = get_as_radian<max_corner, 0>(box);
        return_type y_max = get_as_radian<max_corner, 1>(box);

        math::normalize_spheroidal_box_coordinates<radian>(x_min, y_min, x_max, y_max);

        if (x_min == x_max || y_max == y_min)
        {
            return c0;
        }

        return_type const e2 = formula::eccentricity_sqr<return_type>(m_spheroid);

        return_type const x_diff = x_max - x_min;
        return_type const sin_y_min = sin(y_min);
        return_type const sin_y_max = sin(y_max);

        if (math::equals(e2, c0))
        {
            // spherical formula
            return_type const a = get_radius<0>(m_spheroid);
            return x_diff * (sin_y_max - sin_y_min) * a * a;
        }

        return_type const c1 = 1;
        return_type const c2 = 2;
        return_type const b = get_radius<2>(m_spheroid);

        /*
        return_type const c4 = 4;
        return_type const e = math::sqrt(e2);

        return_type const p_min = log(math::abs(e * sin_y_min + c1));
        return_type const p_max = log(math::abs(e * sin_y_max + c1));
        return_type const m_min = log(math::abs(e * sin_y_min - c1));
        return_type const m_max = log(math::abs(e * sin_y_max - c1));
        return_type const n_min = e * sin_y_min * sin_y_min;
        return_type const n_max = e * sin_y_max * sin_y_max;
        return_type const d_min = e * n_min - c1;
        return_type const d_max = e * n_max - c1;

        // NOTE: For equal latitudes the original formula generated by maxima may give negative
        //   result. It's caused by the order of operations, so here they're rearranged for
        //   symmetry.
        return_type const comp0 = (p_min - m_min) / (c4 * e * d_min);
        return_type const comp1 = sin_y_min / (c2 * d_min);
        return_type const comp2 = n_min * (m_min - p_min) / (c4 * d_min);
        return_type const comp3 = (p_max - m_max) / (c4 * e * d_max);
        return_type const comp4 = sin_y_max / (c2 * d_max);
        return_type const comp5 = n_max * (m_max - p_max) / (c4 * d_max);
        return_type const comp02 = comp0 + comp1 + comp2;
        return_type const comp35 = comp3 + comp4 + comp5;

        return b * b * x_diff * (comp02 - comp35);
        */

        return_type const comp0_min = c1 / (c1 - e2 * sin_y_min * sin_y_min);
        return_type const comp0_max = c1 / (c1 - e2 * sin_y_max * sin_y_max);

        // NOTE: For latitudes equal to 0 the original formula returns NAN
        return_type comp1_min = 0, comp1_max = 0;
        if (e2 > c0)
        {
            return_type const e = math::sqrt(e2);
            return_type const e_sin_y_min = e * sin_y_min;
            return_type const e_sin_y_max = e * sin_y_max;

            comp1_min = e_sin_y_min == c0 ? c1 : atanh(e_sin_y_min) / e_sin_y_min;
            comp1_max = e_sin_y_max == c0 ? c1 : atanh(e_sin_y_max) / e_sin_y_max;
        }
        else
        {
            return_type const ea = math::sqrt(-e2);
            return_type const ea_sin_y_min = ea * sin_y_min;
            return_type const ea_sin_y_max = ea * sin_y_max;

            comp1_min = ea_sin_y_min == c0 ? c1 : atan(ea_sin_y_min) / ea_sin_y_min;
            comp1_max = ea_sin_y_max == c0 ? c1 : atan(ea_sin_y_max) / ea_sin_y_max;
        }

        return_type const comp01_min = sin_y_min * (comp0_min + comp1_min);
        return_type const comp01_max = sin_y_max * (comp0_max + comp1_max);

        return b * b * x_diff * (comp01_max - comp01_min) / c2;
    }

    Spheroid model() const
    {
        return m_spheroid;
    }

private:
    Spheroid m_spheroid;
};


}} // namespace strategy::area


}} // namespace boost::geometry


#endif // BOOST_GEOMETRY_STRATEGY_GEOGRAPHIC_AREA_BOX_HPP

/* area_box.hpp
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
*/