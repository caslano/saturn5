// Boost.Geometry Index
//
// Spatial index distance predicates, calculators and checkers used in nearest neighbor query
//
// Copyright (c) 2011-2013 Adam Wulkiewicz, Lodz, Poland.
//
// Use, modification and distribution is subject to the Boost Software License,
// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_GEOMETRY_INDEX_DISTANCE_PREDICATES_HPP
#define BOOST_GEOMETRY_INDEX_DISTANCE_PREDICATES_HPP

#include <boost/geometry/index/detail/distance_predicates.hpp>

/*!
\defgroup nearest_relations Nearest relations (boost::geometry::index::)
*/

namespace boost { namespace geometry { namespace index {

// relations generators

#ifdef BOOST_GEOMETRY_INDEX_DETAIL_EXPERIMENTAL

/*!
\brief Generate to_nearest() relationship.

Generate a nearest query Point and Value's Indexable relationship while calculating
distances. This function may be used to define that knn query should calculate distances
as smallest as possible between query Point and Indexable's points. In other words it
should be the distance to the nearest Indexable's point. This function may be also used
to define distances bounds which indicates that Indexable's nearest point should be
closer or further than value v. This is default relation.

\ingroup nearest_relations

\tparam T   Type of wrapped object. This may be a Point for PointRelation or CoordinateType for
            MinRelation or MaxRelation

\param v    Point or distance value.
*/
template <typename T>
detail::to_nearest<T> to_nearest(T const& v)
{
    return detail::to_nearest<T>(v);
}

/*!
\brief Generate to_centroid() relationship.

Generate a nearest query Point and Value's Indexable relationship while calculating
distances. This function may be used to define that knn query should calculate distances
between query Point and Indexable's centroid. This function may be also used
to define distances bounds which indicates that Indexable's centroid should be
closer or further than value v.

\ingroup nearest_relations

\tparam T   Type of wrapped object. This may be a Point for PointRelation or some CoordinateType for
            MinRelation or MaxRelation

\param v    Point or distance value.
*/
template <typename T>
detail::to_centroid<T> to_centroid(T const& v)
{
    return detail::to_centroid<T>(v);
}

/*!
\brief Generate to_furthest() relationship.

Generate a nearest query Point and Value's Indexable relationship while calculating
distances. This function may be used to define that knn query should calculate distances
as biggest as possible between query Point and Indexable's points. In other words it
should be the distance to the furthest Indexable's point. This function may be also used
to define distances bounds which indicates that Indexable's furthest point should be
closer or further than value v.

\ingroup nearest_relations

\tparam T   Type of wrapped object. This may be a Point for PointRelation or some CoordinateType for
            MinRelation or MaxRelation

\param v    Point or distance value.
*/
template <typename T>
detail::to_furthest<T> to_furthest(T const& v)
{
    return detail::to_furthest<T>(v);
}

#endif // BOOST_GEOMETRY_INDEX_DETAIL_EXPERIMENTAL

// distance predicates generators

/*!
\brief Generate unbounded() distance predicate.

Generate a distance predicate. This defines distances bounds which are used by knn query.
This function indicates that there is no distance bounds and Values should be returned
if distances between Point and Indexable are the smallest. Distance calculation is defined
by PointRelation. This is default nearest predicate.

\ingroup distance_predicates

\tparam PointRelation   PointRelation type.

\param pr               The point relation. This may be generated by \c index::to_nearest(),
                        \c index::to_centroid() or \c index::to_furthest() with \c Point passed as a parameter.
*/
//template <typename PointRelation>
//inline detail::unbounded<PointRelation>
//unbounded(PointRelation const& pr)
//{
//    return detail::unbounded<PointRelation>(pr);
//}

/*!
\brief Generate min_bounded() distance predicate.

Generate a distance predicate. This defines distances bounds which are used by knn query.
This function indicates that Values should be returned only if distances between Point and
Indexable are greater or equal to some min_distance passed in MinRelation. Check for closest Value is
defined by PointRelation. So it is possible e.g. to return Values with centroids closest to some
Point but only if nearest points are further than some distance.

\ingroup distance_predicates

\tparam PointRelation   PointRelation type.
\tparam MinRelation     MinRelation type.

\param pr               The point relation. This may be generated by \c to_nearest(),
                        \c to_centroid() or \c to_furthest() with \c Point passed as a parameter.
\param minr             The minimum bound relation. This may be generated by \c to_nearest(),
                        \c to_centroid() or \c to_furthest() with distance value passed as a parameter.
*/
//template <typename PointRelation, typename MinRelation>
//inline detail::min_bounded<PointRelation, MinRelation>
//min_bounded(PointRelation const& pr, MinRelation const& minr)
//{
//    return detail::min_bounded<PointRelation, MinRelation>(pr, minr);
//}

/*!
\brief Generate max_bounded() distance predicate.

Generate a distance predicate. This defines distances bounds which are used by knn query.
This function indicates that Values should be returned only if distances between Point and
Indexable are lesser or equal to some max_distance passed in MaxRelation. Check for closest Value is
defined by PointRelation. So it is possible e.g. to return Values with centroids closest to some
Point but only if nearest points are closer than some distance.

\ingroup distance_predicates

\tparam PointRelation   PointRelation type.
\tparam MaxRelation     MaxRelation type.

\param pr               The point relation. This may be generated by \c to_nearest(),
                        \c to_centroid() or \c to_furthest() with \c Point passed as a parameter.
\param maxr             The maximum bound relation. This may be generated by \c to_nearest(),
                        \c to_centroid() or \c to_furthest() with distance value passed as a parameter.
*/
//template <typename PointRelation, typename MaxRelation>
//inline detail::max_bounded<PointRelation, MaxRelation>
//max_bounded(PointRelation const& pr, MaxRelation const& maxr)
//{
//    return detail::max_bounded<PointRelation, MaxRelation>(pr, maxr);
//}

/*!
\brief Generate bounded() distance predicate.

Generate a distance predicate. This defines distances bounds which are used by knn query.
This function indicates that Values should be returned only if distances between Point and
Indexable are greater or equal to some min_distance passed in MinRelation and lesser or equal to
some max_distance passed in MaxRelation. Check for closest Value is defined by PointRelation.
So it is possible e.g. to return Values with centroids closest to some Point but only if nearest
points are further than some distance and closer than some other distance.

\ingroup distance_predicates

\tparam PointRelation   PointRelation type.
\tparam MinRelation     MinRelation type.
\tparam MaxRelation     MaxRelation type.

\param pr               The point relation. This may be generated by \c to_nearest(),
                        \c to_centroid() or \c to_furthest() with \c Point passed as a parameter.
\param minr             The minimum bound relation. This may be generated by \c to_nearest(),
                        \c to_centroid() or \c to_furthest() with distance value passed as a parameter.
\param maxr             The maximum bound relation. This may be generated by \c to_nearest(),
                        \c to_centroid() or \c to_furthest() with distance value passed as a parameter.
*/
//template <typename PointRelation, typename MinRelation, typename MaxRelation>
//inline detail::bounded<PointRelation, MinRelation, MaxRelation>
//bounded(PointRelation const& pr, MinRelation const& minr, MaxRelation const& maxr)
//{
//    return detail::bounded<PointRelation, MinRelation, MaxRelation>(pr, minr, maxr);
//}

}}} // namespace boost::geometry::index

#endif // BOOST_GEOMETRY_INDEX_DISTANCE_PREDICATES_HPP

/* distance_predicates.hpp
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
*/