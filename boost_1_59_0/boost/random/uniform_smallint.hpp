/* boost random/uniform_smallint.hpp header file
 *
 * Copyright Jens Maurer 2000-2001
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * See http://www.boost.org for most recent version including documentation.
 *
 * $Id$
 *
 * Revision history
 *  2001-04-08  added min<max assertion (N. Becker)
 *  2001-02-18  moved to individual header files
 */

#ifndef BOOST_RANDOM_UNIFORM_SMALLINT_HPP
#define BOOST_RANDOM_UNIFORM_SMALLINT_HPP

#include <istream>
#include <iosfwd>
#include <boost/assert.hpp>
#include <boost/config.hpp>
#include <boost/limits.hpp>
#include <boost/type_traits/is_integral.hpp>
#include <boost/random/detail/config.hpp>
#include <boost/random/detail/operators.hpp>
#include <boost/random/detail/signed_unsigned_tools.hpp>
#include <boost/random/uniform_01.hpp>
#include <boost/detail/workaround.hpp>

#ifdef BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS
#include <boost/type_traits/conditional.hpp>
#endif

namespace boost {
namespace random {

// uniform integer distribution on a small range [min, max]

/**
 * The distribution function uniform_smallint models a \random_distribution.
 * On each invocation, it returns a random integer value uniformly distributed
 * in the set of integer numbers {min, min+1, min+2, ..., max}. It assumes
 * that the desired range (max-min+1) is small compared to the range of the
 * underlying source of random numbers and thus makes no attempt to limit
 * quantization errors.
 *
 * Let \f$r_{\mathtt{out}} = (\mbox{max}-\mbox{min}+1)\f$ the desired range of
 * integer numbers, and
 * let \f$r_{\mathtt{base}}\f$ be the range of the underlying source of random
 * numbers. Then, for the uniform distribution, the theoretical probability
 * for any number i in the range \f$r_{\mathtt{out}}\f$ will be
 * \f$\displaystyle p_{\mathtt{out}}(i) = \frac{1}{r_{\mathtt{out}}}\f$.
 * Likewise, assume a uniform distribution on \f$r_{\mathtt{base}}\f$ for
 * the underlying source of random numbers, i.e.
 * \f$\displaystyle p_{\mathtt{base}}(i) = \frac{1}{r_{\mathtt{base}}}\f$.
 * Let \f$p_{\mathtt{out\_s}}(i)\f$ denote the random
 * distribution generated by @c uniform_smallint. Then the sum over all
 * i in \f$r_{\mathtt{out}}\f$ of
 * \f$\displaystyle
 * \left(\frac{p_{\mathtt{out\_s}}(i)}{p_{\mathtt{out}}(i)} - 1\right)^2\f$
 * shall not exceed
 * \f$\displaystyle \frac{r_{\mathtt{out}}}{r_{\mathtt{base}}^2}
 * (r_{\mathtt{base}} \mbox{ mod } r_{\mathtt{out}})
 * (r_{\mathtt{out}} - r_{\mathtt{base}} \mbox{ mod } r_{\mathtt{out}})\f$.
 *
 * The template parameter IntType shall denote an integer-like value type.
 *
 * @xmlnote
 * The property above is the square sum of the relative differences
 * in probabilities between the desired uniform distribution
 * \f$p_{\mathtt{out}}(i)\f$ and the generated distribution
 * \f$p_{\mathtt{out\_s}}(i)\f$.
 * The property can be fulfilled with the calculation
 * \f$(\mbox{base\_rng} \mbox{ mod } r_{\mathtt{out}})\f$, as follows:
 * Let \f$r = r_{\mathtt{base}} \mbox{ mod } r_{\mathtt{out}}\f$.
 * The base distribution on \f$r_{\mathtt{base}}\f$ is folded onto the
 * range \f$r_{\mathtt{out}}\f$. The numbers i < r have assigned
 * \f$\displaystyle
 * \left\lfloor\frac{r_{\mathtt{base}}}{r_{\mathtt{out}}}\right\rfloor+1\f$
 * numbers of the base distribution, the rest has only \f$\displaystyle
 * \left\lfloor\frac{r_{\mathtt{base}}}{r_{\mathtt{out}}}\right\rfloor\f$.
 * Therefore,
 * \f$\displaystyle p_{\mathtt{out\_s}}(i) =
 * \left(\left\lfloor\frac{r_{\mathtt{base}}}
 * {r_{\mathtt{out}}}\right\rfloor+1\right) /
 * r_{\mathtt{base}}\f$ for i < r and \f$\displaystyle p_{\mathtt{out\_s}}(i) =
 * \left\lfloor\frac{r_{\mathtt{base}}}
 * {r_{\mathtt{out}}}\right\rfloor/r_{\mathtt{base}}\f$ otherwise.
 * Substituting this in the
 * above sum formula leads to the desired result.
 * @endxmlnote
 *
 * Note: The upper bound for
 * \f$(r_{\mathtt{base}} \mbox{ mod } r_{\mathtt{out}})
 * (r_{\mathtt{out}} - r_{\mathtt{base}} \mbox{ mod } r_{\mathtt{out}})\f$ is
 * \f$\displaystyle \frac{r_{\mathtt{out}}^2}{4}\f$.  Regarding the upper bound
 * for the square sum of the relative quantization error of
 * \f$\displaystyle \frac{r_\mathtt{out}^3}{4r_{\mathtt{base}}^2}\f$, it
 * seems wise to either choose \f$r_{\mathtt{base}}\f$ so that
 * \f$r_{\mathtt{base}} > 10r_{\mathtt{out}}^2\f$ or ensure that
 * \f$r_{\mathtt{base}}\f$ is
 * divisible by \f$r_{\mathtt{out}}\f$.
 */
template<class IntType = int>
class uniform_smallint
{
public:
    typedef IntType input_type;
    typedef IntType result_type;

    class param_type
    {
    public:

        typedef uniform_smallint distribution_type;

        /** constructs the parameters of a @c uniform_smallint distribution. */
        param_type(IntType min_arg = 0, IntType max_arg = 9)
          : _min(min_arg), _max(max_arg)
        {
            BOOST_ASSERT(_min <= _max);
        }

        /** Returns the minimum value. */
        IntType a() const { return _min; }
        /** Returns the maximum value. */
        IntType b() const { return _max; }
        

        /** Writes the parameters to a @c std::ostream. */
        BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, param_type, parm)
        {
            os << parm._min << " " << parm._max;
            return os;
        }
    
        /** Reads the parameters from a @c std::istream. */
        BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, param_type, parm)
        {
            is >> parm._min >> std::ws >> parm._max;
            return is;
        }

        /** Returns true if the two sets of parameters are equal. */
        BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(param_type, lhs, rhs)
        { return lhs._min == rhs._min && lhs._max == rhs._max; }

        /** Returns true if the two sets of parameters are different. */
        BOOST_RANDOM_DETAIL_INEQUALITY_OPERATOR(param_type)

    private:
        IntType _min;
        IntType _max;
    };

    /**
     * Constructs a @c uniform_smallint. @c min and @c max are the
     * lower and upper bounds of the output range, respectively.
     */
    explicit uniform_smallint(IntType min_arg = 0, IntType max_arg = 9)
      : _min(min_arg), _max(max_arg) {}

    /**
     * Constructs a @c uniform_smallint from its parameters.
     */
    explicit uniform_smallint(const param_type& parm)
      : _min(parm.a()), _max(parm.b()) {}

    /** Returns the minimum value of the distribution. */
    result_type a() const { return _min; }
    /** Returns the maximum value of the distribution. */
    result_type b() const { return _max; }
    /** Returns the minimum value of the distribution. */
    result_type min BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _min; }
    /** Returns the maximum value of the distribution. */
    result_type max BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _max; }

    /** Returns the parameters of the distribution. */
    param_type param() const { return param_type(_min, _max); }
    /** Sets the parameters of the distribution. */
    void param(const param_type& parm)
    {
        _min = parm.a();
        _max = parm.b();
    }

    /**
     * Effects: Subsequent uses of the distribution do not depend
     * on values produced by any engine prior to invoking reset.
     */
    void reset() { }

    /** Returns a value uniformly distributed in the range [min(), max()]. */
    template<class Engine>
    result_type operator()(Engine& eng) const
    {
        typedef typename Engine::result_type base_result;
        return generate(eng, boost::random::traits::is_integral<base_result>());
    }

    /** Returns a value uniformly distributed in the range [param.a(), param.b()]. */
    template<class Engine>
    result_type operator()(Engine& eng, const param_type& parm) const
    { return uniform_smallint(parm)(eng); }

    /** Writes the distribution to a @c std::ostream. */
    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, uniform_smallint, ud)
    {
        os << ud._min << " " << ud._max;
        return os;
    }
    
    /** Reads the distribution from a @c std::istream. */
    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, uniform_smallint, ud)
    {
        is >> ud._min >> std::ws >> ud._max;
        return is;
    }

    /**
     * Returns true if the two distributions will produce identical
     * sequences of values given equal generators.
     */
    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(uniform_smallint, lhs, rhs)
    { return lhs._min == rhs._min && lhs._max == rhs._max; }
    
    /**
     * Returns true if the two distributions may produce different
     * sequences of values given equal generators.
     */
    BOOST_RANDOM_DETAIL_INEQUALITY_OPERATOR(uniform_smallint)

private:
    
    // \cond show_private
    template<class Engine>
    result_type generate(Engine& eng, boost::true_type) const
    {
        // equivalent to (eng() - eng.min()) % (_max - _min + 1) + _min,
        // but guarantees no overflow.
        typedef typename Engine::result_type base_result;
        typedef typename boost::random::traits::make_unsigned<base_result>::type base_unsigned;
        typedef typename boost::random::traits::make_unsigned_or_unbounded<result_type>::type range_type;
#ifdef BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS
        typedef typename conditional<
           std::numeric_limits<range_type>::is_specialized && std::numeric_limits<base_unsigned>::is_specialized
           && (std::numeric_limits<range_type>::digits >= std::numeric_limits<base_unsigned>::digits),
           range_type, base_unsigned>::type mixed_range_type;
#else
        typedef base_unsigned mixed_range_type;
#endif
        range_type range = random::detail::subtract<result_type>()(_max, _min);
        base_unsigned base_range =
            random::detail::subtract<base_result>()((eng.max)(), (eng.min)());
        base_unsigned val =
            random::detail::subtract<base_result>()(eng(), (eng.min)());
        if(range >= base_range) {
            return boost::random::detail::add<range_type, result_type>()(
                static_cast<range_type>(val), _min);
        } else {
            // This involves mixed arithmetic between the base generators range
            // type, and the result_type's range type.  mixed_range_type is
            // normally the same as base_unsigned which is the most efficient
            // option, but requires a narrowing explcit cast if result_type
            // is a multiprecision type.  If no such casts are available then use
            // multiprecision arithmetic throughout instead.
            mixed_range_type modulus = static_cast<mixed_range_type>(range)+1;
            return boost::random::detail::add<range_type, result_type>()(
                static_cast<mixed_range_type>(val) % modulus, _min);
        }
    }
    
    template<class Engine>
    result_type generate(Engine& eng, boost::false_type) const
    {
        typedef typename Engine::result_type base_result;
        typedef typename boost::random::traits::make_unsigned<result_type>::type range_type;
        range_type range = random::detail::subtract<result_type>()(_max, _min);
        base_result val = boost::uniform_01<base_result>()(eng);
        // what is the worst that can possibly happen here?
        // base_result may not be able to represent all the values in [0, range]
        // exactly.  If this happens, it will cause round off error and we
        // won't be able to produce all the values in the range.  We don't
        // care about this because the user has already told us not to by
        // using uniform_smallint.  However, we do need to be careful
        // to clamp the result, or floating point rounding can produce
        // an out of range result.
        range_type offset = static_cast<range_type>(val * (static_cast<base_result>(range) + 1));
        if(offset > range) return _max;
        return boost::random::detail::add<range_type, result_type>()(offset , _min);
    }
    // \endcond

    result_type _min;
    result_type _max;
};

} // namespace random

using random::uniform_smallint;

} // namespace boost

#endif // BOOST_RANDOM_UNIFORM_SMALLINT_HPP

/* uniform_smallint.hpp
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
*/