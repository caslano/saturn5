/* boost random/linear_feedback_shift.hpp header file
 *
 * Copyright Jens Maurer 2002
 * Copyright Steven Watanabe 2011
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * See http://www.boost.org for most recent version including documentation.
 *
 * $Id$
 *
 */

#ifndef BOOST_RANDOM_LINEAR_FEEDBACK_SHIFT_HPP
#define BOOST_RANDOM_LINEAR_FEEDBACK_SHIFT_HPP

#include <iosfwd>
#include <stdexcept>
#include <boost/config.hpp>
#include <boost/cstdint.hpp>
#include <boost/static_assert.hpp>
#include <boost/integer/integer_mask.hpp>
#include <boost/random/detail/config.hpp>
#include <boost/random/detail/seed.hpp>
#include <boost/random/detail/operators.hpp>
#include <boost/random/detail/seed_impl.hpp>

namespace boost {
namespace random {

/**
 * Instatiations of @c linear_feedback_shift model a
 * \pseudo_random_number_generator.  It was originally
 * proposed in
 *
 *  @blockquote
 *  "Random numbers generated by linear recurrence modulo two.",
 *  Tausworthe, R. C.(1965), Mathematics of Computation 19, 201-209.
 *  @endblockquote
 */
template<class UIntType, int w, int k, int q, int s>
class linear_feedback_shift_engine
{
public:
    typedef UIntType result_type;
    BOOST_STATIC_CONSTANT(bool, has_fixed_range = false);
    BOOST_STATIC_CONSTANT(int, word_size = w);
    BOOST_STATIC_CONSTANT(int, exponent1 = k);
    BOOST_STATIC_CONSTANT(int, exponent2 = q);
    BOOST_STATIC_CONSTANT(int, step_size = s);
    BOOST_STATIC_CONSTANT(UIntType, default_seed = 341);

    /** Returns the smallest value that the generator can produce. */
    static BOOST_CONSTEXPR result_type min BOOST_PREVENT_MACRO_SUBSTITUTION () { return 0; }
    /** Returns the largest value that the generator can produce. */
    static BOOST_CONSTEXPR result_type max BOOST_PREVENT_MACRO_SUBSTITUTION ()
    { return wordmask(); }

    BOOST_STATIC_ASSERT(w > 0);
    BOOST_STATIC_ASSERT(q > 0);
    BOOST_STATIC_ASSERT(k < w);
    BOOST_STATIC_ASSERT(0 < 2*q && 2*q < k);
    BOOST_STATIC_ASSERT(0 < s && s <= k-q);

    /** Constructs a @c linear_feedback_shift_engine, using the default seed. */
    linear_feedback_shift_engine() { seed(); }
    
    /** Constructs a @c linear_feedback_shift_engine, seeding it with s0. */
    BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(linear_feedback_shift_engine,
        UIntType, s0)
    { seed(s0); }
    
    /** Constructs a @c linear_feedback_shift_engine, seeding it with seq. */
    BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR(linear_feedback_shift_engine,
        SeedSeq, seq)
    { seed(seq); }
    
    /**
     * Constructs a @c linear_feedback_shift_engine, seeding it with 
     * values from the range [first, last).
     */
    template<class It> linear_feedback_shift_engine(It& first, It last)
    { seed(first, last); }
    
    /** Seeds a @c linear_feedback_shift_engine with the default seed. */
    void seed() {  seed(default_seed); }
    
    /** Seeds a @c linear_feedback_shift_engine with @c s0. */
    BOOST_RANDOM_DETAIL_ARITHMETIC_SEED(linear_feedback_shift_engine,
        UIntType, s0)
    {
        value = s0 & wordmask();
        if(value < (1 << (w-k))) {
            value += 1 << (w-k);
        }
    }
    
    /**
     * Seeds a @c linear_feedback_shift_engine with values
     * produced by @c seq.generate().
     */
    BOOST_RANDOM_DETAIL_SEED_SEQ_SEED(linear_feedback_shift_engine,
        SeedSeq, seq)
    { seed(detail::seed_one_int<UIntType, (UIntType(2) << (w - 1))>(seq)); }
    
    /**
     * Seeds a @c linear_feedback_shift_engine with values
     * from the range [first, last).
     */
    template<class It> void seed(It& first, It last)
    {
        seed(detail::get_one_int<UIntType, (UIntType(2) << (w - 1))>(first, last));
    }

    /** Returns the next value of the generator. */
    result_type operator()()
    {
        const UIntType b = (((value << q) ^ value) & wordmask()) >> (k-s);
        const UIntType mask = (wordmask() << (w-k)) & wordmask();
        value = ((value & mask) << s) ^ b;
        return value;
    }
  
    /** Fills a range with random values */
    template<class Iter>
    void generate(Iter first, Iter last)
    { detail::generate_from_int(*this, first, last); }

    /** Advances the state of the generator by @c z. */
    void discard(boost::uintmax_t z)
    {
        for(boost::uintmax_t j = 0; j < z; ++j) {
            (*this)();
        }
    }
    
    /**
     * Writes the textual representation of the generator to a @c std::ostream.
     */
    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, linear_feedback_shift_engine, x)
    {
        os << x.value;
        return os;
    }
    
    /**
     * Reads the textual representation of the generator from a @c std::istream.
     */
    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, linear_feedback_shift_engine, x)
    {
        is >> x.value;
        return is;
    }

    /**
     * Returns true if the two generators will produce identical
     * sequences of outputs.
     */
    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(linear_feedback_shift_engine, x, y)
    { return x.value == y.value; }
    
    /**
     * Returns true if the two generators will produce different
     * sequences of outputs.
     */
    BOOST_RANDOM_DETAIL_INEQUALITY_OPERATOR(linear_feedback_shift_engine)

private:
    /// \cond show_private
    static BOOST_CONSTEXPR UIntType wordmask() { return boost::low_bits_mask_t<w>::sig_bits; }
    /// \endcond
    UIntType value;
};

#ifndef BOOST_NO_INCLASS_MEMBER_INITIALIZATION
//  A definition is required even for integral static constants
template<class UIntType, int w, int k, int q, int s>
const bool linear_feedback_shift_engine<UIntType, w, k, q, s>::has_fixed_range;
template<class UIntType, int w, int k, int q, int s>
const int linear_feedback_shift_engine<UIntType, w, k, q, s>::word_size;
template<class UIntType, int w, int k, int q, int s>
const int linear_feedback_shift_engine<UIntType, w, k, q, s>::exponent1;
template<class UIntType, int w, int k, int q, int s>
const int linear_feedback_shift_engine<UIntType, w, k, q, s>::exponent2;
template<class UIntType, int w, int k, int q, int s>
const int linear_feedback_shift_engine<UIntType, w, k, q, s>::step_size;
template<class UIntType, int w, int k, int q, int s>
const UIntType linear_feedback_shift_engine<UIntType, w, k, q, s>::default_seed;
#endif

/// \cond show_deprecated

/** Provided for backwards compatibility. */
template<class UIntType, int w, int k, int q, int s, UIntType v = 0>
class linear_feedback_shift :
    public linear_feedback_shift_engine<UIntType, w, k, q, s>
{
    typedef linear_feedback_shift_engine<UIntType, w, k, q, s> base_type;
public:
    linear_feedback_shift() {}
    BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR(linear_feedback_shift,
        SeedSeq, seq)
    { seed(seq); }
    BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(linear_feedback_shift,
        UIntType, val)
    { seed(val); }
    template<class It>
    linear_feedback_shift(It& first, It last) : base_type(first, last) {}
};

/// \endcond

} // namespace random
} // namespace boost

#endif // BOOST_RANDOM_LINEAR_FEEDBACK_SHIFT_HPP

/* linear_feedback_shift.hpp
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
*/