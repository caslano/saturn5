//  (C) Copyright Jeremy Siek 2004
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_PROPERTY_HPP
#define BOOST_PROPERTY_HPP

#include <boost/mpl/bool.hpp>
#include <boost/mpl/if.hpp>
#include <boost/mpl/has_xxx.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/type_traits.hpp>
#include <boost/static_assert.hpp>

namespace boost
{

struct no_property
{
};

template < class Tag, class T, class Base = no_property > struct property
{
    typedef Base next_type;
    typedef Tag tag_type;
    typedef T value_type;
    property(const T& v = T()) : m_value(v) {}
    property(const T& v, const Base& b) : m_value(v), m_base(b) {}
    // copy constructor and assignment operator will be generated by compiler

    T m_value;
    Base m_base;
};

// Kinds of properties
namespace graph_introspect_detail
{
    BOOST_MPL_HAS_XXX_TRAIT_DEF(kind)
    template < typename T, bool Cond > struct get_kind
    {
        typedef void type;
    };
    template < typename T > struct get_kind< T, true >
    {
        typedef typename T::kind type;
    };
}

// Having a default is to make this trait work for any type, not just valid
// properties, to work around VC++ <= 10 bugs related to SFINAE in
// compressed_sparse_row_graph's get functions and similar
template < class PropertyTag >
struct property_kind
: graph_introspect_detail::get_kind< PropertyTag,
      graph_introspect_detail::has_kind< PropertyTag >::value >
{
};

// Some standard properties defined independently of Boost.Graph:
enum vertex_all_t
{
    vertex_all
};
enum edge_all_t
{
    edge_all
};
enum graph_all_t
{
    graph_all
};
enum vertex_bundle_t
{
    vertex_bundle
};
enum edge_bundle_t
{
    edge_bundle
};
enum graph_bundle_t
{
    graph_bundle
};

// Code to look up one property in a property list:
template < typename PList, typename PropName, typename Enable = void >
struct lookup_one_property_internal
{
    BOOST_STATIC_CONSTANT(bool, found = false);
    typedef void type;
};

// Special-case properties (vertex_all, edge_all, graph_all)
#define BGL_ALL_PROP(tag)                                                 \
    template < typename T > struct lookup_one_property_internal< T, tag > \
    {                                                                     \
        BOOST_STATIC_CONSTANT(bool, found = true);                        \
        typedef T type;                                                   \
        static T& lookup(T& x, tag) { return x; }                         \
        static const T& lookup(const T& x, tag) { return x; }             \
    };                                                                    \
    template < typename Tag, typename T, typename Base >                  \
    struct lookup_one_property_internal< property< Tag, T, Base >, tag >  \
    { /* Avoid ambiguity */                                               \
        BOOST_STATIC_CONSTANT(bool, found = true);                        \
        typedef property< Tag, T, Base > type;                            \
        static type& lookup(type& x, tag) { return x; }                   \
        static const type& lookup(const type& x, tag) { return x; }       \
    };

BGL_ALL_PROP(vertex_all_t)
BGL_ALL_PROP(edge_all_t)
BGL_ALL_PROP(graph_all_t)
#undef BGL_ALL_PROP

// *_bundled; these need to be macros rather than inheritance to resolve
// ambiguities
#define BGL_DO_ONE_BUNDLE_TYPE(kind)                                           \
    template < typename T >                                                    \
    struct lookup_one_property_internal< T, BOOST_JOIN(kind, _bundle_t) >      \
    {                                                                          \
        BOOST_STATIC_CONSTANT(bool, found = true);                             \
        typedef T type;                                                        \
        static T& lookup(T& x, BOOST_JOIN(kind, _bundle_t)) { return x; }      \
        static const T& lookup(const T& x, BOOST_JOIN(kind, _bundle_t))        \
        {                                                                      \
            return x;                                                          \
        }                                                                      \
    };                                                                         \
                                                                               \
    template < typename Tag, typename T, typename Base >                       \
    struct lookup_one_property_internal< property< Tag, T, Base >,             \
        BOOST_JOIN(kind, _bundle_t) >                                          \
    : lookup_one_property_internal< Base, BOOST_JOIN(kind, _bundle_t) >        \
    {                                                                          \
    private:                                                                   \
        typedef lookup_one_property_internal< Base,                            \
            BOOST_JOIN(kind, _bundle_t) >                                      \
            base_type;                                                         \
                                                                               \
    public:                                                                    \
        template < typename BundleTag >                                        \
        static typename lazy_enable_if_c<                                      \
            (base_type::found                                                  \
                && (is_same< BundleTag,                                        \
                    BOOST_JOIN(kind, _bundle_t) >::value)),                    \
            add_reference< typename base_type::type > >::type                  \
        lookup(property< Tag, T, Base >& p, BundleTag)                         \
        {                                                                      \
            return base_type::lookup(p.m_base, BOOST_JOIN(kind, _bundle_t)()); \
        }                                                                      \
        template < typename BundleTag >                                        \
        static typename lazy_enable_if_c<                                      \
            (base_type::found                                                  \
                && (is_same< BundleTag,                                        \
                    BOOST_JOIN(kind, _bundle_t) >::value)),                    \
            add_reference< const typename base_type::type > >::type            \
        lookup(const property< Tag, T, Base >& p, BundleTag)                   \
        {                                                                      \
            return base_type::lookup(p.m_base, BOOST_JOIN(kind, _bundle_t)()); \
        }                                                                      \
    };

BGL_DO_ONE_BUNDLE_TYPE(vertex)
BGL_DO_ONE_BUNDLE_TYPE(edge)
BGL_DO_ONE_BUNDLE_TYPE(graph)
#undef BGL_DO_ONE_BUNDLE_TYPE

// Normal old-style properties; second case also handles chaining of bundled
// property accesses
template < typename Tag, typename T, typename Base >
struct lookup_one_property_internal< boost::property< Tag, T, Base >, Tag >
{
    BOOST_STATIC_CONSTANT(bool, found = true);
    typedef property< Tag, T, Base > prop;
    typedef T type;
    template < typename U >
    static typename enable_if< is_same< prop, U >, T& >::type lookup(
        U& prop, const Tag&)
    {
        return prop.m_value;
    }
    template < typename U >
    static typename enable_if< is_same< prop, U >, const T& >::type lookup(
        const U& prop, const Tag&)
    {
        return prop.m_value;
    }
};

template < typename Tag, typename T, typename Base, typename PropName >
struct lookup_one_property_internal< boost::property< Tag, T, Base >, PropName >
: lookup_one_property_internal< Base, PropName >
{
private:
    typedef lookup_one_property_internal< Base, PropName > base_type;

public:
    template < typename PL >
    static
        typename lazy_enable_if< is_same< PL, boost::property< Tag, T, Base > >,
            add_reference< typename base_type::type > >::type
        lookup(PL& prop, const PropName& tag)
    {
        return base_type::lookup(prop.m_base, tag);
    }
    template < typename PL >
    static
        typename lazy_enable_if< is_same< PL, boost::property< Tag, T, Base > >,
            add_reference< const typename base_type::type > >::type
        lookup(const PL& prop, const PropName& tag)
    {
        return base_type::lookup(prop.m_base, tag);
    }
};

// Pointer-to-member access to bundled properties
#ifndef BOOST_GRAPH_NO_BUNDLED_PROPERTIES
template < typename T, typename TMaybeBase, typename R >
struct lookup_one_property_internal< T, R TMaybeBase::*,
    typename enable_if< is_base_of< TMaybeBase, T > >::type >
{
    BOOST_STATIC_CONSTANT(bool, found = true);
    typedef R type;
    static R& lookup(T& x, R TMaybeBase::*ptr) { return x.*ptr; }
    static const R& lookup(const T& x, R TMaybeBase::*ptr) { return x.*ptr; }
};
#endif

// Version of above handling const property lists properly
template < typename T, typename Tag >
struct lookup_one_property : lookup_one_property_internal< T, Tag >
{
};

template < typename T, typename Tag > struct lookup_one_property< const T, Tag >
{
    BOOST_STATIC_CONSTANT(
        bool, found = (lookup_one_property_internal< T, Tag >::found));
    typedef const typename lookup_one_property_internal< T, Tag >::type type;
    template < typename U >
    static typename lazy_enable_if< is_same< T, U >,
        add_reference< const typename lookup_one_property_internal< T,
            Tag >::type > >::type
    lookup(const U& p, Tag tag)
    {
        return lookup_one_property_internal< T, Tag >::lookup(p, tag);
    }
};

// The BGL properties specialize property_kind and
// property_num, and use enum's for the Property type (see
// graph/properties.hpp), but the user may want to use a class
// instead with a nested kind type and num.  Also, we may want to
// switch BGL back to using class types for properties at some point.

template < class P > struct has_property : boost::mpl::true_
{
};
template <> struct has_property< no_property > : boost::mpl::false_
{
};

} // namespace boost

#include <boost/pending/detail/property.hpp>

namespace boost
{

template < class PropertyList, class Tag >
struct property_value : lookup_one_property< PropertyList, Tag >
{
};

template < class PropertyList, class Tag >
inline typename lookup_one_property< PropertyList, Tag >::type&
get_property_value(PropertyList& p, Tag tag)
{
    return lookup_one_property< PropertyList, Tag >::lookup(p, tag);
}

template < class PropertyList, class Tag >
inline const typename lookup_one_property< PropertyList, Tag >::type&
get_property_value(const PropertyList& p, Tag tag)
{
    return lookup_one_property< PropertyList, Tag >::lookup(p, tag);
}

namespace detail
{

    /** This trait returns true if T is no_property. */
    template < typename T >
    struct is_no_property : mpl::bool_< is_same< T, no_property >::value >
    {
    };

    template < typename PList, typename Tag > class lookup_one_property_f;

    template < typename PList, typename Tag, typename F >
    struct lookup_one_property_f_result;

    template < typename PList, typename Tag >
    struct lookup_one_property_f_result< PList, Tag,
        const lookup_one_property_f< PList, Tag >(PList) >
    {
        typedef typename lookup_one_property< PList, Tag >::type type;
    };

    template < typename PList, typename Tag >
    struct lookup_one_property_f_result< PList, Tag,
        const lookup_one_property_f< PList, Tag >(PList&) >
    {
        typedef typename lookup_one_property< PList, Tag >::type& type;
    };

    template < typename PList, typename Tag >
    struct lookup_one_property_f_result< PList, Tag,
        const lookup_one_property_f< PList, Tag >(const PList&) >
    {
        typedef const typename lookup_one_property< PList, Tag >::type& type;
    };

    template < typename PList, typename Tag > class lookup_one_property_f
    {
        Tag tag;

    public:
        lookup_one_property_f(Tag tag) : tag(tag) {}
        template < typename F >
        struct result : lookup_one_property_f_result< PList, Tag, F >
        {
        };

        typename lookup_one_property_f_result< PList, Tag,
            const lookup_one_property_f(PList&) >::type
        operator()(PList& pl) const
        {
            return lookup_one_property< PList, Tag >::lookup(pl, tag);
        }
    };

} // namespace detail

namespace detail
{
    // Stuff for directed_graph and undirected_graph to skip over their first
    // vertex_index and edge_index properties when providing vertex_all and
    // edge_all; make sure you know the exact structure of your properties if
    // you use there.
    struct remove_first_property
    {
        template < typename F > struct result
        {
            typedef typename boost::function_traits< F >::arg1_type a1;
            typedef typename boost::remove_reference< a1 >::type non_ref;
            typedef typename non_ref::next_type nx;
            typedef typename boost::mpl::if_< boost::is_const< non_ref >,
                boost::add_const< nx >, nx >::type with_const;
            typedef typename boost::add_reference< with_const >::type type;
        };
        template < typename Prop >
        typename Prop::next_type& operator()(Prop& p) const
        {
            return p.m_base;
        }
        template < typename Prop >
        const typename Prop::next_type& operator()(const Prop& p) const
        {
            return p.m_base;
        }
    };
}

} // namesapce boost

#endif /* BOOST_PROPERTY_HPP */

/* property.hpp
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
*/