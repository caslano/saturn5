//  Copyright (c) 2001-2011 Hartmut Kaiser
// 
//  Distributed under the Boost Software License, Version 1.0. (See accompanying 
//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#if !defined(BOOST_SPIRIT_LEXER_PARSE_NOV_17_2007_0246PM)
#define BOOST_SPIRIT_LEXER_PARSE_NOV_17_2007_0246PM

#if defined(_MSC_VER)
#pragma once
#endif

#include <boost/spirit/home/qi/skip_over.hpp>
#include <boost/spirit/home/qi/parse.hpp>
#include <boost/spirit/home/qi/nonterminal/grammar.hpp>
#include <boost/spirit/home/support/unused.hpp>
#include <boost/spirit/home/lex/lexer.hpp>
#include <boost/mpl/assert.hpp>

namespace boost { namespace phoenix
{
    template <typename Expr>
    struct actor;
}}

namespace boost { namespace spirit { namespace lex
{
    ///////////////////////////////////////////////////////////////////////////
    //  Import skip_flag enumerator type from Qi namespace
    using qi::skip_flag;

    ///////////////////////////////////////////////////////////////////////////
    //
    //  The tokenize_and_parse() function is one of the main Spirit API 
    //  functions. It simplifies using a lexer as the underlying token source
    //  while parsing a given input sequence.
    //
    //  The function takes a pair of iterators spanning the underlying input 
    //  stream to parse, the lexer object (built from the token definitions) 
    //  and a parser object (built from the parser grammar definition).
    //
    //  The second version of this function additionally takes an attribute to 
    //  be used as the top level data structure instance the parser should use 
    //  to store the recognized input to.
    //
    //  The function returns true if the parsing succeeded (the given input
    //  sequence has been successfully matched by the given grammar).
    //
    //  first, last:    The pair of iterators spanning the underlying input 
    //                  sequence to parse. These iterators must at least 
    //                  conform to the requirements of the std::intput_iterator 
    //                  category.
    //                  On exit the iterator 'first' will be updated to the 
    //                  position right after the last successfully matched 
    //                  token. 
    //  lex:            The lexer object (encoding the token definitions) to be
    //                  used to convert the input sequence into a sequence of 
    //                  tokens. This token sequence is passed to the parsing 
    //                  process. The LexerExpr type must conform to the 
    //                  lexer interface described in the corresponding section
    //                  of the documentation.
    //  xpr:            The grammar object (encoding the parser grammar) to be
    //                  used to match the token sequence generated by the lex 
    //                  object instance. The ParserExpr type must conform to 
    //                  the grammar interface described in the corresponding 
    //                  section of the documentation.
    //  attr:           The top level attribute passed to the parser. It will 
    //                  be populated during the parsing of the input sequence.
    //                  On exit it will hold the 'parser result' corresponding 
    //                  to the matched input sequence.
    //
    ///////////////////////////////////////////////////////////////////////////
    template <typename Iterator, typename Lexer, typename ParserExpr>
    inline bool
    tokenize_and_parse(Iterator& first, Iterator last, Lexer const& lex,
        ParserExpr const& xpr)
    {
        // Report invalid expression error as early as possible.
        // If you got an error_invalid_expression error message here,
        // then the expression (expr) is not a valid spirit qi expression.
        BOOST_SPIRIT_ASSERT_MATCH(qi::domain, ParserExpr);

        typename Lexer::iterator_type iter = lex.begin(first, last);
        return compile<qi::domain>(xpr).parse(
            iter, lex.end(), unused, unused, unused);
    }

    ///////////////////////////////////////////////////////////////////////////
    template <typename Iterator, typename Lexer, typename ParserExpr
      , typename Attribute>
    inline bool
    tokenize_and_parse(Iterator& first, Iterator last, Lexer const& lex
      , ParserExpr const& xpr, Attribute& attr)
    {
        // Report invalid expression error as early as possible.
        // If you got an error_invalid_expression error message here,
        // then the expression (expr) is not a valid spirit qi expression.
        BOOST_SPIRIT_ASSERT_MATCH(qi::domain, ParserExpr);

        typename Lexer::iterator_type iter = lex.begin(first, last);
        return compile<qi::domain>(xpr).parse(
            iter, lex.end(), unused, unused, attr);
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    //  The tokenize_and_phrase_parse() function is one of the main Spirit API 
    //  functions. It simplifies using a lexer as the underlying token source
    //  while phrase parsing a given input sequence.
    //
    //  The function takes a pair of iterators spanning the underlying input 
    //  stream to parse, the lexer object (built from the token definitions) 
    //  and a parser object (built from the parser grammar definition). The 
    //  additional skipper parameter will be used as the skip parser during
    //  the parsing process.
    //
    //  The second version of this function additionally takes an attribute to 
    //  be used as the top level data structure instance the parser should use 
    //  to store the recognized input to.
    //
    //  The function returns true if the parsing succeeded (the given input
    //  sequence has been successfully matched by the given grammar).
    //
    //  first, last:    The pair of iterators spanning the underlying input 
    //                  sequence to parse. These iterators must at least 
    //                  conform to the requirements of the std::intput_iterator 
    //                  category.
    //                  On exit the iterator 'first' will be updated to the 
    //                  position right after the last successfully matched 
    //                  token. 
    //  lex:            The lexer object (encoding the token definitions) to be
    //                  used to convert the input sequence into a sequence of 
    //                  tokens. This token sequence is passed to the parsing 
    //                  process. The LexerExpr type must conform to the 
    //                  lexer interface described in the corresponding section
    //                  of the documentation.
    //  xpr:            The grammar object (encoding the parser grammar) to be
    //                  used to match the token sequence generated by the lex 
    //                  object instance. The ParserExpr type must conform to 
    //                  the grammar interface described in the corresponding 
    //                  section of the documentation.
    //  skipper:        The skip parser to be used while parsing the given 
    //                  input sequence. Note, the skip parser will have to 
    //                  act on the same token sequence as the main parser 
    //                  'xpr'.
    //  post_skip:      The post_skip flag controls whether the function will
    //                  invoke an additional post skip after the main parser
    //                  returned.
    //  attr:           The top level attribute passed to the parser. It will 
    //                  be populated during the parsing of the input sequence.
    //                  On exit it will hold the 'parser result' corresponding 
    //                  to the matched input sequence.
    //
    ///////////////////////////////////////////////////////////////////////////
    template <typename Iterator, typename Lexer, typename ParserExpr
      , typename Skipper>
    inline bool
    tokenize_and_phrase_parse(Iterator& first, Iterator last
      , Lexer const& lex, ParserExpr const& xpr, Skipper const& skipper
      , BOOST_SCOPED_ENUM(skip_flag) post_skip = skip_flag::postskip)
    {
        // Report invalid expression error as early as possible.
        // If you got an error_invalid_expression error message here,
        // then the expression (expr) is not a valid spirit qi expression.
        BOOST_SPIRIT_ASSERT_MATCH(qi::domain, ParserExpr);
        BOOST_SPIRIT_ASSERT_MATCH(qi::domain, Skipper);

        typedef
            typename spirit::result_of::compile<qi::domain, Skipper>::type
        skipper_type;
        skipper_type const skipper_ = compile<qi::domain>(skipper);

        typename Lexer::iterator_type iter = lex.begin(first, last);
        typename Lexer::iterator_type end = lex.end();
        if (!compile<qi::domain>(xpr).parse(
                iter, end, unused, skipper_, unused))
            return false;

        // do a final post-skip
        if (post_skip == skip_flag::postskip)
            qi::skip_over(iter, end, skipper_);
        return true;
    }

    template <typename Iterator, typename Lexer, typename ParserExpr
      , typename Skipper, typename Attribute>
    inline bool
    tokenize_and_phrase_parse(Iterator& first, Iterator last
      , Lexer const& lex, ParserExpr const& xpr, Skipper const& skipper
      , BOOST_SCOPED_ENUM(skip_flag) post_skip, Attribute& attr)
    {
        // Report invalid expression error as early as possible.
        // If you got an error_invalid_expression error message here,
        // then the expression (expr) is not a valid spirit qi expression.
        BOOST_SPIRIT_ASSERT_MATCH(qi::domain, ParserExpr);
        BOOST_SPIRIT_ASSERT_MATCH(qi::domain, Skipper);

        typedef
            typename spirit::result_of::compile<qi::domain, Skipper>::type
        skipper_type;
        skipper_type const skipper_ = compile<qi::domain>(skipper);

        typename Lexer::iterator_type iter = lex.begin(first, last);
        typename Lexer::iterator_type end = lex.end();
        if (!compile<qi::domain>(xpr).parse(
                iter, end, unused, skipper_, attr))
            return false;

        // do a final post-skip
        if (post_skip == skip_flag::postskip)
            qi::skip_over(iter, end, skipper_);
        return true;
    }

    ///////////////////////////////////////////////////////////////////////////
    template <typename Iterator, typename Lexer, typename ParserExpr
      , typename Skipper, typename Attribute>
    inline bool
    tokenize_and_phrase_parse(Iterator& first, Iterator last
      , Lexer const& lex, ParserExpr const& xpr, Skipper const& skipper
      , Attribute& attr)
    {
        return tokenize_and_phrase_parse(first, last, lex, xpr, skipper
          , skip_flag::postskip, attr);
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    //  The tokenize() function is one of the main Spirit API functions. It 
    //  simplifies using a lexer to tokenize a given input sequence. It's main
    //  purpose is to use the lexer to tokenize all the input. 
    //
    //  The second version below discards all generated tokens afterwards. 
    //  This is useful whenever all the needed functionality has been 
    //  implemented directly inside the lexer semantic actions, which are being 
    //  executed while the tokens are matched. 
    //
    //  The function takes a pair of iterators spanning the underlying input 
    //  stream to scan, the lexer object (built from the token definitions),
    //  and a (optional) functor being called for each of the generated tokens. 
    //
    //  The function returns true if the scanning of the input succeeded (the 
    //  given input sequence has been successfully matched by the given token
    //  definitions).
    //
    //  first, last:    The pair of iterators spanning the underlying input 
    //                  sequence to parse. These iterators must at least 
    //                  conform to the requirements of the std::intput_iterator 
    //                  category.
    //                  On exit the iterator 'first' will be updated to the 
    //                  position right after the last successfully matched 
    //                  token. 
    //  lex:            The lexer object (encoding the token definitions) to be
    //                  used to convert the input sequence into a sequence of 
    //                  tokens. The LexerExpr type must conform to the 
    //                  lexer interface described in the corresponding section
    //                  of the documentation.
    //  f:              A functor (callable object) taking a single argument of
    //                  the token type and returning a bool, indicating whether
    //                  the tokenization should be canceled.
    //  initial_state:  The name of the state the lexer should start matching.
    //                  The default value is zero, causing the lexer to start 
    //                  in its 'INITIAL' state.
    //
    ///////////////////////////////////////////////////////////////////////////
    namespace detail
    {
        template <typename Token, typename F>
        bool tokenize_callback(Token const& t, F f)
        {
            return f(t);
        }

        template <typename Token, typename Eval>
        bool tokenize_callback(Token const& t, phoenix::actor<Eval> const& f)
        {
            f(t);
            return true;
        }

        template <typename Token>
        bool tokenize_callback(Token const& t, void (*f)(Token const&))
        {
            f(t);
            return true;
        }

        template <typename Token>
        bool tokenize_callback(Token const& t, bool (*f)(Token const&))
        {
            return f(t);
        }
    }

    template <typename Iterator, typename Lexer, typename F>
    inline bool
    tokenize(Iterator& first, Iterator last, Lexer const& lex, F f
      , typename Lexer::char_type const* initial_state = 0)
    {
        typedef typename Lexer::iterator_type iterator_type;

        iterator_type iter = lex.begin(first, last, initial_state);
        iterator_type end = lex.end();
        for (/**/; iter != end && token_is_valid(*iter); ++iter) 
        {
            if (!detail::tokenize_callback(*iter, f))
                return false;
        }
        return (iter == end) ? true : false;
    }

    ///////////////////////////////////////////////////////////////////////////
    template <typename Iterator, typename Lexer>
    inline bool
    tokenize(Iterator& first, Iterator last, Lexer const& lex
      , typename Lexer::char_type const* initial_state = 0)
    {
        typedef typename Lexer::iterator_type iterator_type;

        iterator_type iter = lex.begin(first, last, initial_state);
        iterator_type end = lex.end();

        while (iter != end && token_is_valid(*iter))
            ++iter;

        return (iter == end) ? true : false;
    }

}}}

#endif

/* tokenize_and_parse.hpp
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
*/