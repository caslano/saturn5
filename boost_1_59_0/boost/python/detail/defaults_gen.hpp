///////////////////////////////////////////////////////////////////////////////
//
// Copyright David Abrahams 2002, Joel de Guzman, 2002.
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
///////////////////////////////////////////////////////////////////////////////
#ifndef DEFAULTS_GEN_JDG20020807_HPP
#define DEFAULTS_GEN_JDG20020807_HPP

#include <boost/python/detail/preprocessor.hpp>
#include <boost/preprocessor/repeat.hpp>
#include <boost/preprocessor/repeat_from_to.hpp>
#include <boost/preprocessor/enum.hpp>
#include <boost/preprocessor/enum_params.hpp>
#include <boost/preprocessor/repetition/enum_binary_params.hpp>
#include <boost/preprocessor/tuple.hpp>
#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/arithmetic/sub.hpp>
#include <boost/preprocessor/stringize.hpp>
#include <boost/preprocessor/inc.hpp>
#include <boost/preprocessor/empty.hpp>
#include <boost/preprocessor/comma_if.hpp>
#include <boost/config.hpp>
#include <boost/mpl/begin_end.hpp>
#include <boost/mpl/next.hpp>
#include <boost/mpl/deref.hpp>
#include <cstddef>

namespace boost { namespace python {

namespace detail
{
  // overloads_base is used as a base class for all function
  // stubs. This class holds the doc_string of the stubs.
  struct overloads_base
  {
      overloads_base(char const* doc_)
          : m_doc(doc_) {}

      overloads_base(char const* doc_, detail::keyword_range const& kw)
          : m_doc(doc_), m_keywords(kw) {}

      char const* doc_string() const
      {
          return m_doc;
      }

      detail::keyword_range const& keywords() const
      {
          return m_keywords;
      }

   private:
      char const* m_doc;
      detail::keyword_range m_keywords;
  };

  // overloads_proxy is generated by the overloads_common operator[] (see
  // below). This class holds a user defined call policies of the stubs.
  template <class CallPoliciesT, class OverloadsT>
  struct overloads_proxy
      : public overloads_base
  {
      typedef typename OverloadsT::non_void_return_type   non_void_return_type;
      typedef typename OverloadsT::void_return_type       void_return_type;

      overloads_proxy(
          CallPoliciesT const& policies_
          , char const* doc
          , keyword_range const& kw
          )
          : overloads_base(doc, kw)
            , policies(policies_)
      {}

      CallPoliciesT
      call_policies() const
      {
          return policies;
      }

      CallPoliciesT policies;
  };

  // overloads_common is our default function stubs base class. This
  // class returns the default_call_policies in its call_policies()
  // member function.  It can generate a overloads_proxy however through
  // its operator[]
  template <class DerivedT>
  struct overloads_common
      : public overloads_base
  {
      overloads_common(char const* doc)
          : overloads_base(doc) {}

      overloads_common(char const* doc, keyword_range const& kw)
          : overloads_base(doc, kw) {}

      default_call_policies
      call_policies() const
      {
          return default_call_policies();
      }

      template <class CallPoliciesT>
      overloads_proxy<CallPoliciesT, DerivedT>
      operator[](CallPoliciesT const& policies) const
      {
          return overloads_proxy<CallPoliciesT, DerivedT>(
              policies, this->doc_string(), this->keywords());
      }
  };

}}} // namespace boost::python::detail


#define BOOST_PYTHON_TYPEDEF_GEN(z, index, data)                                \
    typedef typename ::boost::mpl::next<BOOST_PP_CAT(iter, index)>::type        \
        BOOST_PP_CAT(iter, BOOST_PP_INC(index));                                \
    typedef typename ::boost::mpl::deref<BOOST_PP_CAT(iter, index)>::type       \
        BOOST_PP_CAT(T, index);

#define BOOST_PYTHON_FUNC_WRAPPER_GEN(z, index, data)                   \
    static RT BOOST_PP_CAT(func_,                                       \
        BOOST_PP_SUB_D(1, index, BOOST_PP_TUPLE_ELEM(3, 1, data))) (    \
        BOOST_PP_ENUM_BINARY_PARAMS_Z(                                  \
            1, index, T, arg))                                          \
    {                                                                   \
        BOOST_PP_TUPLE_ELEM(3, 2, data)                                 \
        BOOST_PP_TUPLE_ELEM(3, 0, data)(                                \
            BOOST_PP_ENUM_PARAMS(                                       \
                index,                                                  \
                arg));                                                  \
    }

#define BOOST_PYTHON_GEN_FUNCTION(fname, fstubs_name, n_args, n_dflts, ret)     \
    struct fstubs_name                                                          \
    {                                                                           \
        BOOST_STATIC_CONSTANT(int, n_funcs = BOOST_PP_INC(n_dflts));            \
        BOOST_STATIC_CONSTANT(int, max_args = n_funcs);                         \
                                                                                \
        template <typename SigT>                                                \
        struct gen                                                              \
        {                                                                       \
            typedef typename ::boost::mpl::begin<SigT>::type rt_iter;           \
            typedef typename ::boost::mpl::deref<rt_iter>::type RT;             \
            typedef typename ::boost::mpl::next<rt_iter>::type iter0;           \
                                                                                \
            BOOST_PP_REPEAT_2ND(                                                \
                n_args,                                                         \
                BOOST_PYTHON_TYPEDEF_GEN,                                       \
                0)                                                              \
                                                                                \
            BOOST_PP_REPEAT_FROM_TO_2(                                          \
                BOOST_PP_SUB_D(1, n_args, n_dflts),                             \
                BOOST_PP_INC(n_args),                                           \
                BOOST_PYTHON_FUNC_WRAPPER_GEN,                                  \
                (fname, BOOST_PP_SUB_D(1, n_args, n_dflts), ret))               \
        };                                                                      \
    };                                                                          \

///////////////////////////////////////////////////////////////////////////////
#define BOOST_PYTHON_MEM_FUNC_WRAPPER_GEN(z, index, data)                       \
    static RT BOOST_PP_CAT(func_,                                               \
        BOOST_PP_SUB_D(1, index, BOOST_PP_TUPLE_ELEM(3, 1, data))) (            \
            ClassT obj BOOST_PP_COMMA_IF(index)                                 \
            BOOST_PP_ENUM_BINARY_PARAMS_Z(1, index, T, arg)                     \
        )                                                                       \
    {                                                                           \
        BOOST_PP_TUPLE_ELEM(3, 2, data) obj.BOOST_PP_TUPLE_ELEM(3, 0, data)(    \
            BOOST_PP_ENUM_PARAMS(index, arg)                                    \
        );                                                                      \
    }

#define BOOST_PYTHON_GEN_MEM_FUNCTION(fname, fstubs_name, n_args, n_dflts, ret) \
    struct fstubs_name                                                          \
    {                                                                           \
        BOOST_STATIC_CONSTANT(int, n_funcs = BOOST_PP_INC(n_dflts));            \
        BOOST_STATIC_CONSTANT(int, max_args = n_funcs + 1);                     \
                                                                                \
        template <typename SigT>                                                \
        struct gen                                                              \
        {                                                                       \
            typedef typename ::boost::mpl::begin<SigT>::type rt_iter;           \
            typedef typename ::boost::mpl::deref<rt_iter>::type RT;             \
                                                                                \
            typedef typename ::boost::mpl::next<rt_iter>::type class_iter;      \
            typedef typename ::boost::mpl::deref<class_iter>::type ClassT;      \
            typedef typename ::boost::mpl::next<class_iter>::type iter0;        \
                                                                                \
            BOOST_PP_REPEAT_2ND(                                                \
                n_args,                                                         \
                BOOST_PYTHON_TYPEDEF_GEN,                                       \
                0)                                                              \
                                                                                \
            BOOST_PP_REPEAT_FROM_TO_2(                                          \
                BOOST_PP_SUB_D(1, n_args, n_dflts),                             \
                BOOST_PP_INC(n_args),                                           \
                BOOST_PYTHON_MEM_FUNC_WRAPPER_GEN,                              \
                (fname, BOOST_PP_SUB_D(1, n_args, n_dflts), ret))               \
        };                                                                      \
    };

#define BOOST_PYTHON_OVERLOAD_CONSTRUCTORS(fstubs_name, n_args, n_dflts)                    \
    fstubs_name(char const* doc = 0)                                                        \
        : ::boost::python::detail::overloads_common<fstubs_name>(doc) {}                    \
    template <std::size_t N>                                                                \
    fstubs_name(char const* doc, ::boost::python::detail::keywords<N> const& keywords)      \
        : ::boost::python::detail::overloads_common<fstubs_name>(                           \
            doc, keywords.range())                                                          \
    {                                                                                       \
        typedef typename ::boost::python::detail::                                          \
            error::more_keywords_than_function_arguments<                                   \
                N,n_args>::too_many_keywords assertion BOOST_ATTRIBUTE_UNUSED;              \
    }                                                                                       \
    template <std::size_t N>                                                                \
    fstubs_name(::boost::python::detail::keywords<N> const& keywords, char const* doc = 0)  \
        : ::boost::python::detail::overloads_common<fstubs_name>(                           \
            doc, keywords.range())                                                          \
    {                                                                                       \
        typedef typename ::boost::python::detail::                                          \
            error::more_keywords_than_function_arguments<                                   \
                N,n_args>::too_many_keywords assertion BOOST_ATTRIBUTE_UNUSED;              \
    }

# if defined(BOOST_NO_VOID_RETURNS)

#  define BOOST_PYTHON_GEN_FUNCTION_STUB(fname, fstubs_name, n_args, n_dflts)   \
    struct fstubs_name                                                          \
        : public ::boost::python::detail::overloads_common<fstubs_name>         \
    {                                                                           \
        BOOST_PYTHON_GEN_FUNCTION(                                              \
            fname, non_void_return_type, n_args, n_dflts, return)               \
        BOOST_PYTHON_GEN_FUNCTION(                                              \
            fname, void_return_type, n_args, n_dflts, ;)                        \
                                                                                \
        BOOST_PYTHON_OVERLOAD_CONSTRUCTORS(fstubs_name, n_args, n_dflts)        \
    };

#  define BOOST_PYTHON_GEN_MEM_FUNCTION_STUB(fname, fstubs_name, n_args, n_dflts)       \
    struct fstubs_name                                                                  \
        : public ::boost::python::detail::overloads_common<fstubs_name>                 \
    {                                                                                   \
        BOOST_PYTHON_GEN_MEM_FUNCTION(                                                  \
            fname, non_void_return_type, n_args, n_dflts, return)                       \
        BOOST_PYTHON_GEN_MEM_FUNCTION(                                                  \
            fname, void_return_type, n_args, n_dflts, ;)                                \
                                                                                        \
        BOOST_PYTHON_OVERLOAD_CONSTRUCTORS(fstubs_name, n_args + 1, n_dflts)            \
    };

# else // !defined(BOOST_NO_VOID_RETURNS)

#  define BOOST_PYTHON_GEN_FUNCTION_STUB(fname, fstubs_name, n_args, n_dflts)   \
    struct fstubs_name                                                          \
        : public ::boost::python::detail::overloads_common<fstubs_name>         \
    {                                                                           \
        BOOST_PYTHON_GEN_FUNCTION(                                              \
            fname, non_void_return_type, n_args, n_dflts, return)               \
                                                                                \
        typedef non_void_return_type void_return_type;                          \
        BOOST_PYTHON_OVERLOAD_CONSTRUCTORS(fstubs_name, n_args, n_dflts)        \
    };


#  define BOOST_PYTHON_GEN_MEM_FUNCTION_STUB(fname, fstubs_name, n_args, n_dflts)       \
    struct fstubs_name                                                                  \
        : public ::boost::python::detail::overloads_common<fstubs_name>                 \
    {                                                                                   \
        BOOST_PYTHON_GEN_MEM_FUNCTION(                                                  \
            fname, non_void_return_type, n_args, n_dflts, return)                       \
                                                                                        \
        typedef non_void_return_type void_return_type;                                  \
        BOOST_PYTHON_OVERLOAD_CONSTRUCTORS(fstubs_name, n_args + 1, n_dflts)            \
    };

# endif // !defined(BOOST_NO_VOID_RETURNS)

///////////////////////////////////////////////////////////////////////////////
//
//  MAIN MACROS
//
//      Given generator_name, fname, min_args and max_args, These macros
//      generate function stubs that forward to a function or member function
//      named fname. max_args is the arity of the function or member function
//      fname. fname can have default arguments. min_args is the minimum
//      arity that fname can accept.
//
//      There are two versions:
//
//          1. BOOST_PYTHON_FUNCTION_OVERLOADS for free functions
//          2. BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS for member functions.
//
//      For instance, given a function:
//
//      int
//      foo(int a, char b = 1, unsigned c = 2, double d = 3)
//      {
//          return a + b + c + int(d);
//      }
//
//      The macro invocation:
//
//          BOOST_PYTHON_FUNCTION_OVERLOADS(foo_stubs, foo, 1, 4)
//
//      Generates this code:
//
//      struct foo_stubsNonVoid
//      {
//          static const int n_funcs = 4;
//          static const int max_args = n_funcs;
//
//          template <typename SigT>
//          struct gen
//          {
//              typedef typename ::boost::mpl::begin<SigT>::type    rt_iter;
//              typedef typename rt_iter::type                      RT;
//              typedef typename rt_iter::next                      iter0;
//              typedef typename iter0::type                        T0;
//              typedef typename iter0::next                        iter1;
//              typedef typename iter1::type                        T1;
//              typedef typename iter1::next                        iter2;
//              typedef typename iter2::type                        T2;
//              typedef typename iter2::next                        iter3;
//              typedef typename iter3::type                        T3;
//              typedef typename iter3::next                        iter4;
//
//              static RT func_0(T0 arg0)
//              { return foo(arg0); }
//
//              static RT func_1(T0 arg0, T1 arg1)
//              { return foo(arg0, arg1); }
//
//              static RT func_2(T0 arg0, T1 arg1, T2 arg2)
//              { return foo(arg0, arg1, arg2); }
//
//              static RT func_3(T0 arg0, T1 arg1, T2 arg2, T3 arg3)
//              { return foo(arg0, arg1, arg2, arg3); }
//          };
//      };
//
//      struct foo_overloads
//          : public boost::python::detail::overloads_common<foo_overloads>
//      {
//          typedef foo_overloadsNonVoid    non_void_return_type;
//          typedef foo_overloadsNonVoid    void_return_type;
//
//          foo_overloads(char const* doc = 0)
//             : boost::python::detail::overloads_common<foo_overloads>(doc) {}
//      };
//
//      The typedefs non_void_return_type and void_return_type are
//      used to handle compilers that do not support void returns. The
//      example above typedefs non_void_return_type and
//      void_return_type to foo_overloadsNonVoid. On compilers that do
//      not support void returns, there are two versions:
//      foo_overloadsNonVoid and foo_overloadsVoid.  The "Void"
//      version is almost identical to the "NonVoid" version except
//      for the return type (void) and the lack of the return keyword.
//
//      See the overloads_common above for a description of the
//      foo_overloads' base class.
//
///////////////////////////////////////////////////////////////////////////////
#define BOOST_PYTHON_FUNCTION_OVERLOADS(generator_name, fname, min_args, max_args)          \
    BOOST_PYTHON_GEN_FUNCTION_STUB(                                                         \
        fname,                                                                              \
        generator_name,                                                                     \
        max_args,                                                                           \
        BOOST_PP_SUB_D(1, max_args, min_args))

#define BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(generator_name, fname, min_args, max_args)   \
    BOOST_PYTHON_GEN_MEM_FUNCTION_STUB(                                                     \
        fname,                                                                              \
        generator_name,                                                                     \
        max_args,                                                                           \
        BOOST_PP_SUB_D(1, max_args, min_args))

// deprecated macro names (to be removed)
#define BOOST_PYTHON_FUNCTION_GENERATOR BOOST_PYTHON_FUNCTION_OVERLOADS
#define BOOST_PYTHON_MEM_FUN_GENERATOR BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS

///////////////////////////////////////////////////////////////////////////////
#endif // DEFAULTS_GEN_JDG20020807_HPP



/* defaults_gen.hpp
HpafL1BtXDj4C2lfI6OCura+YmbVM2Fd4IcmT/lALgH5MladwlTdhN5cePSVsDXVEOcKamzWsLDjj0Od2ImhGy/EG7+fdQbtgPkLextZy2kJGg+b+3d3mfp2937q9jY8U6O/zntOifVFm79fsufvq6p3rZS8kX4uyqaH8SyyO2/Gw930UCezJ7arov8FLS28GdzIa24jztynqVrZnXj2nvUC1p1PdsUP0xc96ZuPgtdf+97veWJ4cV7bK63vS9OKyclr32s1GyyelxBX1s80/6vv02/mJjlWbX7vtbMb/FbHu/tRr8eNfOnXrH6VdKZcmgscr2ebY/zB863/9m/reeOxDV/De9WYPN/HJPgN8uJO9Jynn97PZi6rqDsfD/OTu7M3F96Mv9PsciRwdp6vn+QpLXln3qz25/7K9toWn2zWLyalj+tln+/5z0xj/9riE3bs3olM7i47g/3FK7gzGlpKHfXHcwe412/n6jXZG8da9p4uQ59Vzd1B4Vc6Cp/lmdQe1wVd90Pq+x45VHDmnK6v3b/V9/XSvRnKm82H5DTSeF7cmc+9qcnebu+PR/m/bo+mN/TX1C4e++dbXb2Nx+8+3Fk9rB/PMfe0e1xNedINeXyiCmk8Gji9v+qTzS9+PK1fzKaC5a+tdevVytE6NffvkvuaXv4VuouENbIO/y2+C6O+33Mp601qewnPPkib79Svkr+cVmeGD3Rlf0RKn9351y9z/I7SqiKHs90B/eJTWyPZNO0tKv/nqn5ic74ba1f7Bq6z74PkX1/6n5f0ipbQO+82bdw7el6jl+4W69sZXH5v50d9NotOqKr4ic5cZXUSfr7HW5suBmdRzC6TKxonK7S/qy6BGyeqSxRUmnJ99tMyjo77HYmnNZ/xZQZh3X8bAj022DwHG4qHaUvnXyyTsXj92Q7hoe6rIeoPLH81Bd5YhrDQnLCjPWEH2mwnKPlORyBvejwu5oVKOxOS21+UIdtlGshBXB0QDvu4+SMCuHnh5J+/5Lc/800zWyxNS3bKj9/SM/2DECc5Nqi8yU1LO/EvLqEvWSsuZSWABA7FuI8uODsy6pXzizCZXzwvdst9Yfj+Bqmge1D51/fTQlP+9nrPb1fY79v3VN+LJLsbnQ13ngedRA4bL9bhB4RBq3X6WHr5HuJt8XXGn7yositDHE6hYVoOMz4aliW27xlV32EBvdQD4UDzb0QQaaiyBzmfXJ9ToJtpLZd2hrLGhbTWGH/rbljiDn81mbX+M29OkJ1rEChbjgIjWZ0ORTuc8CK8j8mkrbWdhXaq7YtyC0dzmliVa9WNwiLWYHtbFvZ5/PSywtYY3ahmazQlbUQoNZXK/o1qZVLuIvEWulkVG+9fUX/87l+OdKb0cgBSWec/g/43+elWUU7ONYmr1n9Pzj9LTfnSs6my1hP3DGF/XzEne9k1CbtN1sXcKdbnuM2l/8na15B+0ylwemr9f/ZmJcFm/rZ0PFHYGkoX3B38zvOF2w0HPtjJzvi1ujpOM9VPeRKhvXJqIOd5g2q1YZvopdmn/VB68wPmzt+oF8d65wLtx0MZc0GijbSXt+UnXsRM6wCOkAdjr4JRW4Q0AJeOhbcn9J3NjUWPPhO7nVRFbTVkC8VflhBDgfYIAoI7lDV4cyiP6mpTp905zEe7Uw6dhVtv9ZbWh6sA3vUA4IgA4Vko9cRLeASJ5eBlUcCbG1wHtT65HqtpBHzLpDsx8j9ri7+J7/wkDpD3i/YohabvUp+VB+I59Qr+EW5jSB2fduyfqD28EH9PImJh/2vG3NJD0dPe80Gs/gM3VMVSbbTY7S3FPAUyV28BMx2AP3sq2hpbpUJ/GQCxskUKOmb/BiaO/u74FY3PRM9Ww5v2dlsZcvZXPvGGe5vNuq3VRbWD4rbPW1PwPPNfOgOFvGNIopytPTf8Zcp0z4gqfnE/Z0nkzGrEFZMd8xJLm8Hya4ynYZNoenTJskC3d3AzfeXo8pJgP6BJDMXKI8QTdmHn17OrR5M0kyu7gAyTqBoSkevaxNyl6KGcalyfTUm/Yej3KZMEFNJXLIrsiM1pBuQiVgWTLZ4spryqkKS72AhTfl2WobmIvE4KV0wEVkIPQGpb6NhamdEe4SF2xB7mAXbMHuZJ1jBAgYYxCoycRdK0X75fkqgdAniWI4uO3elhM09DZEYy80tDJMjRFZCs7qciiwwYsUUBjM5G3EG7gMsgVUtQWj0bunDCJZOPTnWiRLFeSPpxahiqPMOV+XePKjNiAXRMYoh5yJqZv4VKZCv24ykPjRzDaqG8JXMcgFOPAqGfnpoORCJ3bndidJuKw5CViLdduxZxi0pC+ZgFee8UneDEz0TRPug5/WImkRHqUM+XZAleOrJZQ9jhWZKfbIPtguXE4lX9X+LROs4m+T0FyRmTY3pSbSfCjzkoHkOulyn2DVXLIGBvA6KO1004eWRabOIhRJJmddKd7BBYs4lROQkW4cmSEGyI0XFKl9hAp9AvDn3m1u28AIKKW1Lwa+OiyGvFd2/misEADlExwWV0aqS/YYPZH3TpJ/Z9yw06vrpDISnb7/L3iQ27TgcxYL/ESXLGH02wSGeAh0heBYSJUAykKl5skKIvj8hTREh9+SHn8RDhuq+tfVa4Tm2W8yDxJFgyAvo8OJXAk+DMP9Y0YCWBD7mN7Fjq0DCMesaPGM4FmlOzhOY5qlYfavOh5tt5x32sBAe5Ab6AEEtojCThjp+wCz/HRdJMZqBV2k+oejHwbuyXiM5bU46j116F8mIE8ZrN4nhQuzAXpppzv2M4oDqSJKdfm07jCz9t6neizcdJ4fNVr9MUcyOSl2wYknBdPr+ezJjWxwUi1O5Hw9BHhKiXEyttJivaiLgBUxBNLuS2Mx6PvO5MC6pz0ODo2BB4lZorZIMXO1mdsGDgLP19IMFPqUczI394bDyBOsvtGgHK1jBAh8bZSuBasEWFPo0CtTQaAGrUdymT4OUwMNeEBwgXANiiVAk7xih0QmSenPqsvseBUY3Xr86UlVs7t1o0fvtH0+6R9AKlcY8HlZWH8fHRppJ0v/x1AxFHfA/jZxYuilw86av1aRFR61G6bQM4Kau0g1gT5nbClYFFK8UGySpyupiAHrXV/zvuioXxE8LkxebI3I/jrFpMqnwau45/+Jl8wR5DxyDlqvyc5bQ85Pucj69hAZOgBQ6MIZ9cHKB/ukiJHy3ILoFmgHwq0gs6RnD+89OJlftMM60Si4WfYPfZpIfsOaOhpxZ1DUph6LOdCx+U8BVr0qhjIlS5g3bYkDBBgt28FFxIocu3CSVGzRxgxnRePGJy+Kqwp05zGnjivA8YyZ3/OYzEOIc0BWwK9vSZkyV35YKDHKmtaLC4JaWdJLOQDs+Nu19BRJBkKpCvYUCi6eYQPUtnUgKK037eGmln4bRMQusfKUVvgRpMWehdey6HvAM9bNB5rkfSySzqbldMoC92psj8AKeBpoGPkavRKgRTixKcujLGW64FW5iNvkNrJNiioaZdhLxTE/UDRx2z/AorFpfmpMCRSom0+VHf8X1zY+i8UTZJLRBbMOw5+eIlkQGVslXOILRon180eF4VkAD52CzWuwSVmSiY6wALlFicUMgLxqL7lHb24M5S9hkH6GCiQP0uTqj1jyir8HWm4KiM4ig6ZnmjNrghfsFvB4Po+nL9TSGnA066GZo7dMLlE2CWPz2uD/X+wHoB6DMLyZJ+IfmH0PlMuF2dSvVf8iAcM0zxEIXOluJZRZz9wk9WEdFsAg6Qs8K2PTVlfcfufhlS284LFz9hvyQ/9aLlMFeXhjnyFU6xQe1idukr28IuS4NdrUZbAAqNU4/hrU8wlWEp1EERQqbRDlEDXdvd3Dp7iRh2QvRiTtm44trX6XpdQc0dnQvPTVqcd6rKIZZDPyYlQgo0LMMBCFIjmuOid4Lm8BNFgIY60epJtGteexcG7Ym3Sd/Zl7lJ32FXhs21bMJ3uT3KhBFuuuLYvbo/vPiUBY5BPAaZLMY5Mbnyt+BZQ4xSBGBZaNX84Gme8mHCUQ5Sus39zhv4ZBlqoiAvPx5LP45vBBsGsS6Cfbd4SeVUM9YgVhcpsu+OP9oTFkg6KDLs8wXhABRhDnDBRj8yLLpxvJOSfJPckn3tggG8bbu6gpH31nMcG2Qmunk81kDQRzbCDZTAVn7h8JefRy/EaATDBQcrdF64MnFy4qf2eFvxqPOy/HREM/qUENInBgKE283Yn1QZXfmBFiC4PApmimdYcpxOwRFZ0cubPEhZtegdVFTsfAaFxYBQqGPCViAyCHplKucShN59BOtmexfIXHgJdngKZ8r81bVT3kzAPTW02JOx7nH3OJzkTvhLljWolfPU5hnAF4Fao/AxgH35QhB7GmcFPhAkZkSeLetkNSLJ2ifeC1kXavM5TTcDhSs6vz+j/4sRoS4aTaSAUYhpMYB7wcW2Yq3/ZDndOLU2fbB7AWhSEmpGp0FUmz1+uyKxiB3wxau79OcMG9mj4aPZw/5M1gby7o6JcdrbNfaXPYgfhgKux+v8tHRM/3HM4J0QxRDEZ+YOu0s+LxewkvP41BNu2LhUtNgzxnxNNB6xHLGXDMbjERaKP49yA1t8ahLvN7xwbmJ9FoKmPbM9bff2yo6LZsf5is2QUBHKt43qsZ6Y8a0Pot6/vcNLNvG8EW4EQSYETkfvYyGzpRYTdM71nw4/5wehLwjPcDS8wzsncyCBI/AdJSTKuK2icOMPxy4H1gfMwvDQip/PdSPYB0zinVEZD/nSmW/0nR5Jk/Qnm2vIT3IFA8dwpHbvZHb74nZ4Op5x/ZPZwvapyVxdCfPMcavJ8Ao67CYw1GOkq9AXFn2nHn+VVehvhr037G9uhEkv7Rv+9nVV0LzzjdbdBuvc0uoXp0PsmGdMXuN0zIvO3OvPuq2/DSpb0GjEC3/jxAEsUmku3eCNONFP7hlXW0TuZbw0D6RLILB5kd7gz5OyCWThXcIzInxS+1/3nJ4vaN5hriRTZDU7vUSTeJcN8u62iTQQ2AQpRqwBLdJWjYg5NdJdZ05Nm6qkJgzSChb7Ezp33yUWzM++NUNH3yWbAmBx9/L3Oby8zAzBV4aAzQ3V1MQZiOSpqmEbHEU1UjPdOODxHYJOgmkimWhBpnHJtkGsKoU1wOZ9J9dWgmkynX8AJLoKgAV7hdNQodEHo5JhsYOpy8Mpg6bYYrMHXuxTYkw1y/hvBWtGetehY8u6xdhdeinJB6AwdyX/j4J7Bg+G0cEAWtu2bdu227+2bdu2bdu2bdu2v+L2DmfKlDwZ3iyBniinIpOnSrdwyxvoXul3kQ5dtp2+KCACpcTICbMAsvTVFy+mxj/c8+5TA2YRcAqdG5WvGBTda1VkPrJ3dZ3vfsE/rQFX3qMj1ohdxs3IQP8AzoPcVIySzR98Xcb9tNNWKoqVWFBWfaDJElviQd8OmcBXuRnzaI1stCJ3Tw9pdR44DjVbu1I93GkdjZtK/U90dcv5pOQqMXkAklyyh054NqgORqqNqiQMVVOAZDgH1pa9kTkPZz9wsQ7OnLCEJsS+YrGsHClY+mLWqllhsUWO+NbZWaoAy8aYHBmF+1Zcnv8NtybRhTiMKDG0b3sIm2fc+TkOg4jnuUFepiQiCRCnbcpGG7zxQu8SfqLNPvGrGI91RyzW9e2yXb2LkqTni8RUC430jj2xp6Krk3/5I5zT9Lw84NrxiY9iObHgc3SyD2ay+vGEpXBBCYOi90RanXJTDhBqJvI0KC9/mPWCxfIGfxjCXjMTIj+BzZSIXxitGoJe3bIeA2QVpKTIymGv2CVxUbUIUkpeqBdYWykSG6fvDZorJeS1KkkjaBH/To1scJj9dcTcsh5GP3ARlweIZBLXUZPw27/5AFqGEkPJvOAlIMRchNZ7ZGf5KuhhqRv/jc671SYTEMGcTRgomoFYAstGkV2ZTCaUFAXwo57vIjIES4JHjJUnK5YvVNE1LnnwmcdEVsETqhwGLCA4g05TJz0ZFwnaGDxfPB/ybOCE1ACG1UFw2g2OYFBM5gWJflEIVpVIjHmzdr64P9uwQ5PbMnDVSKBM9KopjWI6S3D+Whg/h1Vm4RFoQzIzIxa5vdnJL8+BzXi3Mzwim0HMFesZeEcPi+1s1/LuOrJl11LPr+Nol+ppD2w/qeyGz2AZ/hn7Hhdnmq35eBmPYZ8m3ZsJg3E6b1NnxQFQlrlR2Gy3c6z75eZx+ZbpG25b8qOA0aRiZ0r1aqxxg1LYwTSGfEPwqcAVfSvGsCti9T+0i8EYlT7MBp+E9VzK1rPRnYvmZcu38JsPQ27yVnRhStXad+tO/ni8tcWY4DH5RZTkSgHtqFidwwLIGhnPfxo9pTDZ6mKpiukS3mqN6Q60jGwXCy0xD+S45OwHt+Q1hYn+SmeUdKl346ge4qXqV/URNbEd9w7DTrgWydVqY0DvxUNmCckxzegMxpF1EKPLUhpRhDM+ww8oYM04sdYOPEHQswgGHiRlx6LdTEeXZJwfgy617QyACpsMri+/619LGfE/CwJg9WiM+KczLsXPvxD9ZIDpIa8CVr8wTtfZtiDJgYT+1dY7GuNg8tUTlfjBruLXBpn8MgOVkyCw1BFbYpUZsfIVsd38RyjYKTNalQApVSsNizhaAS6FQswZ1579DyCmAIhfQzjFSw+Boa4/kFUqehQQUyclY92a1l4g1Oqy1euKOiQt9IJ5ZrG+0hrxh47Mp7PgKWb5V6TJyVbgfrTqpiQ6Q/KKrmIzJOGsC7MhXLAhCEHtYwOCtTC+ULmRFYxn3JEjhuBnPDRyZNLoHa/3/yVkywiM9s/XdCjInczzS4J//4gW8qOP0vrvVulrd6YnQdZZGM4SOVjQEWgA5LG8FwtXEW++EJ2cLho6BIXlIfKOYDdT1MtNQmoAX5cEFPNr2ATeN4ajMKomeDmaMNwYzuvwg+tRxq8sByVff/83WNw67lHTL9q1CezfX1vyEn+jTRY0zS5+ZlmxupXw37oknoKCXYH2XLp+rIxCpSu0yo1x3z6xJJPZDX109hpkeiR/Tj4pPlp9Vl+2EuyBT7D2ecP5HPlmBCM1VZSYkzUTCZDPufc4Ssd4qEtgxxNjCZueiCYM3e7Ag+sx5+QZlEAi9Dn54KWU/0wsTDkyIBDZbwuY1XfEFw0B5i9JPrwAbz6whSiCuVC8M4rTYsEKC4y6eJCC6AOKJP/cIN+8lNUVjbohzLSshOukz+5dOZFZYKBJ4BhJUIgPdEPFqoHLZAMt3DZZwv1cSH7oF/pKWU79sYzmgU5QsFkxtXMXHMySTlbtYs6dhBMuwH2H+WS+WzmxAx/nsKRQK5w2g0ePs8eY1TmC6/rKJzsSXmA+q94znOHHuAFLKACHVLLzHuEEvhC8XYxrgtKS63T6exZjgD641egULNjIr5bFw78ZAlNkhakWoRavUBoTCLObn3mWq5wIr3wORcIJJewHjU6vho/886b8C0c0ALzQ5vgTNhh36RoIF33DtnQjWj2+1mNaZcvd7bn6U9zNnPILZsY9Xvo9rCdXybddAC44+Z5E+6G31NYIOlkdjLyAByrI1abZeHXZNBY3hZ10CwUAm2EvnG2bMfFx4HyYiv/QTf7xwWGHMUufqeA4IVe9wQ1c
*/