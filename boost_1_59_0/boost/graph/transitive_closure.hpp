// Copyright (C) 2001 Vladimir Prus <ghost@cs.msu.su>
// Copyright (C) 2001 Jeremy Siek <jsiek@cs.indiana.edu>
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// NOTE: this final is generated by libs/graph/doc/transitive_closure.w

#ifndef BOOST_GRAPH_TRANSITIVE_CLOSURE_HPP
#define BOOST_GRAPH_TRANSITIVE_CLOSURE_HPP

#include <vector>
#include <algorithm> // for std::min and std::max
#include <functional>
#include <boost/config.hpp>
#include <boost/bind/bind.hpp>
#include <boost/graph/strong_components.hpp>
#include <boost/graph/topological_sort.hpp>
#include <boost/graph/graph_concepts.hpp>
#include <boost/graph/named_function_params.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/concept/assert.hpp>

namespace boost
{

namespace detail
{
    inline void union_successor_sets(const std::vector< std::size_t >& s1,
        const std::vector< std::size_t >& s2, std::vector< std::size_t >& s3)
    {
        BOOST_USING_STD_MIN();
        for (std::size_t k = 0; k < s1.size(); ++k)
            s3[k] = min BOOST_PREVENT_MACRO_SUBSTITUTION(s1[k], s2[k]);
    }
} // namespace detail

namespace detail
{
    template < typename TheContainer, typename ST = std::size_t,
        typename VT = typename TheContainer::value_type >
    struct subscript_t
    {
        typedef ST argument_type;
        typedef VT& result_type;

        subscript_t(TheContainer& c) : container(&c) {}
        VT& operator()(const ST& i) const { return (*container)[i]; }

    protected:
        TheContainer* container;
    };
    template < typename TheContainer >
    subscript_t< TheContainer > subscript(TheContainer& c)
    {
        return subscript_t< TheContainer >(c);
    }
} // namespace detail

template < typename Graph, typename GraphTC, typename G_to_TC_VertexMap,
    typename VertexIndexMap >
void transitive_closure(const Graph& g, GraphTC& tc,
    G_to_TC_VertexMap g_to_tc_map, VertexIndexMap index_map)
{
    if (num_vertices(g) == 0)
        return;
    typedef typename graph_traits< Graph >::vertex_descriptor vertex;
    typedef typename graph_traits< Graph >::vertex_iterator vertex_iterator;
    typedef typename property_traits< VertexIndexMap >::value_type size_type;
    typedef
        typename graph_traits< Graph >::adjacency_iterator adjacency_iterator;

    BOOST_CONCEPT_ASSERT((VertexListGraphConcept< Graph >));
    BOOST_CONCEPT_ASSERT((AdjacencyGraphConcept< Graph >));
    BOOST_CONCEPT_ASSERT((VertexMutableGraphConcept< GraphTC >));
    BOOST_CONCEPT_ASSERT((EdgeMutableGraphConcept< GraphTC >));
    BOOST_CONCEPT_ASSERT(
        (ReadablePropertyMapConcept< VertexIndexMap, vertex >));

    typedef size_type cg_vertex;
    std::vector< cg_vertex > component_number_vec(num_vertices(g));
    iterator_property_map< cg_vertex*, VertexIndexMap, cg_vertex, cg_vertex& >
        component_number(&component_number_vec[0], index_map);

    int num_scc
        = strong_components(g, component_number, vertex_index_map(index_map));

    std::vector< std::vector< vertex > > components;
    build_component_lists(g, num_scc, component_number, components);

    typedef boost::adjacency_list< boost::vecS, boost::vecS, boost::directedS >
        CG_t;
    CG_t CG(num_scc);
    for (cg_vertex s = 0; s < components.size(); ++s)
    {
        std::vector< cg_vertex > adj;
        for (size_type i = 0; i < components[s].size(); ++i)
        {
            vertex u = components[s][i];
            adjacency_iterator v, v_end;
            for (boost::tie(v, v_end) = adjacent_vertices(u, g); v != v_end;
                 ++v)
            {
                cg_vertex t = component_number[*v];
                if (s != t) // Avoid loops in the condensation graph
                    adj.push_back(t);
            }
        }
        std::sort(adj.begin(), adj.end());
        typename std::vector< cg_vertex >::iterator di
            = std::unique(adj.begin(), adj.end());
        if (di != adj.end())
            adj.erase(di, adj.end());
        for (typename std::vector< cg_vertex >::const_iterator i = adj.begin();
             i != adj.end(); ++i)
        {
            add_edge(s, *i, CG);
        }
    }

    std::vector< cg_vertex > topo_order;
    std::vector< cg_vertex > topo_number(num_vertices(CG));
    topological_sort(CG, std::back_inserter(topo_order),
        vertex_index_map(identity_property_map()));
    std::reverse(topo_order.begin(), topo_order.end());
    size_type n = 0;
    for (typename std::vector< cg_vertex >::iterator iter = topo_order.begin();
         iter != topo_order.end(); ++iter)
        topo_number[*iter] = n++;

    std::vector< std::vector< cg_vertex > > CG_vec(num_vertices(CG));
    for (size_type i = 0; i < num_vertices(CG); ++i)
    {
        using namespace boost::placeholders;

        typedef typename boost::graph_traits< CG_t >::adjacency_iterator
            cg_adj_iter;
        std::pair< cg_adj_iter, cg_adj_iter > pr = adjacent_vertices(i, CG);
        CG_vec[i].assign(pr.first, pr.second);
        std::sort(CG_vec[i].begin(), CG_vec[i].end(),
            boost::bind(std::less< cg_vertex >(),
                boost::bind(detail::subscript(topo_number), _1),
                boost::bind(detail::subscript(topo_number), _2)));
    }

    std::vector< std::vector< cg_vertex > > chains;
    {
        std::vector< cg_vertex > in_a_chain(CG_vec.size());
        for (typename std::vector< cg_vertex >::iterator i = topo_order.begin();
             i != topo_order.end(); ++i)
        {
            cg_vertex v = *i;
            if (!in_a_chain[v])
            {
                chains.resize(chains.size() + 1);
                std::vector< cg_vertex >& chain = chains.back();
                for (;;)
                {
                    chain.push_back(v);
                    in_a_chain[v] = true;

                    typename std::vector< cg_vertex >::const_iterator next
                    #ifdef __cpp_lib_not_fn
                        = std::find_if(CG_vec[v].begin(), CG_vec[v].end(),
                                       std::not_fn(detail::subscript(in_a_chain)));
                    #else
                        = std::find_if(CG_vec[v].begin(), CG_vec[v].end(),
                                       std::not1(detail::subscript(in_a_chain)));
                    #endif

                    if (next != CG_vec[v].end())
                        v = *next;
                    else
                        break; // end of chain, dead-end
                }
            }
        }
    }
    std::vector< size_type > chain_number(CG_vec.size());
    std::vector< size_type > pos_in_chain(CG_vec.size());
    for (size_type i = 0; i < chains.size(); ++i)
        for (size_type j = 0; j < chains[i].size(); ++j)
        {
            cg_vertex v = chains[i][j];
            chain_number[v] = i;
            pos_in_chain[v] = j;
        }

    cg_vertex inf = (std::numeric_limits< cg_vertex >::max)();
    std::vector< std::vector< cg_vertex > > successors(
        CG_vec.size(), std::vector< cg_vertex >(chains.size(), inf));
    for (typename std::vector< cg_vertex >::reverse_iterator i
         = topo_order.rbegin();
         i != topo_order.rend(); ++i)
    {
        cg_vertex u = *i;
        typename std::vector< cg_vertex >::const_iterator adj, adj_last;
        for (adj = CG_vec[u].begin(), adj_last = CG_vec[u].end();
             adj != adj_last; ++adj)
        {
            cg_vertex v = *adj;
            if (topo_number[v] < successors[u][chain_number[v]])
            {
                // Succ(u) = Succ(u) U Succ(v)
                detail::union_successor_sets(
                    successors[u], successors[v], successors[u]);
                // Succ(u) = Succ(u) U {v}
                successors[u][chain_number[v]] = topo_number[v];
            }
        }
    }

    for (size_type i = 0; i < CG_vec.size(); ++i)
        CG_vec[i].clear();
    for (size_type i = 0; i < CG_vec.size(); ++i)
        for (size_type j = 0; j < chains.size(); ++j)
        {
            size_type topo_num = successors[i][j];
            if (topo_num < inf)
            {
                cg_vertex v = topo_order[topo_num];
                for (size_type k = pos_in_chain[v]; k < chains[j].size(); ++k)
                    CG_vec[i].push_back(chains[j][k]);
            }
        }

    // Add vertices to the transitive closure graph
    {
        vertex_iterator i, i_end;
        for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i)
            g_to_tc_map[*i] = add_vertex(tc);
    }
    // Add edges between all the vertices in two adjacent SCCs
    typename std::vector< std::vector< cg_vertex > >::const_iterator si, si_end;
    for (si = CG_vec.begin(), si_end = CG_vec.end(); si != si_end; ++si)
    {
        cg_vertex s = si - CG_vec.begin();
        typename std::vector< cg_vertex >::const_iterator i, i_end;
        for (i = CG_vec[s].begin(), i_end = CG_vec[s].end(); i != i_end; ++i)
        {
            cg_vertex t = *i;
            for (size_type k = 0; k < components[s].size(); ++k)
                for (size_type l = 0; l < components[t].size(); ++l)
                    add_edge(g_to_tc_map[components[s][k]],
                        g_to_tc_map[components[t][l]], tc);
        }
    }
    // Add edges connecting all vertices in a SCC
    for (size_type i = 0; i < components.size(); ++i)
        if (components[i].size() > 1)
            for (size_type k = 0; k < components[i].size(); ++k)
                for (size_type l = 0; l < components[i].size(); ++l)
                {
                    vertex u = components[i][k], v = components[i][l];
                    add_edge(g_to_tc_map[u], g_to_tc_map[v], tc);
                }

    // Find loopbacks in the original graph.
    // Need to add it to transitive closure.
    {
        vertex_iterator i, i_end;
        for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i)
        {
            adjacency_iterator ab, ae;
            for (boost::tie(ab, ae) = adjacent_vertices(*i, g); ab != ae; ++ab)
            {
                if (*ab == *i)
                    if (components[component_number[*i]].size() == 1)
                        add_edge(g_to_tc_map[*i], g_to_tc_map[*i], tc);
            }
        }
    }
}

template < typename Graph, typename GraphTC >
void transitive_closure(const Graph& g, GraphTC& tc)
{
    if (num_vertices(g) == 0)
        return;
    typedef typename property_map< Graph, vertex_index_t >::const_type
        VertexIndexMap;
    VertexIndexMap index_map = get(vertex_index, g);

    typedef typename graph_traits< GraphTC >::vertex_descriptor tc_vertex;
    std::vector< tc_vertex > to_tc_vec(num_vertices(g));
    iterator_property_map< tc_vertex*, VertexIndexMap, tc_vertex, tc_vertex& >
        g_to_tc_map(&to_tc_vec[0], index_map);

    transitive_closure(g, tc, g_to_tc_map, index_map);
}

namespace detail
{
    template < typename Graph, typename GraphTC, typename G_to_TC_VertexMap,
        typename VertexIndexMap >
    void transitive_closure_dispatch(const Graph& g, GraphTC& tc,
        G_to_TC_VertexMap g_to_tc_map, VertexIndexMap index_map)
    {
        typedef typename graph_traits< GraphTC >::vertex_descriptor tc_vertex;
        typename std::vector< tc_vertex >::size_type n
            = is_default_param(g_to_tc_map) ? num_vertices(g) : 1;
        std::vector< tc_vertex > to_tc_vec(n);

        transitive_closure(g, tc,
            choose_param(g_to_tc_map,
                make_iterator_property_map(
                    to_tc_vec.begin(), index_map, to_tc_vec[0])),
            index_map);
    }
} // namespace detail

template < typename Graph, typename GraphTC, typename P, typename T,
    typename R >
void transitive_closure(
    const Graph& g, GraphTC& tc, const bgl_named_params< P, T, R >& params)
{
    if (num_vertices(g) == 0)
        return;
    detail::transitive_closure_dispatch(g, tc,
        get_param(params, orig_to_copy_t()),
        choose_const_pmap(get_param(params, vertex_index), g, vertex_index));
}

template < typename G > void warshall_transitive_closure(G& g)
{
    typedef typename graph_traits< G >::vertex_iterator vertex_iterator;

    BOOST_CONCEPT_ASSERT((AdjacencyMatrixConcept< G >));
    BOOST_CONCEPT_ASSERT((EdgeMutableGraphConcept< G >));

    // Matrix form:
    // for k
    //  for i
    //    if A[i,k]
    //      for j
    //        A[i,j] = A[i,j] | A[k,j]
    vertex_iterator ki, ke, ii, ie, ji, je;
    for (boost::tie(ki, ke) = vertices(g); ki != ke; ++ki)
        for (boost::tie(ii, ie) = vertices(g); ii != ie; ++ii)
            if (edge(*ii, *ki, g).second)
                for (boost::tie(ji, je) = vertices(g); ji != je; ++ji)
                    if (!edge(*ii, *ji, g).second && edge(*ki, *ji, g).second)
                    {
                        add_edge(*ii, *ji, g);
                    }
}

template < typename G > void warren_transitive_closure(G& g)
{
    using namespace boost;
    typedef typename graph_traits< G >::vertex_iterator vertex_iterator;

    BOOST_CONCEPT_ASSERT((AdjacencyMatrixConcept< G >));
    BOOST_CONCEPT_ASSERT((EdgeMutableGraphConcept< G >));

    // Make sure second loop will work
    if (num_vertices(g) == 0)
        return;

    // for i = 2 to n
    //    for k = 1 to i - 1
    //      if A[i,k]
    //        for j = 1 to n
    //          A[i,j] = A[i,j] | A[k,j]

    vertex_iterator ic, ie, jc, je, kc, ke;
    for (boost::tie(ic, ie) = vertices(g), ++ic; ic != ie; ++ic)
        for (boost::tie(kc, ke) = vertices(g); *kc != *ic; ++kc)
            if (edge(*ic, *kc, g).second)
                for (boost::tie(jc, je) = vertices(g); jc != je; ++jc)
                    if (!edge(*ic, *jc, g).second && edge(*kc, *jc, g).second)
                    {
                        add_edge(*ic, *jc, g);
                    }
    //  for i = 1 to n - 1
    //    for k = i + 1 to n
    //      if A[i,k]
    //        for j = 1 to n
    //          A[i,j] = A[i,j] | A[k,j]

    for (boost::tie(ic, ie) = vertices(g), --ie; ic != ie; ++ic)
        for (kc = ic, ke = ie, ++kc; kc != ke; ++kc)
            if (edge(*ic, *kc, g).second)
                for (boost::tie(jc, je) = vertices(g); jc != je; ++jc)
                    if (!edge(*ic, *jc, g).second && edge(*kc, *jc, g).second)
                    {
                        add_edge(*ic, *jc, g);
                    }
}

} // namespace boost

#endif // BOOST_GRAPH_TRANSITIVE_CLOSURE_HPP

/* transitive_closure.hpp
cKwwhTS/EyZcuFtyVX2EFQOSFkOKnlHAZ0whJ8wNwjrtfR6jZAEtdQGOZQFBRh7Zeh7ffpxfD1YYClZgeJq/hzvCZB0koRGNqwEDYJSpjMOCZCw4gPLZlPEM87wJ686XajXxv8ob2gSVmnjrBJ2a5AtSaUdx2XZdRwnbdsF78bbDZFyy3MNUUMU4FS+DdomIsWlFZdt4Q8fKX6mojplJSYqKmhNjV4qqExIe7ULUY9mKCtQSJu1SFeIq5eRuk3yKOsRFIZs0bGSKlhI25SQuxTlLqZAL8jgSRhbECgvKGRJOFkR0R/wWZNVHgLuf+45oXlIkqaamZNcFXW7xqCFJsTPSbLKYj7CaBZkOKaTwVPAzqu6iVlJJQg9hguSe+7THxNHiXl4iMOM8+AQKkzr4+Hxm6ZBJaGwqufFFZknRSRZm0Zzk+vusqMQ7ZkHyCdJ0WqVDj3TqReOOqbh0ZinTSbj7gi5SJ2P6F3qGSW+N37VjlQ3yGONW9x20KRyHMhrEUkd0Hlop444eYqpjkhpkNxNeDZorYx/3/t6UVke+DbL8CU/39dZxcsaF1glyJo3W8bPGld70G4dwa/R6E4hrVHrjwAapnni7I541up1JpPvCy/hc49rLxC/HP4AUvcO8T+re8RtH8e+4wftSvPjew7JPutHDtk+SnwkYLqrSQ4EKParqqIYJKjkIZXkTBY1lNurMiZoaFWA5Y7LQkTKwUpu6tUPwSGGPurZD4UjpTQVERR5dMXhZpiKsQwNdpbXM8FxVRTtZvrU8oSKJunqibENFQ0U2Wc2tDPZcVkVBRTF5WacioqKiorxzma+iI0Kebam7oiRCuVnZRkVsWeVJ2Wf5D5tytLLRsrBIeUlFumWNZlnKOf+yZLPqSyXUUmBFtKc4X1WBitaybLMavnJUhAq+CsWyxnA5fUXleUlHJQG1LllZTkXqeTWqCuFTmKfyk0psOeDcYVmPLx+yzN8yzlMRQVVoSZ5NGkGNZEn8KclTM1qxcJnFMspTNVplttzBsisjj7xCwrIhoyBHTWmZlU1nWp5lmZZNqztPV5mhnMuyJqNUV/VhGfQpwlOFTjlyyercpVm9O39bWWpJ8SnFU4tOaXKZxzJYs1y13G3Zy7JZs3BbjbAMaVnzSaBZ1qdopTJ2GfIpfL2MvVxu2bRZxKekpWJ2mf0peL2mR5lnSfYp+V3zSnGnzG7ZzbL1XfcrD6DstSRnWbte+lwJdm72FMldBlDpLd9ZJnoK5a76VhZb0jsve9fCVxpdFjjXc/mbrVy65OsMKG5mX7cs5cOfE8wWMVsGnlpzd/ao6pUOOiNmK+nVOp1tvkNmi4VedL2LZsudACGcBXXEMVc4zojfTXWUdwoiz7RcHHT+7pRInSt2NNEX2gFNXLh0dHfyaU55XER0JNRW3M6oOypqSm5WXk7Puf8C517OM7gVgQvNLvg6asDFJxewLXmOhWgXNPzizHPTjnbbfK3zD2eaLc2dWsI5pHP2d6KvupgVGxeeLV23OSZuVbelbGcz/NLO05qOzOsar1P37Dyvc92OVtkln0eSd4UtNYGSj7NRF9+vIII8qHPBdwk+daR5oSdGPu3YOZInpXcLPsnYldlTpncNPlWB0tGzO8+AnDKKs3HPCICu3PLiozOf0OxS46P1VwBAobfo5LTdMwegMQuEe6R5V+mWZ1ioPQM+GX6FAJQY5qWetN5tuqUZgDen6J7FusU7yzdny57RAD3fPIElq6efR+6veN1agRXcRwrPwu0igeXMJ4yv9O0KAeDGI6Zn57fizRzPk9q7VbeUb2Hv8s7Z1rvXV+C3ws28wFm3Z+52LdJp7hPDe963yk+JLzD0kfC97luJcN73rPDdzkeaEPhz6vsE46OYu/DD9EhTGM20wnmQ7geTQUte2T5izLI23XzMjWbqmJZ17Jk4ecjOkcZLvnnIxpHhTd5LpQ+b8bekrn38FxNHZsExhtLUpmVEJuoxu9JCEnOxDLZTJ5XVRPr9MaJS/6YFdYZkSUP7pDKTigybU2v7qDIHSklIO3CJNb4kpdzmPK2jJKfcDictpCTewjojjXJxiZVlWgZucWHTTDN95Rjw4Ocx18SElB4q02RhtZ7+XBIYzlRfUnhmzJ3JuTjszLYl7bY4OJQJvrj4yNwtU3BmRMAUm9FzzLQ4y2v7nkkx9R/LHDyzXEa/aRi2ZUj6nmkQtkUOs1ymgmmTx0gU02xG/TEXy0wUB9qUMMu4NLvS1INpRbppSSa2aUm6iWkm5lTkMRnL6BTbw9SkaY+Gvi5TbUawabzHdJctRibHVKZpuIblNrNdpolpu8doFSPNNPVDjcdsFbvV1Mcx2EO+htW32Up67JTnQ/2aPj8T7jT5Q/madUva7JTqQ/uaaQ/jxnSqaeiaRQ+zXqbOMe5D9dvMJftOJuFUrGns2/gl28cUwKnv0xrABDVde8zx0Mll/M0YOp17HPY2icfmm2l03PY2+mklm5Z4nPQWG66nYRPdvKIxC2k9Z1qvccXGnjltW9sMXGPMHDxuAm5os7d29x/X77HXds8fN77ZgGjNYTQEX8m0hHWvYTS3rho+q2ptptS1riW0JNHZTK5u2GhozaS0uq3CPstqzas2JF/ptERUW1audV7xtXRE17FddreURDc1W9toja40P1n7bPSxN0VbG20Mia6VtKTb2Gqtpjzzb0y0tLxsQF0GtkT7jPFbF9pobcy0tOJbR0U349tQbKyNrNG3VF6Zdm4QsG+Tr+a0pF7ZoNkQfoT5LD03x64Bnh02dvgNoFb9XeN8FhBbhC7leaYQW0kuxT+SfNZjGgqvWFyjfFZimmfXHFy7svUp1iVcG7INc1uVrlh5tmbqWK5oeTZ69PWaGNa4XGuyzfRaHq5APyJ8lumbIi+tnl06V3sMdpqkLhU/Unw26Bsnr3hcg3Us1Nbcrrxcm3WMdloJV5GuND8EOmcAxsCN2CvIj/Atc441uX8NHgaYtq7PXrF/BG/Z9jbxXMp+JH+tXzfsrNpdubm2fm1/6/s2eV3KudZumb1sgD2bfUTymfs2967tXBF9hPJZ/zSJXeo9l31tEDSOXgk863kN5DSVXvrSfiQtznBeZD1o90HoYKQu6xw0tF9ea7plwzlxacu6dU8eOXbiahNgXt934Orwp+6g20PoEKmtbh1GtGXqKLhF0hzbugzrwLhl0pxJti/URHVuJbscaXu4hVbuXjuj65CprW0dVbRV1GR0bmwdVHRCqw1uXVh2iKtNLru6aOuozS67IWgLAcfYXGW0k6zOM9qPa4Ktzq6dqrWt3Hq9+vhO19tCNwfp15tdrrS9gP3DberAeRfHbJ2si/2ODtuazou9fZ2AizPP9m36+SeH2DYxHb2XtIsTArevLTRbP9xTyHaKLX2OIQSXwU17joFoZ7n20i1KjnW+g5E2sy31lyzck5FOGNuCzEPyTqprD45lGafFLXiOxWnHxi24a5GXhMyD4w6PaxOOHTr72ja1rb+tY93Hum6RW7jXMq1DdC527a1bzK2b3Qeqbcm2yV7A7hPVTrZrnxf/j7lqlx+ni00x2+6PVRv73LZo28SPJRtXrU0z28qPTRsnvbara6nWwStnvfbaLfqX6I8VnxPXzpstpGux1tGvw+cOH9tenl2Aa29b4LXaS+bHFr6jb9vgtZzb0NdRTEfvFpPb5tfBtwvFpoTbxNdogZ7HOkvOU9aJBwjDqcldgyfQfa3rcrt520U3LXVw8kzn5uje0YvD3aPLnqHWrTB1dvIG/RbWM7hrYFtGF+XGtLbMLVJtqnOZ5jr51vZB0rO4a0EX+8a1tkpthuZma0/l9vqR2jO5a2JbRxe9tkJtunOjc7TyWsSdrcurO0O3SG2y8mr57tzzqetdF6w2Hzhmdcl2V9BVostS2w4csDrbOmm+1/R68UJyR/K06QrtCu02r60GzljduNwadqnXFgLHLy6HPXS6anQ5ajuBg5EvqF05ugy1ramnT3cEdwRP756xHl9do93f22jb/9nlcYx5LeBeItyFeA527W1D2xW9JL00cUw8+N6QUh+9yFaoMWh1mz9+XXk+hYVJPwBX6e3/3N9Q6ujbXRzyXW08xVwg42Pu8BA3mDwV4HO3XqBnr1bqaBveJBUK/dS6YZ+QlhaM+FCZvQpIrdR4ffDjM7jrWgIUaxVOsowuikh0MPlOiM865jwsimk6lrmgxFolxSboHVZEFlz3WBbFdRY0zspyCkRgZqzFsGOIFtHxOuaKrS4VJb58yx7mgheUglMlL3+kWMacadoso393OLT/9ErpXCdrqoTZrpFcP8rRDGvX+TH0Xuk2l3j1g/bgpHZs0hR3+rEsHtRYhnbqM+lVT+p8L9NrrKbnsNZsZznY9iz6FrM6+uSP0Xdi6nXDnN4nZvh7mxU46Wyt0bLAyIp9M2zdKgIdTmhbWAj6ybz0RImtfPxZGLoVe4T56fEFIe/j5128PHFEOpwSciiZ41Kjqp6+ckUub8UNhY2Nt5xsgQW4I27i7/NiOEaBYZEEgO9vbuzImhmygkjb5PrXGa7vKLBPwhLemxnWq7YZniSvpfX56Fm+Atl3kkqneNbiJQXPfa6L1aVsvnfn2GffBc6EfJprZ6ewGKlH3x7OHuDwh6VnDaCY3h4Q5UKPfCDSaSKakLUGl0Vo5FwJJ+wRfp0ar6znb5WFb/E3V/5qWK/62IHs/yejWxCo7YOejKYpu9yp1Xpo51sViZ7/xHiberl1J8Xe11g3YTJE07gGsxZMDdU51De0WQ5uoXf+xVEwtWXsUHfQns5/lNQ9zFKvPdf3HK6JE01Kx7qiV45Wc0nqMVQTJ5mYis7HpImp5ALTHo8sGjr/ofcS1va+Mb+mMJz9GE09XRSozMXaapSzzl0tGiwgLI97vrkG8rAcP8zKSJhyE0tQB8Lpdmm/hS1ZIYvErspnWQtUYmnl9Hx1rPqPazxJEZ9hvnjl9s7WRl/DoOSHjgS5AsW7h3myM+DwUxz1fDtUlRjkOZ52+hZWvZ5nahzM+C/KroNdSUvbFXKHVnvO3pyvukgSScxXSsUUIyPtdshahPZFCMbjEhKcc+O8QX5KdwjDr+zzfZmkjXzv0WQ+s+ky3Z5ZnAANWsXt7TqlTYS5+wIrJEdEWC6ewy8SnDq0Z1yFQLJYRB2+N4ynTdmUBZW/s4QdfTMxV9yM8dlrJTPnpg5MZlc8F0uNH0/YhCBF83uz1O9FltI8fEf0r3LNRwtfszV0i/wnBWDvEDPtQ2Gpzxpnr+bPhhS6otyLT/X6mqW6tpoMHOWp2QuTdMuTdEuTDIvOgBiPeRaWjHVnX1m3lfYTn9sVyupuF/oOjiel+ka33DdBNRyvc217OUnP2XUXCH5SSZYe6c35Imy942uomUjmRKkn1oPJIUeO6VfmVnVemgkah8Vs1yC1ipzaueidNwfd8YweVDd2CzH34fP3glaII2Z3rblTQzPT3ZLdT0p1fNPHpchtiKTOMZ0/7U0pL9Ezaz7P93wuYjg0j44WtZ2TxfWXMtsO/mR27U2pXUcL6gk5TJ1ZvaR8TidccAssrtm9eHxGJ2t0x1H4J7SUSi/K+lwaDD1uH2Es32cloqeEjrPa8ariRsvp9YOyO5IqY68cYwmFnB+5aTTGnxc6Z1EU+D+e3uFpNfIjNfI9NcotNfI+OvnnHYbNyf6+anKd42avuc2LmDLc3yJcV2HqHkPPxBW2Dltfi5a6FZM5Tp9kna9co8CJ3btmFnfvbHgC3/H4y6yDC5Pb13ds3h5ByFi7pP4DXLPbV3JsXn7uQuyYGfOYQpaMYJYfOv5qNPo6b1h8ze/LWASarEZqKq+VOzohhdxv0sYBkRVGC4KclQDyalIxjmPAXtdhDmGur/qo7d0V6qKXvXasM77ndgXFtHBOK7jkQ5lqKv/x32SnFQU33esgSXmeRaalcWd4FxZ8oW7pUXmBRSbWMWf4aGZ8oQPp0TnSRaas71selnhhsx7+AhY9ovl02tmyCDNhjPMaNdKBR+8A/A7TNxrX6UWS+eTIV8fv7aOZSZ0nPfeqyT/wLv+cbP3zyfCvillneIR/auE/n5z/qvhXIybBBTOyhPPxBQn3Azpq9vi99It6aj/04gODXSpeArP79GOsy1nMP5f61zNN/BmvAr8sMZ30Ef73pviyjobTASfit9RM/dZHS8OBsCuvK2/2WYyZnnpEMWdFPFlqlfbHRWqRcHYRNMrUvM4yiw75LQgxUdxvGGiMwcpufG/CP1c3kAZTtPpTdPraWn3q6n3qmn3qGn1t9X75z76B+mHR9UTskKF5XhiXUFBCA9do5jor+u32dpz/rdOSvGSeEVygx2wN18/aXzrhfbDF+Pgb6e2vqnE+4+J1npuMgGaA26unTwBX8VZJ/YTEM63tocHfyJEPK//8GoHXEdbdW9XB+4Af5R+t1ztYxeR8JovB57rm4HStQ/vwG4OnQbse2mZjFhJX4mKiBBXsgQF/oy7LwvK+cguGsK//j4W2Dw/OPhpCXR8kRf2/JvxNfZC+mKvAv3Rd2m1eH6/yVmHCyYmBRsiPuH/nasX3zntakQwojBr2WwfIE6ogGygzuKWtG4Na4292fwXZoZUOzl2Um8BnUKTU/bfSLFmTf+4vWjxoVlQQH2IKi/OUr4CJ8/z7ljs1wyYuYfdCE92IojJv47Ais8I7QFOLLz3vq5HmR8Nc7cuWKDQPLqRNfRtiUIfabp+IIcmtHzl1vFO/LfIQPSc6CgQmI1mhOYlmDrSJvYa9AZzU3FVU1RVTt8nFLiWVrtrqaP/lOIkeYLOFzQD4fqlbe/wA526cP8KG1ROrGbrBH6355kNh/T8FiCX7AuOZOiaO7RkSA7/KOJnO6kNjtsAvnYhgHupYIggb4JXZKBNKofhr8vHsdgmGjOL3+ektTqVVVXV7w4iP1WbzoNezpAJJzcblMweHVNvy+obJ2rpMTUc5QK3TslF5uQourKp/EWIotc7CUJOSYRFCeMX8DHRfKks5rcVSRAK5OrplOEKETr7ywKaSMhZ8fjtsEqM0+1m0xHRtYfwvMt09LIFJZZFfqPkFufSKFhmuToGEYlAgR3WN7TinobbGbzmPr0y78PhhcW0SQ1o1izzSnSWYrd8fJFGBG7e+ku/eDDFRPrnUglBFi/nWhTeHTRW2g+IWYpwVqFzS/noectk56DxRUaEorIWBG1ktYzn5rLO6XcW6BPHqXeOEx+7wbkyIYWSxWXNQYyqTAUDGyc4XXLQB3+yoUg41Edh17PacuVz6VfqYRQkdE9zMRCrg1UBkQejr6jnstoPbyZL+gfSSMDFmkxXSL9mVxcKuk5msSabiLMgNVnf7w2cqyvZXC1Qvi4wuzuozV1mXrI63/9zMh7Qmwk+HdOW7gwDIk37aXCL4onna10hrmVWD91dG7zNXLKMT1hwzramllzdJubbN/Sgx8kgxD+HMn4zPZ4wS8OFkJvXS1uvn3UxWqPDj/jGQFAe2RxQ6no1XojnyfGDI7cjEjhRlq0ZauB0/UVD3udy9M7LZI+Hz5SzTVt3Z2dnjysI4fooi6L3KIq1qIl3YVM3KJOJPpG7tBScnJ9oK3EBt0o8PxudrkrGowVOnk08gyfJw7gd1
*/