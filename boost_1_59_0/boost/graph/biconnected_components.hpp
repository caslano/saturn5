// Copyright (c) Jeremy Siek 2001
// Copyright (c) Douglas Gregor 2004
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// NOTE: this final is generated by libs/graph/doc/biconnected_components.w

#ifndef BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP
#define BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP

#include <stack>
#include <vector>
#include <algorithm> // for std::min and std::max
#include <boost/config.hpp>
#include <boost/limits.hpp>
#include <boost/graph/graph_traits.hpp>
#include <boost/graph/graph_concepts.hpp>
#include <boost/property_map/property_map.hpp>
#include <boost/graph/depth_first_search.hpp>
#include <boost/graph/graph_utility.hpp>
#include <boost/concept/assert.hpp>
#include <boost/assert.hpp>

namespace boost
{
namespace detail
{
    template < typename ComponentMap, typename DiscoverTimeMap,
        typename LowPointMap, typename PredecessorMap, typename OutputIterator,
        typename Stack, typename ArticulationVector, typename IndexMap,
        typename DFSVisitor >
    struct biconnected_components_visitor : public dfs_visitor<>
    {
        biconnected_components_visitor(ComponentMap comp, std::size_t& c,
            std::size_t& children_of_root, DiscoverTimeMap dtm,
            std::size_t& dfs_time, LowPointMap lowpt, PredecessorMap pred,
            OutputIterator out, Stack& S,
            ArticulationVector& is_articulation_point, IndexMap index_map,
            DFSVisitor vis)
        : comp(comp)
        , c(c)
        , children_of_root(children_of_root)
        , dtm(dtm)
        , dfs_time(dfs_time)
        , lowpt(lowpt)
        , pred(pred)
        , out(out)
        , S(S)
        , is_articulation_point(is_articulation_point)
        , index_map(index_map)
        , vis(vis)
        {
        }

        template < typename Vertex, typename Graph >
        void initialize_vertex(const Vertex& u, Graph& g)
        {
            put(pred, u, u);
            vis.initialize_vertex(u, g);
        }

        template < typename Vertex, typename Graph >
        void start_vertex(const Vertex& u, Graph& g)
        {
            children_of_root = 0;
            vis.start_vertex(u, g);
        }

        template < typename Vertex, typename Graph >
        void discover_vertex(const Vertex& u, Graph& g)
        {
            put(dtm, u, ++dfs_time);
            put(lowpt, u, get(dtm, u));
            vis.discover_vertex(u, g);
        }

        template < typename Edge, typename Graph >
        void examine_edge(const Edge& e, Graph& g)
        {
            vis.examine_edge(e, g);
        }

        template < typename Edge, typename Graph >
        void tree_edge(const Edge& e, Graph& g)
        {
            typename boost::graph_traits< Graph >::vertex_descriptor src
                = source(e, g);
            typename boost::graph_traits< Graph >::vertex_descriptor tgt
                = target(e, g);

            S.push(e);
            put(pred, tgt, src);
            if (get(pred, src) == src)
            {
                ++children_of_root;
            }
            vis.tree_edge(e, g);
        }

        template < typename Edge, typename Graph >
        void back_edge(const Edge& e, Graph& g)
        {
            BOOST_USING_STD_MIN();

            typename boost::graph_traits< Graph >::vertex_descriptor src
                = source(e, g);
            typename boost::graph_traits< Graph >::vertex_descriptor tgt
                = target(e, g);
            if (tgt != get(pred, src))
            {
                S.push(e);
                put(lowpt, src,
                    min BOOST_PREVENT_MACRO_SUBSTITUTION(
                        get(lowpt, src), get(dtm, tgt)));
            }
            vis.back_edge(e, g);
        }

        template < typename Edge, typename Graph >
        void forward_or_cross_edge(const Edge& e, Graph& g)
        {
            vis.forward_or_cross_edge(e, g);
        }

        template < typename Vertex, typename Graph >
        void finish_vertex(const Vertex& u, Graph& g)
        {
            BOOST_USING_STD_MIN();
            Vertex parent = get(pred, u);
            if (parent == u)
            { // Root of tree is special
                is_articulation_point[get(index_map, u)]
                    = (children_of_root > 1);
            }
            else
            {
                put(lowpt, parent,
                    min BOOST_PREVENT_MACRO_SUBSTITUTION(
                        get(lowpt, parent), get(lowpt, u)));
                if (get(lowpt, u) >= get(dtm, parent))
                {
                    is_articulation_point[get(index_map, parent)] = true;
                    while (get(dtm, source(S.top(), g)) >= get(dtm, u))
                    {
                        put(comp, S.top(), c);
                        S.pop();
                    }
                    BOOST_ASSERT(source(S.top(), g) == parent);
                    BOOST_ASSERT(target(S.top(), g) == u);
                    put(comp, S.top(), c);
                    S.pop();
                    ++c;
                }
            }
            if (is_articulation_point[get(index_map, u)])
            {
                *out++ = u;
            }
            vis.finish_vertex(u, g);
        }

        ComponentMap comp;
        std::size_t& c;
        std::size_t& children_of_root;
        DiscoverTimeMap dtm;
        std::size_t& dfs_time;
        LowPointMap lowpt;
        PredecessorMap pred;
        OutputIterator out;
        Stack& S;
        ArticulationVector& is_articulation_point;
        IndexMap index_map;
        DFSVisitor vis;
    };

    template < typename Graph, typename ComponentMap, typename OutputIterator,
        typename VertexIndexMap, typename DiscoverTimeMap, typename LowPointMap,
        typename PredecessorMap, typename DFSVisitor >
    std::pair< std::size_t, OutputIterator > biconnected_components_impl(
        const Graph& g, ComponentMap comp, OutputIterator out,
        VertexIndexMap index_map, DiscoverTimeMap dtm, LowPointMap lowpt,
        PredecessorMap pred, DFSVisitor dfs_vis)
    {
        typedef typename graph_traits< Graph >::vertex_descriptor vertex_t;
        typedef typename graph_traits< Graph >::edge_descriptor edge_t;
        BOOST_CONCEPT_ASSERT((VertexListGraphConcept< Graph >));
        BOOST_CONCEPT_ASSERT((IncidenceGraphConcept< Graph >));
        BOOST_CONCEPT_ASSERT(
            (WritablePropertyMapConcept< ComponentMap, edge_t >));
        BOOST_CONCEPT_ASSERT(
            (ReadWritePropertyMapConcept< DiscoverTimeMap, vertex_t >));
        BOOST_CONCEPT_ASSERT(
            (ReadWritePropertyMapConcept< LowPointMap, vertex_t >));
        BOOST_CONCEPT_ASSERT(
            (ReadWritePropertyMapConcept< PredecessorMap, vertex_t >));

        std::size_t num_components = 0;
        std::size_t children_of_root;
        std::size_t dfs_time = 0;
        std::stack< edge_t > S;
        std::vector< char > is_articulation_point(num_vertices(g));

        biconnected_components_visitor< ComponentMap, DiscoverTimeMap,
            LowPointMap, PredecessorMap, OutputIterator, std::stack< edge_t >,
            std::vector< char >, VertexIndexMap, DFSVisitor >
            vis(comp, num_components, children_of_root, dtm, dfs_time, lowpt,
                pred, out, S, is_articulation_point, index_map, dfs_vis);

        depth_first_search(g, visitor(vis).vertex_index_map(index_map));

        return std::pair< std::size_t, OutputIterator >(
            num_components, vis.out);
    }

    template < typename PredecessorMap > struct bicomp_dispatch3
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename LowPointMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, LowPointMap lowpt,
            const bgl_named_params< P, T, R >& params, PredecessorMap pred)
        {
            return biconnected_components_impl(g, comp, out, index_map, dtm,
                lowpt, pred,
                choose_param(get_param(params, graph_visitor),
                    make_dfs_visitor(null_visitor())));
        }
    };

    template <> struct bicomp_dispatch3< param_not_found >
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename LowPointMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, LowPointMap lowpt,
            const bgl_named_params< P, T, R >& params, param_not_found)
        {
            typedef typename graph_traits< Graph >::vertex_descriptor vertex_t;
            std::vector< vertex_t > pred(num_vertices(g));
            vertex_t vert = graph_traits< Graph >::null_vertex();

            return biconnected_components_impl(g, comp, out, index_map, dtm,
                lowpt,
                make_iterator_property_map(pred.begin(), index_map, vert),
                choose_param(get_param(params, graph_visitor),
                    make_dfs_visitor(null_visitor())));
        }
    };

    template < typename LowPointMap > struct bicomp_dispatch2
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename P, typename T, typename R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, const bgl_named_params< P, T, R >& params,
            LowPointMap lowpt)
        {
            typedef typename get_param_type< vertex_predecessor_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch3< dispatch_type >::apply(g, comp, out,
                index_map, dtm, lowpt, params,
                get_param(params, vertex_predecessor));
        }
    };

    template <> struct bicomp_dispatch2< param_not_found >
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap,
            typename DiscoverTimeMap, typename P, typename T, typename R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            DiscoverTimeMap dtm, const bgl_named_params< P, T, R >& params,
            param_not_found)
        {
            typedef typename graph_traits< Graph >::vertices_size_type
                vertices_size_type;
            std::vector< vertices_size_type > lowpt(num_vertices(g));
            vertices_size_type vst(0);

            typedef typename get_param_type< vertex_predecessor_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch3< dispatch_type >::apply(g, comp, out,
                index_map, dtm,
                make_iterator_property_map(lowpt.begin(), index_map, vst),
                params, get_param(params, vertex_predecessor));
        }
    };

    template < typename DiscoverTimeMap > struct bicomp_dispatch1
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            const bgl_named_params< P, T, R >& params, DiscoverTimeMap dtm)
        {
            typedef typename get_param_type< vertex_lowpoint_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch2< dispatch_type >::apply(g, comp, out,
                index_map, dtm, params, get_param(params, vertex_lowpoint));
        }
    };

    template <> struct bicomp_dispatch1< param_not_found >
    {
        template < typename Graph, typename ComponentMap,
            typename OutputIterator, typename VertexIndexMap, class P, class T,
            class R >
        static std::pair< std::size_t, OutputIterator > apply(const Graph& g,
            ComponentMap comp, OutputIterator out, VertexIndexMap index_map,
            const bgl_named_params< P, T, R >& params, param_not_found)
        {
            typedef typename graph_traits< Graph >::vertices_size_type
                vertices_size_type;
            std::vector< vertices_size_type > discover_time(num_vertices(g));
            vertices_size_type vst(0);

            typedef typename get_param_type< vertex_lowpoint_t,
                bgl_named_params< P, T, R > >::type dispatch_type;

            return bicomp_dispatch2< dispatch_type >::apply(g, comp, out,
                index_map,
                make_iterator_property_map(
                    discover_time.begin(), index_map, vst),
                params, get_param(params, vertex_lowpoint));
        }
    };

}

template < typename Graph, typename ComponentMap, typename OutputIterator,
    typename DiscoverTimeMap, typename LowPointMap >
std::pair< std::size_t, OutputIterator > biconnected_components(const Graph& g,
    ComponentMap comp, OutputIterator out, DiscoverTimeMap dtm,
    LowPointMap lowpt)
{
    typedef param_not_found dispatch_type;

    return detail::bicomp_dispatch3< dispatch_type >::apply(g, comp, out,
        get(vertex_index, g), dtm, lowpt,
        bgl_named_params< int, buffer_param_t >(0), param_not_found());
}

template < typename Graph, typename ComponentMap, typename OutputIterator,
    typename P, typename T, typename R >
std::pair< std::size_t, OutputIterator > biconnected_components(const Graph& g,
    ComponentMap comp, OutputIterator out,
    const bgl_named_params< P, T, R >& params)
{
    typedef typename get_param_type< vertex_discover_time_t,
        bgl_named_params< P, T, R > >::type dispatch_type;

    return detail::bicomp_dispatch1< dispatch_type >::apply(g, comp, out,
        choose_const_pmap(get_param(params, vertex_index), g, vertex_index),
        params, get_param(params, vertex_discover_time));
}

template < typename Graph, typename ComponentMap, typename OutputIterator >
std::pair< std::size_t, OutputIterator > biconnected_components(
    const Graph& g, ComponentMap comp, OutputIterator out)
{
    return biconnected_components(
        g, comp, out, bgl_named_params< int, buffer_param_t >(0));
}

namespace graph_detail
{
    struct dummy_output_iterator
    {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void pointer;
        typedef void difference_type;

        struct reference
        {
            template < typename T > reference& operator=(const T&)
            {
                return *this;
            }
        };

        reference operator*() const { return reference(); }
        dummy_output_iterator& operator++() { return *this; }
        dummy_output_iterator operator++(int) { return *this; }
    };
} // end namespace graph_detail

template < typename Graph, typename ComponentMap, typename P, typename T,
    typename R >
std::size_t biconnected_components(const Graph& g, ComponentMap comp,
    const bgl_named_params< P, T, R >& params)
{
    return biconnected_components(
        g, comp, graph_detail::dummy_output_iterator(), params)
        .first;
}

template < typename Graph, typename ComponentMap >
std::size_t biconnected_components(const Graph& g, ComponentMap comp)
{
    return biconnected_components(
        g, comp, graph_detail::dummy_output_iterator())
        .first;
}

template < typename Graph, typename OutputIterator, typename P, typename T,
    typename R >
OutputIterator articulation_points(const Graph& g, OutputIterator out,
    const bgl_named_params< P, T, R >& params)
{
    return biconnected_components(g, dummy_property_map(), out, params).second;
}

template < typename Graph, typename OutputIterator >
OutputIterator articulation_points(const Graph& g, OutputIterator out)
{
    return biconnected_components(g, dummy_property_map(), out,
        bgl_named_params< int, buffer_param_t >(0))
        .second;
}

} // namespace boost

#endif /* BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP */

/* biconnected_components.hpp
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
*/