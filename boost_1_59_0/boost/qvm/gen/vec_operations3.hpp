#ifndef BOOST_QVM_GEN_VEC_OPERATIONS3_HPP_INCLUDED
#define BOOST_QVM_GEN_VEC_OPERATIONS3_HPP_INCLUDED

// Copyright 2008-2022 Emil Dotchevski and Reverge Studios, Inc.

// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// This file was generated by a program. Do not edit manually.

#include <boost/qvm/deduce_scalar.hpp>
#include <boost/qvm/deduce_vec.hpp>
#include <boost/qvm/error.hpp>
#include <boost/qvm/gen/vec_assign3.hpp>
#include <boost/qvm/math.hpp>
#include <boost/qvm/static_assert.hpp>
#include <boost/qvm/throw_exception.hpp>

namespace boost { namespace qvm {

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==3 && vec_traits<B>::dim==3,
    deduce_vec2<A,B,3> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_vec2<A,B,3>::type R;
    BOOST_QVM_STATIC_ASSERT(vec_traits<R>::dim==3);
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)+vec_traits<B>::template read_element<0>(b);
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)+vec_traits<B>::template read_element<1>(b);
    vec_traits<R>::template write_element<2>(r)=vec_traits<A>::template read_element<2>(a)+vec_traits<B>::template read_element<2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int D>
    struct plus_vv_defined;

    template <>
    struct
    plus_vv_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==3 && vec_traits<B>::dim==3,
    deduce_vec2<A,B,3> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_vec2<A,B,3>::type R;
    BOOST_QVM_STATIC_ASSERT(vec_traits<R>::dim==3);
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)-vec_traits<B>::template read_element<0>(b);
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)-vec_traits<B>::template read_element<1>(b);
    vec_traits<R>::template write_element<2>(r)=vec_traits<A>::template read_element<2>(a)-vec_traits<B>::template read_element<2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int D>
    struct minus_vv_defined;

    template <>
    struct
    minus_vv_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==3 && vec_traits<B>::dim==3,
    A &>::type
operator+=( A & a, B const & b )
    {
    vec_traits<A>::template write_element<0>(a)+=vec_traits<B>::template read_element<0>(b);
    vec_traits<A>::template write_element<1>(a)+=vec_traits<B>::template read_element<1>(b);
    vec_traits<A>::template write_element<2>(a)+=vec_traits<B>::template read_element<2>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct plus_eq_vv_defined;

    template <>
    struct
    plus_eq_vv_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==3 && vec_traits<B>::dim==3,
    A &>::type
operator-=( A & a, B const & b )
    {
    vec_traits<A>::template write_element<0>(a)-=vec_traits<B>::template read_element<0>(b);
    vec_traits<A>::template write_element<1>(a)-=vec_traits<B>::template read_element<1>(b);
    vec_traits<A>::template write_element<2>(a)-=vec_traits<B>::template read_element<2>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct minus_eq_vv_defined;

    template <>
    struct
    minus_eq_vv_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==3 && is_scalar<B>::value,
    deduce_vec2<A,B,vec_traits<A>::dim> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_vec2<A,B,vec_traits<A>::dim>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)*b;
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)*b;
    vec_traits<R>::template write_element<2>(r)=vec_traits<A>::template read_element<2>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_vs_defined;

    template <>
    struct
    mul_vs_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && vec_traits<B>::dim==3,
    deduce_vec2<A,B,vec_traits<B>::dim> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_vec2<A,B,vec_traits<B>::dim>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=a*vec_traits<B>::template read_element<0>(b);
    vec_traits<R>::template write_element<1>(r)=a*vec_traits<B>::template read_element<1>(b);
    vec_traits<R>::template write_element<2>(r)=a*vec_traits<B>::template read_element<2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_sv_defined;

    template <>
    struct
    mul_sv_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class  B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==3 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    vec_traits<A>::template write_element<0>(a)*=b;
    vec_traits<A>::template write_element<1>(a)*=b;
    vec_traits<A>::template write_element<2>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_eq_vs_defined;

    template <>
    struct
    mul_eq_vs_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==3 && is_scalar<B>::value,
    deduce_vec2<A,B,vec_traits<A>::dim> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_vec2<A,B,vec_traits<A>::dim>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)/b;
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)/b;
    vec_traits<R>::template write_element<2>(r)=vec_traits<A>::template read_element<2>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int D>
    struct div_vs_defined;

    template <>
    struct
    div_vs_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class  B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==3 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    vec_traits<A>::template write_element<0>(a)/=b;
    vec_traits<A>::template write_element<1>(a)/=b;
    vec_traits<A>::template write_element<2>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct div_eq_vs_defined;

    template <>
    struct
    div_eq_vs_defined<3>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    is_vec<A>::value &&
    vec_traits<R>::dim==3 && vec_traits<A>::dim==3,
    R>::type
convert_to( A const & a )
    {
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a);
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a);
    vec_traits<R>::template write_element<2>(r)=vec_traits<A>::template read_element<2>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int D>
    struct convert_to_v_defined;

    template <>
    struct
    convert_to_v_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==3 && vec_traits<B>::dim==3,
bool>::type
operator==( A const & a, B const & b )
    {
    return
        vec_traits<A>::template read_element<0>(a)==vec_traits<B>::template read_element<0>(b) &&
        vec_traits<A>::template read_element<1>(a)==vec_traits<B>::template read_element<1>(b) &&
        vec_traits<A>::template read_element<2>(a)==vec_traits<B>::template read_element<2>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int D>
    struct eq_vv_defined;

    template <>
    struct
    eq_vv_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==3 && vec_traits<B>::dim==3,
bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(vec_traits<A>::template read_element<0>(a)==vec_traits<B>::template read_element<0>(b)) ||
        !(vec_traits<A>::template read_element<1>(a)==vec_traits<B>::template read_element<1>(b)) ||
        !(vec_traits<A>::template read_element<2>(a)==vec_traits<B>::template read_element<2>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct neq_vv_defined;

    template <>
    struct
    neq_vv_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==3,
    deduce_vec<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_vec<A>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=-vec_traits<A>::template read_element<0>(a);
    vec_traits<R>::template write_element<1>(r)=-vec_traits<A>::template read_element<1>(a);
    vec_traits<R>::template write_element<2>(r)=-vec_traits<A>::template read_element<2>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int D>
    struct minus_v_defined;

    template <>
    struct
    minus_v_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    is_vec<A>::value && vec_traits<A>::dim==3,
    typename vec_traits<A>::scalar_type>::type
mag( A const & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const a2=vec_traits<A>::template read_element<2>(a);
    T const m2=a0*a0+a1*a1+a2*a2;
    T const mag=sqrt(m2);
    return mag;
    }

namespace
sfinae
    {
    using ::boost::qvm::mag;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mag_v_defined;

    template <>
    struct
    mag_v_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    is_vec<A>::value && vec_traits<A>::dim==3,
    typename vec_traits<A>::scalar_type>::type
mag_sqr( A const & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const a2=vec_traits<A>::template read_element<2>(a);
    T const m2=a0*a0+a1*a1+a2*a2;
    return m2;
    }

namespace
sfinae
    {
    using ::boost::qvm::mag_sqr;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mag_sqr_v_defined;

    template <>
    struct
    mag_sqr_v_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==3,
    deduce_vec<A> >::type
normalized( A const & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const a2=vec_traits<A>::template read_element<2>(a);
    T const m2=a0*a0+a1*a1+a2*a2;
    if( m2==scalar_traits<typename vec_traits<A>::scalar_type>::value(0) )
        BOOST_QVM_THROW_EXCEPTION(zero_magnitude_error());
    T const rm=scalar_traits<T>::value(1)/sqrt(m2);
    typedef typename deduce_vec<A>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=a0*rm;
    vec_traits<R>::template write_element<1>(r)=a1*rm;
    vec_traits<R>::template write_element<2>(r)=a2*rm;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::normalized;
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==3,
    void>::type
normalize( A & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const a2=vec_traits<A>::template read_element<2>(a);
    T const m2=a0*a0+a1*a1+a2*a2;
    if( m2==scalar_traits<typename vec_traits<A>::scalar_type>::value(0) )
        BOOST_QVM_THROW_EXCEPTION(zero_magnitude_error());
    T const rm=scalar_traits<T>::value(1)/sqrt(m2);
    vec_traits<A>::template write_element<0>(a)*=rm;
    vec_traits<A>::template write_element<1>(a)*=rm;
    vec_traits<A>::template write_element<2>(a)*=rm;
    }

namespace
sfinae
    {
    using ::boost::qvm::normalize;
    }

namespace
qvm_detail
    {
    template <int D>
    struct normalize_v_defined;

    template <>
    struct
    normalize_v_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==3 && vec_traits<B>::dim==3,
    deduce_scalar<typename vec_traits<A>::scalar_type,typename vec_traits<B>::scalar_type> >::type
dot( A const & a, B const & b )
    {
    typedef typename vec_traits<A>::scalar_type Ta;
    typedef typename vec_traits<B>::scalar_type Tb;
    typedef typename deduce_scalar<Ta,Tb>::type Tr;
    Ta const a0=vec_traits<A>::template read_element<0>(a);
    Ta const a1=vec_traits<A>::template read_element<1>(a);
    Ta const a2=vec_traits<A>::template read_element<2>(a);
    Tb const b0=vec_traits<B>::template read_element<0>(b);
    Tb const b1=vec_traits<B>::template read_element<1>(b);
    Tb const b2=vec_traits<B>::template read_element<2>(b);
    Tr const dot=a0*b0+a1*b1+a2*b2;
    return dot;
    }

namespace
sfinae
    {
    using ::boost::qvm::dot;
    }

namespace
qvm_detail
    {
    template <int D>
    struct dot_vv_defined;

    template <>
    struct
    dot_vv_defined<3>
        {
        static bool const value=true;
        };
    }

} }

#endif

/* vec_operations3.hpp
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
*/