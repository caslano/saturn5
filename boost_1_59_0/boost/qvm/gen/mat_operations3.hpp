#ifndef BOOST_QVM_GEN_MAT_OPERATIONS3_HPP_INCLUDED
#define BOOST_QVM_GEN_MAT_OPERATIONS3_HPP_INCLUDED

// Copyright 2008-2022 Emil Dotchevski and Reverge Studios, Inc.

// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// This file was generated by a program. Do not edit manually.

#include <boost/qvm/assert.hpp>
#include <boost/qvm/deduce_mat.hpp>
#include <boost/qvm/deduce_vec.hpp>
#include <boost/qvm/error.hpp>
#include <boost/qvm/gen/mat_assign3.hpp>
#include <boost/qvm/quat_traits.hpp>
#include <boost/qvm/scalar_traits.hpp>
#include <boost/qvm/throw_exception.hpp>

namespace boost { namespace qvm {

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,3,3> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,3,3>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==3);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==3);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)+mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)+mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)+mat_traits<B>::template read_element<0,2>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)+mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)+mat_traits<B>::template read_element<1,1>(b);
    mat_traits<R>::template write_element<1,2>(r)=mat_traits<A>::template read_element<1,2>(a)+mat_traits<B>::template read_element<1,2>(b);
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)+mat_traits<B>::template read_element<2,0>(b);
    mat_traits<R>::template write_element<2,1>(r)=mat_traits<A>::template read_element<2,1>(a)+mat_traits<B>::template read_element<2,1>(b);
    mat_traits<R>::template write_element<2,2>(r)=mat_traits<A>::template read_element<2,2>(a)+mat_traits<B>::template read_element<2,2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_mm_defined;

    template <>
    struct
    plus_mm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,3,1> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,3,1>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==3);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==1);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)+mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)+mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)+mat_traits<B>::template read_element<2,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_mm_defined;

    template <>
    struct
    plus_mm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,1,3> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,1,3>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==1);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==3);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)+mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)+mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)+mat_traits<B>::template read_element<0,2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_mm_defined;

    template <>
    struct
    plus_mm_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,3,3> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,3,3>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==3);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==3);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)-mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)-mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)-mat_traits<B>::template read_element<0,2>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)-mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)-mat_traits<B>::template read_element<1,1>(b);
    mat_traits<R>::template write_element<1,2>(r)=mat_traits<A>::template read_element<1,2>(a)-mat_traits<B>::template read_element<1,2>(b);
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)-mat_traits<B>::template read_element<2,0>(b);
    mat_traits<R>::template write_element<2,1>(r)=mat_traits<A>::template read_element<2,1>(a)-mat_traits<B>::template read_element<2,1>(b);
    mat_traits<R>::template write_element<2,2>(r)=mat_traits<A>::template read_element<2,2>(a)-mat_traits<B>::template read_element<2,2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_mm_defined;

    template <>
    struct
    minus_mm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,3,1> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,3,1>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==3);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==1);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)-mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)-mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)-mat_traits<B>::template read_element<2,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_mm_defined;

    template <>
    struct
    minus_mm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,1,3> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,1,3>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==1);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==3);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)-mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)-mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)-mat_traits<B>::template read_element<0,2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_mm_defined;

    template <>
    struct
    minus_mm_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    A &>::type
operator+=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)+=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)+=mat_traits<B>::template read_element<0,1>(b);
    mat_traits<A>::template write_element<0,2>(a)+=mat_traits<B>::template read_element<0,2>(b);
    mat_traits<A>::template write_element<1,0>(a)+=mat_traits<B>::template read_element<1,0>(b);
    mat_traits<A>::template write_element<1,1>(a)+=mat_traits<B>::template read_element<1,1>(b);
    mat_traits<A>::template write_element<1,2>(a)+=mat_traits<B>::template read_element<1,2>(b);
    mat_traits<A>::template write_element<2,0>(a)+=mat_traits<B>::template read_element<2,0>(b);
    mat_traits<A>::template write_element<2,1>(a)+=mat_traits<B>::template read_element<2,1>(b);
    mat_traits<A>::template write_element<2,2>(a)+=mat_traits<B>::template read_element<2,2>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_eq_mm_defined;

    template <>
    struct
    plus_eq_mm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    A &>::type
operator+=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)+=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<1,0>(a)+=mat_traits<B>::template read_element<1,0>(b);
    mat_traits<A>::template write_element<2,0>(a)+=mat_traits<B>::template read_element<2,0>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_eq_mm_defined;

    template <>
    struct
    plus_eq_mm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    A &>::type
operator+=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)+=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)+=mat_traits<B>::template read_element<0,1>(b);
    mat_traits<A>::template write_element<0,2>(a)+=mat_traits<B>::template read_element<0,2>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_eq_mm_defined;

    template <>
    struct
    plus_eq_mm_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    A &>::type
operator-=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)-=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)-=mat_traits<B>::template read_element<0,1>(b);
    mat_traits<A>::template write_element<0,2>(a)-=mat_traits<B>::template read_element<0,2>(b);
    mat_traits<A>::template write_element<1,0>(a)-=mat_traits<B>::template read_element<1,0>(b);
    mat_traits<A>::template write_element<1,1>(a)-=mat_traits<B>::template read_element<1,1>(b);
    mat_traits<A>::template write_element<1,2>(a)-=mat_traits<B>::template read_element<1,2>(b);
    mat_traits<A>::template write_element<2,0>(a)-=mat_traits<B>::template read_element<2,0>(b);
    mat_traits<A>::template write_element<2,1>(a)-=mat_traits<B>::template read_element<2,1>(b);
    mat_traits<A>::template write_element<2,2>(a)-=mat_traits<B>::template read_element<2,2>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_eq_mm_defined;

    template <>
    struct
    minus_eq_mm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    A &>::type
operator-=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)-=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<1,0>(a)-=mat_traits<B>::template read_element<1,0>(b);
    mat_traits<A>::template write_element<2,0>(a)-=mat_traits<B>::template read_element<2,0>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_eq_mm_defined;

    template <>
    struct
    minus_eq_mm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    A &>::type
operator-=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)-=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)-=mat_traits<B>::template read_element<0,1>(b);
    mat_traits<A>::template write_element<0,2>(a)-=mat_traits<B>::template read_element<0,2>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_eq_mm_defined;

    template <>
    struct
    minus_eq_mm_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)*b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)*b;
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)*b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)*b;
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)*b;
    mat_traits<R>::template write_element<1,2>(r)=mat_traits<A>::template read_element<1,2>(a)*b;
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)*b;
    mat_traits<R>::template write_element<2,1>(r)=mat_traits<A>::template read_element<2,1>(a)*b;
    mat_traits<R>::template write_element<2,2>(r)=mat_traits<A>::template read_element<2,2>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_ms_defined;

    template <>
    struct
    mul_ms_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a*mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=a*mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<0,2>(r)=a*mat_traits<B>::template read_element<0,2>(b);
    mat_traits<R>::template write_element<1,0>(r)=a*mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=a*mat_traits<B>::template read_element<1,1>(b);
    mat_traits<R>::template write_element<1,2>(r)=a*mat_traits<B>::template read_element<1,2>(b);
    mat_traits<R>::template write_element<2,0>(r)=a*mat_traits<B>::template read_element<2,0>(b);
    mat_traits<R>::template write_element<2,1>(r)=a*mat_traits<B>::template read_element<2,1>(b);
    mat_traits<R>::template write_element<2,2>(r)=a*mat_traits<B>::template read_element<2,2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_sm_defined;

    template <>
    struct
    mul_sm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)*b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)*b;
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_ms_defined;

    template <>
    struct
    mul_ms_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==3 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a*mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=a*mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<2,0>(r)=a*mat_traits<B>::template read_element<2,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_sm_defined;

    template <>
    struct
    mul_sm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)*b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)*b;
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_ms_defined;

    template <>
    struct
    mul_ms_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==1 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a*mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=a*mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<0,2>(r)=a*mat_traits<B>::template read_element<0,2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_sm_defined;

    template <>
    struct
    mul_sm_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)*=b;
    mat_traits<A>::template write_element<0,1>(a)*=b;
    mat_traits<A>::template write_element<0,2>(a)*=b;
    mat_traits<A>::template write_element<1,0>(a)*=b;
    mat_traits<A>::template write_element<1,1>(a)*=b;
    mat_traits<A>::template write_element<1,2>(a)*=b;
    mat_traits<A>::template write_element<2,0>(a)*=b;
    mat_traits<A>::template write_element<2,1>(a)*=b;
    mat_traits<A>::template write_element<2,2>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_eq_ms_defined;

    template <>
    struct
    mul_eq_ms_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)*=b;
    mat_traits<A>::template write_element<1,0>(a)*=b;
    mat_traits<A>::template write_element<2,0>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_eq_ms_defined;

    template <>
    struct
    mul_eq_ms_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)*=b;
    mat_traits<A>::template write_element<0,1>(a)*=b;
    mat_traits<A>::template write_element<0,2>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_eq_ms_defined;

    template <>
    struct
    mul_eq_ms_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)/b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)/b;
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)/b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)/b;
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)/b;
    mat_traits<R>::template write_element<1,2>(r)=mat_traits<A>::template read_element<1,2>(a)/b;
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)/b;
    mat_traits<R>::template write_element<2,1>(r)=mat_traits<A>::template read_element<2,1>(a)/b;
    mat_traits<R>::template write_element<2,2>(r)=mat_traits<A>::template read_element<2,2>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_ms_defined;

    template <>
    struct
    div_ms_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator/( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a/mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=a/mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<0,2>(r)=a/mat_traits<B>::template read_element<0,2>(b);
    mat_traits<R>::template write_element<1,0>(r)=a/mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=a/mat_traits<B>::template read_element<1,1>(b);
    mat_traits<R>::template write_element<1,2>(r)=a/mat_traits<B>::template read_element<1,2>(b);
    mat_traits<R>::template write_element<2,0>(r)=a/mat_traits<B>::template read_element<2,0>(b);
    mat_traits<R>::template write_element<2,1>(r)=a/mat_traits<B>::template read_element<2,1>(b);
    mat_traits<R>::template write_element<2,2>(r)=a/mat_traits<B>::template read_element<2,2>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_sm_defined;

    template <>
    struct
    div_sm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)/b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)/b;
    mat_traits<R>::template write_element<2,0>(r)=mat_traits<A>::template read_element<2,0>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_ms_defined;

    template <>
    struct
    div_ms_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==3 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator/( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a/mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=a/mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<2,0>(r)=a/mat_traits<B>::template read_element<2,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_sm_defined;

    template <>
    struct
    div_sm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)/b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)/b;
    mat_traits<R>::template write_element<0,2>(r)=mat_traits<A>::template read_element<0,2>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_ms_defined;

    template <>
    struct
    div_ms_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)/=b;
    mat_traits<A>::template write_element<0,1>(a)/=b;
    mat_traits<A>::template write_element<0,2>(a)/=b;
    mat_traits<A>::template write_element<1,0>(a)/=b;
    mat_traits<A>::template write_element<1,1>(a)/=b;
    mat_traits<A>::template write_element<1,2>(a)/=b;
    mat_traits<A>::template write_element<2,0>(a)/=b;
    mat_traits<A>::template write_element<2,1>(a)/=b;
    mat_traits<A>::template write_element<2,2>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_eq_ms_defined;

    template <>
    struct
    div_eq_ms_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)/=b;
    mat_traits<A>::template write_element<1,0>(a)/=b;
    mat_traits<A>::template write_element<2,0>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_eq_ms_defined;

    template <>
    struct
    div_eq_ms_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)/=b;
    mat_traits<A>::template write_element<0,1>(a)/=b;
    mat_traits<A>::template write_element<0,2>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_eq_ms_defined;

    template <>
    struct
    div_eq_ms_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<R>::rows==3 && mat_traits<A>::rows==3 &&
    mat_traits<R>::cols==3 && mat_traits<A>::cols==3,
    R>::type
convert_to( A const & a )
    {
    R r;
    mat_traits<R>::template write_element<0,0>(r) = mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r) = mat_traits<A>::template read_element<0,1>(a);
    mat_traits<R>::template write_element<0,2>(r) = mat_traits<A>::template read_element<0,2>(a);
    mat_traits<R>::template write_element<1,0>(r) = mat_traits<A>::template read_element<1,0>(a);
    mat_traits<R>::template write_element<1,1>(r) = mat_traits<A>::template read_element<1,1>(a);
    mat_traits<R>::template write_element<1,2>(r) = mat_traits<A>::template read_element<1,2>(a);
    mat_traits<R>::template write_element<2,0>(r) = mat_traits<A>::template read_element<2,0>(a);
    mat_traits<R>::template write_element<2,1>(r) = mat_traits<A>::template read_element<2,1>(a);
    mat_traits<R>::template write_element<2,2>(r) = mat_traits<A>::template read_element<2,2>(a);
    return r;
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE
typename enable_if_c<
    is_mat<R>::value && is_quat<A>::value &&
    mat_traits<R>::rows==3 && mat_traits<R>::cols==3,
    R>::type
convert_to( A const & q )
    {
    typedef typename mat_traits<R>::scalar_type T;
    T const a=quat_traits<A>::template read_element<0>(q);
    T const b=quat_traits<A>::template read_element<1>(q);
    T const c=quat_traits<A>::template read_element<2>(q);
    T const d=quat_traits<A>::template read_element<3>(q);
    T const bb = b*b;
    T const cc = c*c;
    T const dd = d*d;
    T const bc = b*c;
    T const bd = b*d;
    T const cd = c*d;
    T const ab = a*b;
    T const ac = a*c;
    T const ad = a*d;
    T const one = scalar_traits<T>::value(1);
    T const two = one+one;
    R r;
    mat_traits<R>::template write_element<0,0>(r) = one - two*(cc+dd);
    mat_traits<R>::template write_element<0,1>(r) = two*(bc-ad);
    mat_traits<R>::template write_element<0,2>(r) = two*(bd+ac);
    mat_traits<R>::template write_element<1,0>(r) = two*(bc+ad);
    mat_traits<R>::template write_element<1,1>(r) = one - two*(bb+dd);
    mat_traits<R>::template write_element<1,2>(r) = two*(cd-ab);
    mat_traits<R>::template write_element<2,0>(r) = two*(bd-ac);
    mat_traits<R>::template write_element<2,1>(r) = two*(cd+ab);
    mat_traits<R>::template write_element<2,2>(r) = one - two*(bb+cc);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct convert_to_m_defined;

    template <>
    struct
    convert_to_m_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<R>::rows==3 && mat_traits<A>::rows==3 &&
    mat_traits<R>::cols==1 && mat_traits<A>::cols==1,
    R>::type
convert_to( A const & a )
    {
    R r;
    mat_traits<R>::template write_element<0,0>(r) = mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<1,0>(r) = mat_traits<A>::template read_element<1,0>(a);
    mat_traits<R>::template write_element<2,0>(r) = mat_traits<A>::template read_element<2,0>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct convert_to_m_defined;

    template <>
    struct
    convert_to_m_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<R>::rows==1 && mat_traits<A>::rows==1 &&
    mat_traits<R>::cols==3 && mat_traits<A>::cols==3,
    R>::type
convert_to( A const & a )
    {
    R r;
    mat_traits<R>::template write_element<0,0>(r) = mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r) = mat_traits<A>::template read_element<0,1>(a);
    mat_traits<R>::template write_element<0,2>(r) = mat_traits<A>::template read_element<0,2>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct convert_to_m_defined;

    template <>
    struct
    convert_to_m_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    bool>::type
operator==( A const & a, B const & b )
    {
    return
        mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b) &&
        mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b) &&
        mat_traits<A>::template read_element<0,2>(a)==mat_traits<B>::template read_element<0,2>(b) &&
        mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b) &&
        mat_traits<A>::template read_element<1,1>(a)==mat_traits<B>::template read_element<1,1>(b) &&
        mat_traits<A>::template read_element<1,2>(a)==mat_traits<B>::template read_element<1,2>(b) &&
        mat_traits<A>::template read_element<2,0>(a)==mat_traits<B>::template read_element<2,0>(b) &&
        mat_traits<A>::template read_element<2,1>(a)==mat_traits<B>::template read_element<2,1>(b) &&
        mat_traits<A>::template read_element<2,2>(a)==mat_traits<B>::template read_element<2,2>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct eq_mm_defined;

    template <>
    struct
    eq_mm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    bool>::type
operator==( A const & a, B const & b )
    {
    return
        mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b) &&
        mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b) &&
        mat_traits<A>::template read_element<2,0>(a)==mat_traits<B>::template read_element<2,0>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct eq_mm_defined;

    template <>
    struct
    eq_mm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    bool>::type
operator==( A const & a, B const & b )
    {
    return
        mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b) &&
        mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b) &&
        mat_traits<A>::template read_element<0,2>(a)==mat_traits<B>::template read_element<0,2>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct eq_mm_defined;

    template <>
    struct
    eq_mm_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b)) ||
        !(mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b)) ||
        !(mat_traits<A>::template read_element<0,2>(a)==mat_traits<B>::template read_element<0,2>(b)) ||
        !(mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b)) ||
        !(mat_traits<A>::template read_element<1,1>(a)==mat_traits<B>::template read_element<1,1>(b)) ||
        !(mat_traits<A>::template read_element<1,2>(a)==mat_traits<B>::template read_element<1,2>(b)) ||
        !(mat_traits<A>::template read_element<2,0>(a)==mat_traits<B>::template read_element<2,0>(b)) ||
        !(mat_traits<A>::template read_element<2,1>(a)==mat_traits<B>::template read_element<2,1>(b)) ||
        !(mat_traits<A>::template read_element<2,2>(a)==mat_traits<B>::template read_element<2,2>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct neq_mm_defined;

    template <>
    struct
    neq_mm_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b)) ||
        !(mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b)) ||
        !(mat_traits<A>::template read_element<2,0>(a)==mat_traits<B>::template read_element<2,0>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct neq_mm_defined;

    template <>
    struct
    neq_mm_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b)) ||
        !(mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b)) ||
        !(mat_traits<A>::template read_element<0,2>(a)==mat_traits<B>::template read_element<0,2>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct neq_mm_defined;

    template <>
    struct
    neq_mm_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3,
    deduce_mat<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_mat<A>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=-mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r)=-mat_traits<A>::template read_element<0,1>(a);
    mat_traits<R>::template write_element<0,2>(r)=-mat_traits<A>::template read_element<0,2>(a);
    mat_traits<R>::template write_element<1,0>(r)=-mat_traits<A>::template read_element<1,0>(a);
    mat_traits<R>::template write_element<1,1>(r)=-mat_traits<A>::template read_element<1,1>(a);
    mat_traits<R>::template write_element<1,2>(r)=-mat_traits<A>::template read_element<1,2>(a);
    mat_traits<R>::template write_element<2,0>(r)=-mat_traits<A>::template read_element<2,0>(a);
    mat_traits<R>::template write_element<2,1>(r)=-mat_traits<A>::template read_element<2,1>(a);
    mat_traits<R>::template write_element<2,2>(r)=-mat_traits<A>::template read_element<2,2>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_m_defined;

    template <>
    struct
    minus_m_defined<3,3>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==1,
    deduce_mat<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_mat<A>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=-mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<1,0>(r)=-mat_traits<A>::template read_element<1,0>(a);
    mat_traits<R>::template write_element<2,0>(r)=-mat_traits<A>::template read_element<2,0>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_m_defined;

    template <>
    struct
    minus_m_defined<3,1>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==3,
    deduce_mat<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_mat<A>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=-mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r)=-mat_traits<A>::template read_element<0,1>(a);
    mat_traits<R>::template write_element<0,2>(r)=-mat_traits<A>::template read_element<0,2>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_m_defined;

    template <>
    struct
    minus_m_defined<1,3>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3,
    typename mat_traits<A>::scalar_type>::type
determinant( A const & a )
    {
    typedef typename mat_traits<A>::scalar_type T;
    T const a00=mat_traits<A>::template read_element<0,0>(a);
    T const a01=mat_traits<A>::template read_element<0,1>(a);
    T const a02=mat_traits<A>::template read_element<0,2>(a);
    T const a10=mat_traits<A>::template read_element<1,0>(a);
    T const a11=mat_traits<A>::template read_element<1,1>(a);
    T const a12=mat_traits<A>::template read_element<1,2>(a);
    T const a20=mat_traits<A>::template read_element<2,0>(a);
    T const a21=mat_traits<A>::template read_element<2,1>(a);
    T const a22=mat_traits<A>::template read_element<2,2>(a);
    T det=(a00*(a11*a22-a12*a21)-a01*(a10*a22-a12*a20)+a02*(a10*a21-a11*a20));
    return det;
    }

namespace
sfinae
    {
    using ::boost::qvm::determinant;
    }

namespace
qvm_detail
    {
    template <int D>
    struct determinant_defined;

    template <>
    struct
    determinant_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
inverse( A const & a, B det )
    {
    typedef typename mat_traits<A>::scalar_type T;
    BOOST_QVM_ASSERT(det!=scalar_traits<B>::value(0));
    T const a00=mat_traits<A>::template read_element<0,0>(a);
    T const a01=mat_traits<A>::template read_element<0,1>(a);
    T const a02=mat_traits<A>::template read_element<0,2>(a);
    T const a10=mat_traits<A>::template read_element<1,0>(a);
    T const a11=mat_traits<A>::template read_element<1,1>(a);
    T const a12=mat_traits<A>::template read_element<1,2>(a);
    T const a20=mat_traits<A>::template read_element<2,0>(a);
    T const a21=mat_traits<A>::template read_element<2,1>(a);
    T const a22=mat_traits<A>::template read_element<2,2>(a);
    T const f=scalar_traits<T>::value(1)/det;
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)= f*(a11*a22-a12*a21);
    mat_traits<R>::template write_element<0,1>(r)=-f*(a01*a22-a02*a21);
    mat_traits<R>::template write_element<0,2>(r)= f*(a01*a12-a02*a11);
    mat_traits<R>::template write_element<1,0>(r)=-f*(a10*a22-a12*a20);
    mat_traits<R>::template write_element<1,1>(r)= f*(a00*a22-a02*a20);
    mat_traits<R>::template write_element<1,2>(r)=-f*(a00*a12-a02*a10);
    mat_traits<R>::template write_element<2,0>(r)= f*(a10*a21-a11*a20);
    mat_traits<R>::template write_element<2,1>(r)=-f*(a00*a21-a01*a20);
    mat_traits<R>::template write_element<2,2>(r)= f*(a00*a11-a01*a10);
    return r;
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<A>::cols==3,
    deduce_mat<A> >::type
inverse( A const & a )
    {
    typedef typename mat_traits<A>::scalar_type T;
    T det=determinant(a);
    if( det==scalar_traits<T>::value(0) )
        BOOST_QVM_THROW_EXCEPTION(zero_determinant_error());
    return inverse(a,det);
    }

namespace
sfinae
    {
    using ::boost::qvm::inverse;
    }

namespace
qvm_detail
    {
    template <int D>
    struct inverse_m_defined;

    template <>
    struct
    inverse_m_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,3,3> >::type
operator*( A const & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Ta const a02 = mat_traits<A>::template read_element<0,2>(a);
    Ta const a10 = mat_traits<A>::template read_element<1,0>(a);
    Ta const a11 = mat_traits<A>::template read_element<1,1>(a);
    Ta const a12 = mat_traits<A>::template read_element<1,2>(a);
    Ta const a20 = mat_traits<A>::template read_element<2,0>(a);
    Ta const a21 = mat_traits<A>::template read_element<2,1>(a);
    Ta const a22 = mat_traits<A>::template read_element<2,2>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b01 = mat_traits<B>::template read_element<0,1>(b);
    Tb const b02 = mat_traits<B>::template read_element<0,2>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    Tb const b11 = mat_traits<B>::template read_element<1,1>(b);
    Tb const b12 = mat_traits<B>::template read_element<1,2>(b);
    Tb const b20 = mat_traits<B>::template read_element<2,0>(b);
    Tb const b21 = mat_traits<B>::template read_element<2,1>(b);
    Tb const b22 = mat_traits<B>::template read_element<2,2>(b);
    typedef typename deduce_mat2<A,B,3,3>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==3);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==3);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a00*b00+a01*b10+a02*b20;
    mat_traits<R>::template write_element<0,1>(r)=a00*b01+a01*b11+a02*b21;
    mat_traits<R>::template write_element<0,2>(r)=a00*b02+a01*b12+a02*b22;
    mat_traits<R>::template write_element<1,0>(r)=a10*b00+a11*b10+a12*b20;
    mat_traits<R>::template write_element<1,1>(r)=a10*b01+a11*b11+a12*b21;
    mat_traits<R>::template write_element<1,2>(r)=a10*b02+a11*b12+a12*b22;
    mat_traits<R>::template write_element<2,0>(r)=a20*b00+a21*b10+a22*b20;
    mat_traits<R>::template write_element<2,1>(r)=a20*b01+a21*b11+a22*b21;
    mat_traits<R>::template write_element<2,2>(r)=a20*b02+a21*b12+a22*b22;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int /*CR*/,int C>
    struct mul_mm_defined;

    template <>
    struct
    mul_mm_defined<3,3,3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    A &>::type
operator*=( A & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Ta const a02 = mat_traits<A>::template read_element<0,2>(a);
    Ta const a10 = mat_traits<A>::template read_element<1,0>(a);
    Ta const a11 = mat_traits<A>::template read_element<1,1>(a);
    Ta const a12 = mat_traits<A>::template read_element<1,2>(a);
    Ta const a20 = mat_traits<A>::template read_element<2,0>(a);
    Ta const a21 = mat_traits<A>::template read_element<2,1>(a);
    Ta const a22 = mat_traits<A>::template read_element<2,2>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b01 = mat_traits<B>::template read_element<0,1>(b);
    Tb const b02 = mat_traits<B>::template read_element<0,2>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    Tb const b11 = mat_traits<B>::template read_element<1,1>(b);
    Tb const b12 = mat_traits<B>::template read_element<1,2>(b);
    Tb const b20 = mat_traits<B>::template read_element<2,0>(b);
    Tb const b21 = mat_traits<B>::template read_element<2,1>(b);
    Tb const b22 = mat_traits<B>::template read_element<2,2>(b);
    mat_traits<A>::template write_element<0,0>(a)=a00*b00+a01*b10+a02*b20;
    mat_traits<A>::template write_element<0,1>(a)=a00*b01+a01*b11+a02*b21;
    mat_traits<A>::template write_element<0,2>(a)=a00*b02+a01*b12+a02*b22;
    mat_traits<A>::template write_element<1,0>(a)=a10*b00+a11*b10+a12*b20;
    mat_traits<A>::template write_element<1,1>(a)=a10*b01+a11*b11+a12*b21;
    mat_traits<A>::template write_element<1,2>(a)=a10*b02+a11*b12+a12*b22;
    mat_traits<A>::template write_element<2,0>(a)=a20*b00+a21*b10+a22*b20;
    mat_traits<A>::template write_element<2,1>(a)=a20*b01+a21*b11+a22*b21;
    mat_traits<A>::template write_element<2,2>(a)=a20*b02+a21*b12+a22*b22;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_eq_mm_defined;

    template <>
    struct
    mul_eq_mm_defined<3>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==3 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,3,1> >::type
operator*( A const & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Ta const a02 = mat_traits<A>::template read_element<0,2>(a);
    Ta const a10 = mat_traits<A>::template read_element<1,0>(a);
    Ta const a11 = mat_traits<A>::template read_element<1,1>(a);
    Ta const a12 = mat_traits<A>::template read_element<1,2>(a);
    Ta const a20 = mat_traits<A>::template read_element<2,0>(a);
    Ta const a21 = mat_traits<A>::template read_element<2,1>(a);
    Ta const a22 = mat_traits<A>::template read_element<2,2>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    Tb const b20 = mat_traits<B>::template read_element<2,0>(b);
    typedef typename deduce_mat2<A,B,3,1>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==3);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==1);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a00*b00+a01*b10+a02*b20;
    mat_traits<R>::template write_element<1,0>(r)=a10*b00+a11*b10+a12*b20;
    mat_traits<R>::template write_element<2,0>(r)=a20*b00+a21*b10+a22*b20;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int /*CR*/,int C>
    struct mul_mm_defined;

    template <>
    struct
    mul_mm_defined<3,3,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==3 &&
    mat_traits<A>::cols==3 && mat_traits<B>::cols==3,
    deduce_mat2<A,B,1,3> >::type
operator*( A const & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Ta const a02 = mat_traits<A>::template read_element<0,2>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b01 = mat_traits<B>::template read_element<0,1>(b);
    Tb const b02 = mat_traits<B>::template read_element<0,2>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    Tb const b11 = mat_traits<B>::template read_element<1,1>(b);
    Tb const b12 = mat_traits<B>::template read_element<1,2>(b);
    Tb const b20 = mat_traits<B>::template read_element<2,0>(b);
    Tb const b21 = mat_traits<B>::template read_element<2,1>(b);
    Tb const b22 = mat_traits<B>::template read_element<2,2>(b);
    typedef typename deduce_mat2<A,B,1,3>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==1);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==3);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a00*b00+a01*b10+a02*b20;
    mat_traits<R>::template write_element<0,1>(r)=a00*b01+a01*b11+a02*b21;
    mat_traits<R>::template write_element<0,2>(r)=a00*b02+a01*b12+a02*b22;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int /*CR*/,int C>
    struct mul_mm_defined;

    template <>
    struct
    mul_mm_defined<1,3,3>
        {
        static bool const value=true;
        };
    }

} }

#endif

/* mat_operations3.hpp
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
*/