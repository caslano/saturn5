#ifndef BOOST_QVM_GEN_VEC_OPERATIONS2_HPP_INCLUDED
#define BOOST_QVM_GEN_VEC_OPERATIONS2_HPP_INCLUDED

// Copyright 2008-2022 Emil Dotchevski and Reverge Studios, Inc.

// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// This file was generated by a program. Do not edit manually.

#include <boost/qvm/deduce_scalar.hpp>
#include <boost/qvm/deduce_vec.hpp>
#include <boost/qvm/error.hpp>
#include <boost/qvm/gen/vec_assign2.hpp>
#include <boost/qvm/math.hpp>
#include <boost/qvm/static_assert.hpp>
#include <boost/qvm/throw_exception.hpp>

namespace boost { namespace qvm {

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==2 && vec_traits<B>::dim==2,
    deduce_vec2<A,B,2> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_vec2<A,B,2>::type R;
    BOOST_QVM_STATIC_ASSERT(vec_traits<R>::dim==2);
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)+vec_traits<B>::template read_element<0>(b);
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)+vec_traits<B>::template read_element<1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int D>
    struct plus_vv_defined;

    template <>
    struct
    plus_vv_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==2 && vec_traits<B>::dim==2,
    deduce_vec2<A,B,2> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_vec2<A,B,2>::type R;
    BOOST_QVM_STATIC_ASSERT(vec_traits<R>::dim==2);
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)-vec_traits<B>::template read_element<0>(b);
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)-vec_traits<B>::template read_element<1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int D>
    struct minus_vv_defined;

    template <>
    struct
    minus_vv_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==2 && vec_traits<B>::dim==2,
    A &>::type
operator+=( A & a, B const & b )
    {
    vec_traits<A>::template write_element<0>(a)+=vec_traits<B>::template read_element<0>(b);
    vec_traits<A>::template write_element<1>(a)+=vec_traits<B>::template read_element<1>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct plus_eq_vv_defined;

    template <>
    struct
    plus_eq_vv_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==2 && vec_traits<B>::dim==2,
    A &>::type
operator-=( A & a, B const & b )
    {
    vec_traits<A>::template write_element<0>(a)-=vec_traits<B>::template read_element<0>(b);
    vec_traits<A>::template write_element<1>(a)-=vec_traits<B>::template read_element<1>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct minus_eq_vv_defined;

    template <>
    struct
    minus_eq_vv_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==2 && is_scalar<B>::value,
    deduce_vec2<A,B,vec_traits<A>::dim> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_vec2<A,B,vec_traits<A>::dim>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)*b;
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_vs_defined;

    template <>
    struct
    mul_vs_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && vec_traits<B>::dim==2,
    deduce_vec2<A,B,vec_traits<B>::dim> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_vec2<A,B,vec_traits<B>::dim>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=a*vec_traits<B>::template read_element<0>(b);
    vec_traits<R>::template write_element<1>(r)=a*vec_traits<B>::template read_element<1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_sv_defined;

    template <>
    struct
    mul_sv_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class  B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==2 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    vec_traits<A>::template write_element<0>(a)*=b;
    vec_traits<A>::template write_element<1>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_eq_vs_defined;

    template <>
    struct
    mul_eq_vs_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==2 && is_scalar<B>::value,
    deduce_vec2<A,B,vec_traits<A>::dim> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_vec2<A,B,vec_traits<A>::dim>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a)/b;
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int D>
    struct div_vs_defined;

    template <>
    struct
    div_vs_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class  B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==2 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    vec_traits<A>::template write_element<0>(a)/=b;
    vec_traits<A>::template write_element<1>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct div_eq_vs_defined;

    template <>
    struct
    div_eq_vs_defined<2>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    is_vec<A>::value &&
    vec_traits<R>::dim==2 && vec_traits<A>::dim==2,
    R>::type
convert_to( A const & a )
    {
    R r;
    vec_traits<R>::template write_element<0>(r)=vec_traits<A>::template read_element<0>(a);
    vec_traits<R>::template write_element<1>(r)=vec_traits<A>::template read_element<1>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int D>
    struct convert_to_v_defined;

    template <>
    struct
    convert_to_v_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==2 && vec_traits<B>::dim==2,
bool>::type
operator==( A const & a, B const & b )
    {
    return
        vec_traits<A>::template read_element<0>(a)==vec_traits<B>::template read_element<0>(b) &&
        vec_traits<A>::template read_element<1>(a)==vec_traits<B>::template read_element<1>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int D>
    struct eq_vv_defined;

    template <>
    struct
    eq_vv_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==2 && vec_traits<B>::dim==2,
bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(vec_traits<A>::template read_element<0>(a)==vec_traits<B>::template read_element<0>(b)) ||
        !(vec_traits<A>::template read_element<1>(a)==vec_traits<B>::template read_element<1>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct neq_vv_defined;

    template <>
    struct
    neq_vv_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==2,
    deduce_vec<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_vec<A>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=-vec_traits<A>::template read_element<0>(a);
    vec_traits<R>::template write_element<1>(r)=-vec_traits<A>::template read_element<1>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int D>
    struct minus_v_defined;

    template <>
    struct
    minus_v_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    is_vec<A>::value && vec_traits<A>::dim==2,
    typename vec_traits<A>::scalar_type>::type
mag( A const & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const m2=a0*a0+a1*a1;
    T const mag=sqrt(m2);
    return mag;
    }

namespace
sfinae
    {
    using ::boost::qvm::mag;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mag_v_defined;

    template <>
    struct
    mag_v_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    is_vec<A>::value && vec_traits<A>::dim==2,
    typename vec_traits<A>::scalar_type>::type
mag_sqr( A const & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const m2=a0*a0+a1*a1;
    return m2;
    }

namespace
sfinae
    {
    using ::boost::qvm::mag_sqr;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mag_sqr_v_defined;

    template <>
    struct
    mag_sqr_v_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==2,
    deduce_vec<A> >::type
normalized( A const & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const m2=a0*a0+a1*a1;
    if( m2==scalar_traits<typename vec_traits<A>::scalar_type>::value(0) )
        BOOST_QVM_THROW_EXCEPTION(zero_magnitude_error());
    T const rm=scalar_traits<T>::value(1)/sqrt(m2);
    typedef typename deduce_vec<A>::type R;
    R r;
    vec_traits<R>::template write_element<0>(r)=a0*rm;
    vec_traits<R>::template write_element<1>(r)=a1*rm;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::normalized;
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    vec_traits<A>::dim==2,
    void>::type
normalize( A & a )
    {
    typedef typename vec_traits<A>::scalar_type T;
    T const a0=vec_traits<A>::template read_element<0>(a);
    T const a1=vec_traits<A>::template read_element<1>(a);
    T const m2=a0*a0+a1*a1;
    if( m2==scalar_traits<typename vec_traits<A>::scalar_type>::value(0) )
        BOOST_QVM_THROW_EXCEPTION(zero_magnitude_error());
    T const rm=scalar_traits<T>::value(1)/sqrt(m2);
    vec_traits<A>::template write_element<0>(a)*=rm;
    vec_traits<A>::template write_element<1>(a)*=rm;
    }

namespace
sfinae
    {
    using ::boost::qvm::normalize;
    }

namespace
qvm_detail
    {
    template <int D>
    struct normalize_v_defined;

    template <>
    struct
    normalize_v_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    vec_traits<A>::dim==2 && vec_traits<B>::dim==2,
    deduce_scalar<typename vec_traits<A>::scalar_type,typename vec_traits<B>::scalar_type> >::type
dot( A const & a, B const & b )
    {
    typedef typename vec_traits<A>::scalar_type Ta;
    typedef typename vec_traits<B>::scalar_type Tb;
    typedef typename deduce_scalar<Ta,Tb>::type Tr;
    Ta const a0=vec_traits<A>::template read_element<0>(a);
    Ta const a1=vec_traits<A>::template read_element<1>(a);
    Tb const b0=vec_traits<B>::template read_element<0>(b);
    Tb const b1=vec_traits<B>::template read_element<1>(b);
    Tr const dot=a0*b0+a1*b1;
    return dot;
    }

namespace
sfinae
    {
    using ::boost::qvm::dot;
    }

namespace
qvm_detail
    {
    template <int D>
    struct dot_vv_defined;

    template <>
    struct
    dot_vv_defined<2>
        {
        static bool const value=true;
        };
    }

} }

#endif

/* vec_operations2.hpp
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
*/