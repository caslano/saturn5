#ifndef BOOST_QVM_GEN_MAT_OPERATIONS2_HPP_INCLUDED
#define BOOST_QVM_GEN_MAT_OPERATIONS2_HPP_INCLUDED

// Copyright 2008-2022 Emil Dotchevski and Reverge Studios, Inc.

// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// This file was generated by a program. Do not edit manually.

#include <boost/qvm/assert.hpp>
#include <boost/qvm/deduce_mat.hpp>
#include <boost/qvm/deduce_vec.hpp>
#include <boost/qvm/error.hpp>
#include <boost/qvm/gen/mat_assign2.hpp>
#include <boost/qvm/throw_exception.hpp>

namespace boost { namespace qvm {

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,2,2> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,2,2>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==2);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==2);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)+mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)+mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)+mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)+mat_traits<B>::template read_element<1,1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_mm_defined;

    template <>
    struct
    plus_mm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,2,1> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,2,1>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==2);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==1);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)+mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)+mat_traits<B>::template read_element<1,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_mm_defined;

    template <>
    struct
    plus_mm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,1,2> >::type
operator+( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,1,2>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==1);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==2);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)+mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)+mat_traits<B>::template read_element<0,1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_mm_defined;

    template <>
    struct
    plus_mm_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,2,2> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,2,2>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==2);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==2);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)-mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)-mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)-mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)-mat_traits<B>::template read_element<1,1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_mm_defined;

    template <>
    struct
    minus_mm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,2,1> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,2,1>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==2);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==1);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)-mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)-mat_traits<B>::template read_element<1,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_mm_defined;

    template <>
    struct
    minus_mm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,1,2> >::type
operator-( A const & a, B const & b )
    {
    typedef typename deduce_mat2<A,B,1,2>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==1);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==2);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)-mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)-mat_traits<B>::template read_element<0,1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_mm_defined;

    template <>
    struct
    minus_mm_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    A &>::type
operator+=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)+=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)+=mat_traits<B>::template read_element<0,1>(b);
    mat_traits<A>::template write_element<1,0>(a)+=mat_traits<B>::template read_element<1,0>(b);
    mat_traits<A>::template write_element<1,1>(a)+=mat_traits<B>::template read_element<1,1>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_eq_mm_defined;

    template <>
    struct
    plus_eq_mm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    A &>::type
operator+=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)+=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<1,0>(a)+=mat_traits<B>::template read_element<1,0>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_eq_mm_defined;

    template <>
    struct
    plus_eq_mm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    A &>::type
operator+=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)+=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)+=mat_traits<B>::template read_element<0,1>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator+=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct plus_eq_mm_defined;

    template <>
    struct
    plus_eq_mm_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    A &>::type
operator-=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)-=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)-=mat_traits<B>::template read_element<0,1>(b);
    mat_traits<A>::template write_element<1,0>(a)-=mat_traits<B>::template read_element<1,0>(b);
    mat_traits<A>::template write_element<1,1>(a)-=mat_traits<B>::template read_element<1,1>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_eq_mm_defined;

    template <>
    struct
    minus_eq_mm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    A &>::type
operator-=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)-=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<1,0>(a)-=mat_traits<B>::template read_element<1,0>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_eq_mm_defined;

    template <>
    struct
    minus_eq_mm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    A &>::type
operator-=( A & a, B const & b )
    {
    mat_traits<A>::template write_element<0,0>(a)-=mat_traits<B>::template read_element<0,0>(b);
    mat_traits<A>::template write_element<0,1>(a)-=mat_traits<B>::template read_element<0,1>(b);
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_eq_mm_defined;

    template <>
    struct
    minus_eq_mm_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)*b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)*b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)*b;
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_ms_defined;

    template <>
    struct
    mul_ms_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a*mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=a*mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<1,0>(r)=a*mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=a*mat_traits<B>::template read_element<1,1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_sm_defined;

    template <>
    struct
    mul_sm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)*b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_ms_defined;

    template <>
    struct
    mul_ms_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==2 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a*mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=a*mat_traits<B>::template read_element<1,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_sm_defined;

    template <>
    struct
    mul_sm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator*( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)*b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)*b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_ms_defined;

    template <>
    struct
    mul_ms_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==1 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator*( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a*mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=a*mat_traits<B>::template read_element<0,1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_sm_defined;

    template <>
    struct
    mul_sm_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)*=b;
    mat_traits<A>::template write_element<0,1>(a)*=b;
    mat_traits<A>::template write_element<1,0>(a)*=b;
    mat_traits<A>::template write_element<1,1>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_eq_ms_defined;

    template <>
    struct
    mul_eq_ms_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)*=b;
    mat_traits<A>::template write_element<1,0>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_eq_ms_defined;

    template <>
    struct
    mul_eq_ms_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    A &>::type
operator*=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)*=b;
    mat_traits<A>::template write_element<0,1>(a)*=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct mul_eq_ms_defined;

    template <>
    struct
    mul_eq_ms_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)/b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)/b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)/b;
    mat_traits<R>::template write_element<1,1>(r)=mat_traits<A>::template read_element<1,1>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_ms_defined;

    template <>
    struct
    div_ms_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator/( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a/mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<0,1>(r)=a/mat_traits<B>::template read_element<0,1>(b);
    mat_traits<R>::template write_element<1,0>(r)=a/mat_traits<B>::template read_element<1,0>(b);
    mat_traits<R>::template write_element<1,1>(r)=a/mat_traits<B>::template read_element<1,1>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_sm_defined;

    template <>
    struct
    div_sm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)/b;
    mat_traits<R>::template write_element<1,0>(r)=mat_traits<A>::template read_element<1,0>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_ms_defined;

    template <>
    struct
    div_ms_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    is_scalar<A>::value && mat_traits<B>::rows==2 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols> >::type
operator/( A a, B const & b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<B>::rows,mat_traits<B>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a/mat_traits<B>::template read_element<0,0>(b);
    mat_traits<R>::template write_element<1,0>(r)=a/mat_traits<B>::template read_element<1,0>(b);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_sm_defined;

    template <>
    struct
    div_sm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
operator/( A const & a, B b )
    {
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=mat_traits<A>::template read_element<0,0>(a)/b;
    mat_traits<R>::template write_element<0,1>(r)=mat_traits<A>::template read_element<0,1>(a)/b;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_ms_defined;

    template <>
    struct
    div_ms_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)/=b;
    mat_traits<A>::template write_element<0,1>(a)/=b;
    mat_traits<A>::template write_element<1,0>(a)/=b;
    mat_traits<A>::template write_element<1,1>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_eq_ms_defined;

    template <>
    struct
    div_eq_ms_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==1 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)/=b;
    mat_traits<A>::template write_element<1,0>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_eq_ms_defined;

    template <>
    struct
    div_eq_ms_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    A &>::type
operator/=( A & a, B b )
    {
    mat_traits<A>::template write_element<0,0>(a)/=b;
    mat_traits<A>::template write_element<0,1>(a)/=b;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator/=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct div_eq_ms_defined;

    template <>
    struct
    div_eq_ms_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<R>::rows==2 && mat_traits<A>::rows==2 &&
    mat_traits<R>::cols==2 && mat_traits<A>::cols==2,
    R>::type
convert_to( A const & a )
    {
    R r;
    mat_traits<R>::template write_element<0,0>(r) = mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r) = mat_traits<A>::template read_element<0,1>(a);
    mat_traits<R>::template write_element<1,0>(r) = mat_traits<A>::template read_element<1,0>(a);
    mat_traits<R>::template write_element<1,1>(r) = mat_traits<A>::template read_element<1,1>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct convert_to_m_defined;

    template <>
    struct
    convert_to_m_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<R>::rows==2 && mat_traits<A>::rows==2 &&
    mat_traits<R>::cols==1 && mat_traits<A>::cols==1,
    R>::type
convert_to( A const & a )
    {
    R r;
    mat_traits<R>::template write_element<0,0>(r) = mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<1,0>(r) = mat_traits<A>::template read_element<1,0>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct convert_to_m_defined;

    template <>
    struct
    convert_to_m_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class R,class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<R>::rows==1 && mat_traits<A>::rows==1 &&
    mat_traits<R>::cols==2 && mat_traits<A>::cols==2,
    R>::type
convert_to( A const & a )
    {
    R r;
    mat_traits<R>::template write_element<0,0>(r) = mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r) = mat_traits<A>::template read_element<0,1>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::convert_to;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct convert_to_m_defined;

    template <>
    struct
    convert_to_m_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    bool>::type
operator==( A const & a, B const & b )
    {
    return
        mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b) &&
        mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b) &&
        mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b) &&
        mat_traits<A>::template read_element<1,1>(a)==mat_traits<B>::template read_element<1,1>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct eq_mm_defined;

    template <>
    struct
    eq_mm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    bool>::type
operator==( A const & a, B const & b )
    {
    return
        mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b) &&
        mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct eq_mm_defined;

    template <>
    struct
    eq_mm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    bool>::type
operator==( A const & a, B const & b )
    {
    return
        mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b) &&
        mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b);
    }

namespace
sfinae
    {
    using ::boost::qvm::operator==;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct eq_mm_defined;

    template <>
    struct
    eq_mm_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b)) ||
        !(mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b)) ||
        !(mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b)) ||
        !(mat_traits<A>::template read_element<1,1>(a)==mat_traits<B>::template read_element<1,1>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct neq_mm_defined;

    template <>
    struct
    neq_mm_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==1 && mat_traits<B>::cols==1,
    bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b)) ||
        !(mat_traits<A>::template read_element<1,0>(a)==mat_traits<B>::template read_element<1,0>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct neq_mm_defined;

    template <>
    struct
    neq_mm_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==1 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    bool>::type
operator!=( A const & a, B const & b )
    {
    return
        !(mat_traits<A>::template read_element<0,0>(a)==mat_traits<B>::template read_element<0,0>(b)) ||
        !(mat_traits<A>::template read_element<0,1>(a)==mat_traits<B>::template read_element<0,1>(b));
    }

namespace
sfinae
    {
    using ::boost::qvm::operator!=;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct neq_mm_defined;

    template <>
    struct
    neq_mm_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2,
    deduce_mat<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_mat<A>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=-mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r)=-mat_traits<A>::template read_element<0,1>(a);
    mat_traits<R>::template write_element<1,0>(r)=-mat_traits<A>::template read_element<1,0>(a);
    mat_traits<R>::template write_element<1,1>(r)=-mat_traits<A>::template read_element<1,1>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_m_defined;

    template <>
    struct
    minus_m_defined<2,2>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==1,
    deduce_mat<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_mat<A>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=-mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<1,0>(r)=-mat_traits<A>::template read_element<1,0>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_m_defined;

    template <>
    struct
    minus_m_defined<2,1>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<A>::cols==2,
    deduce_mat<A> >::type
operator-( A const & a )
    {
    typedef typename deduce_mat<A>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)=-mat_traits<A>::template read_element<0,0>(a);
    mat_traits<R>::template write_element<0,1>(r)=-mat_traits<A>::template read_element<0,1>(a);
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator-;
    }

namespace
qvm_detail
    {
    template <int R,int C>
    struct minus_m_defined;

    template <>
    struct
    minus_m_defined<1,2>
        {
        static bool const value=true;
        };
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2,
    typename mat_traits<A>::scalar_type>::type
determinant( A const & a )
    {
    typedef typename mat_traits<A>::scalar_type T;
    T const a00=mat_traits<A>::template read_element<0,0>(a);
    T const a01=mat_traits<A>::template read_element<0,1>(a);
    T const a10=mat_traits<A>::template read_element<1,0>(a);
    T const a11=mat_traits<A>::template read_element<1,1>(a);
    T det=(a00*a11-a01*a10);
    return det;
    }

namespace
sfinae
    {
    using ::boost::qvm::determinant;
    }

namespace
qvm_detail
    {
    template <int D>
    struct determinant_defined;

    template <>
    struct
    determinant_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2 && is_scalar<B>::value,
    deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols> >::type
inverse( A const & a, B det )
    {
    typedef typename mat_traits<A>::scalar_type T;
    BOOST_QVM_ASSERT(det!=scalar_traits<B>::value(0));
    T const a00=mat_traits<A>::template read_element<0,0>(a);
    T const a01=mat_traits<A>::template read_element<0,1>(a);
    T const a10=mat_traits<A>::template read_element<1,0>(a);
    T const a11=mat_traits<A>::template read_element<1,1>(a);
    T const f=scalar_traits<T>::value(1)/det;
    typedef typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type R;
    R r;
    mat_traits<R>::template write_element<0,0>(r)= f*a11;
    mat_traits<R>::template write_element<0,1>(r)=-f*a01;
    mat_traits<R>::template write_element<1,0>(r)=-f*a10;
    mat_traits<R>::template write_element<1,1>(r)= f*a00;
    return r;
    }

template <class A>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<A>::cols==2,
    deduce_mat<A> >::type
inverse( A const & a )
    {
    typedef typename mat_traits<A>::scalar_type T;
    T det=determinant(a);
    if( det==scalar_traits<T>::value(0) )
        BOOST_QVM_THROW_EXCEPTION(zero_determinant_error());
    return inverse(a,det);
    }

namespace
sfinae
    {
    using ::boost::qvm::inverse;
    }

namespace
qvm_detail
    {
    template <int D>
    struct inverse_m_defined;

    template <>
    struct
    inverse_m_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,2,2> >::type
operator*( A const & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Ta const a10 = mat_traits<A>::template read_element<1,0>(a);
    Ta const a11 = mat_traits<A>::template read_element<1,1>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b01 = mat_traits<B>::template read_element<0,1>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    Tb const b11 = mat_traits<B>::template read_element<1,1>(b);
    typedef typename deduce_mat2<A,B,2,2>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==2);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==2);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a00*b00+a01*b10;
    mat_traits<R>::template write_element<0,1>(r)=a00*b01+a01*b11;
    mat_traits<R>::template write_element<1,0>(r)=a10*b00+a11*b10;
    mat_traits<R>::template write_element<1,1>(r)=a10*b01+a11*b11;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int /*CR*/,int C>
    struct mul_mm_defined;

    template <>
    struct
    mul_mm_defined<2,2,2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    A &>::type
operator*=( A & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Ta const a10 = mat_traits<A>::template read_element<1,0>(a);
    Ta const a11 = mat_traits<A>::template read_element<1,1>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b01 = mat_traits<B>::template read_element<0,1>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    Tb const b11 = mat_traits<B>::template read_element<1,1>(b);
    mat_traits<A>::template write_element<0,0>(a)=a00*b00+a01*b10;
    mat_traits<A>::template write_element<0,1>(a)=a00*b01+a01*b11;
    mat_traits<A>::template write_element<1,0>(a)=a10*b00+a11*b10;
    mat_traits<A>::template write_element<1,1>(a)=a10*b01+a11*b11;
    return a;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*=;
    }

namespace
qvm_detail
    {
    template <int D>
    struct mul_eq_mm_defined;

    template <>
    struct
    mul_eq_mm_defined<2>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==2 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==1,
    deduce_mat2<A,B,2,1> >::type
operator*( A const & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Ta const a10 = mat_traits<A>::template read_element<1,0>(a);
    Ta const a11 = mat_traits<A>::template read_element<1,1>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    typedef typename deduce_mat2<A,B,2,1>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==2);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==1);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a00*b00+a01*b10;
    mat_traits<R>::template write_element<1,0>(r)=a10*b00+a11*b10;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int /*CR*/,int C>
    struct mul_mm_defined;

    template <>
    struct
    mul_mm_defined<2,2,1>
        {
        static bool const value=true;
        };
    }

template <class A,class B>
BOOST_QVM_CONSTEXPR BOOST_QVM_INLINE_OPERATIONS
typename lazy_enable_if_c<
    mat_traits<A>::rows==1 && mat_traits<B>::rows==2 &&
    mat_traits<A>::cols==2 && mat_traits<B>::cols==2,
    deduce_mat2<A,B,1,2> >::type
operator*( A const & a, B const & b )
    {
    typedef typename mat_traits<A>::scalar_type Ta;
    typedef typename mat_traits<B>::scalar_type Tb;
    Ta const a00 = mat_traits<A>::template read_element<0,0>(a);
    Ta const a01 = mat_traits<A>::template read_element<0,1>(a);
    Tb const b00 = mat_traits<B>::template read_element<0,0>(b);
    Tb const b01 = mat_traits<B>::template read_element<0,1>(b);
    Tb const b10 = mat_traits<B>::template read_element<1,0>(b);
    Tb const b11 = mat_traits<B>::template read_element<1,1>(b);
    typedef typename deduce_mat2<A,B,1,2>::type R;
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::rows==1);
    BOOST_QVM_STATIC_ASSERT(mat_traits<R>::cols==2);
    R r;
    mat_traits<R>::template write_element<0,0>(r)=a00*b00+a01*b10;
    mat_traits<R>::template write_element<0,1>(r)=a00*b01+a01*b11;
    return r;
    }

namespace
sfinae
    {
    using ::boost::qvm::operator*;
    }

namespace
qvm_detail
    {
    template <int R,int /*CR*/,int C>
    struct mul_mm_defined;

    template <>
    struct
    mul_mm_defined<1,2,2>
        {
        static bool const value=true;
        };
    }

} }

#endif

/* mat_operations2.hpp
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
*/