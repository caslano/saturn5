//  (C) Copyright Jeremy Siek 1999-2001.
//  Copyright (C) 2006 Trustees of Indiana University
//  Authors: Douglas Gregor and Jeremy Siek

// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

//  See http://www.boost.org/libs/property_map for documentation.

#ifndef BOOST_PROPERTY_MAP_PARALLEL_PROPERTY_MAPS_HPP
#define BOOST_PROPERTY_MAP_PARALLEL_PROPERTY_MAPS_HPP

// Parallel property maps moved over from <boost/property_map/property_map.hpp>
// as part of refactoring out all parallel code from sequential property map
// library.

#include <boost/assert.hpp>
#include <boost/config.hpp>
#include <boost/static_assert.hpp>
#include <cstddef>
#include <boost/detail/iterator.hpp>
#include <boost/concept_archetype.hpp>
#include <boost/mpl/assert.hpp>
#include <boost/mpl/or.hpp>
#include <boost/mpl/and.hpp>
#include <boost/mpl/has_xxx.hpp>
#include <boost/type_traits/is_same.hpp>
#include <boost/property_map/property_map.hpp>

#include <boost/property_map/parallel/distributed_property_map.hpp>
#include <boost/property_map/parallel/local_property_map.hpp>

namespace boost {
/** Distributed iterator property map.
 *
 * This specialization of @ref iterator_property_map builds a
 * distributed iterator property map given the local index maps
 * generated by distributed graph types that automatically have index
 * properties. 
 *
 * This specialization is useful when creating external distributed
 * property maps via the same syntax used to create external
 * sequential property maps.
 */
template<typename RandomAccessIterator, typename ProcessGroup,
         typename GlobalMap, typename StorageMap, 
         typename ValueType, typename Reference>
class iterator_property_map
        <RandomAccessIterator, 
         local_property_map<ProcessGroup, GlobalMap, StorageMap>,
         ValueType, Reference>
  : public parallel::distributed_property_map
             <ProcessGroup, 
              GlobalMap, 
              iterator_property_map<RandomAccessIterator, StorageMap,
                                    ValueType, Reference> >
{
  typedef iterator_property_map<RandomAccessIterator, StorageMap, 
                                ValueType, Reference> local_iterator_map;

  typedef parallel::distributed_property_map<ProcessGroup, GlobalMap,
                                             local_iterator_map> inherited;

  typedef local_property_map<ProcessGroup, GlobalMap, StorageMap>
    index_map_type;
  typedef iterator_property_map self_type;

public:
  iterator_property_map() { }

  iterator_property_map(RandomAccessIterator cc, const index_map_type& id)
    : inherited(id.process_group(), id.global(), 
                local_iterator_map(cc, id.base())) { }
};

/** Distributed iterator property map.
 *
 * This specialization of @ref iterator_property_map builds a
 * distributed iterator property map given a distributed index
 * map. Only the local portion of the distributed index property map
 * is utilized.
 *
 * This specialization is useful when creating external distributed
 * property maps via the same syntax used to create external
 * sequential property maps.
 */
template<typename RandomAccessIterator, typename ProcessGroup,
         typename GlobalMap, typename StorageMap, 
         typename ValueType, typename Reference>
class iterator_property_map<
        RandomAccessIterator, 
        parallel::distributed_property_map<ProcessGroup,GlobalMap,StorageMap>,
        ValueType, Reference
      >
  : public parallel::distributed_property_map
             <ProcessGroup, 
              GlobalMap,
              iterator_property_map<RandomAccessIterator, StorageMap,
                                    ValueType, Reference> >
{
  typedef iterator_property_map<RandomAccessIterator, StorageMap,
                                ValueType, Reference> local_iterator_map;

  typedef parallel::distributed_property_map<ProcessGroup, GlobalMap,
                                             local_iterator_map> inherited;

  typedef parallel::distributed_property_map<ProcessGroup, GlobalMap, 
                                             StorageMap>
    index_map_type;

public:
  iterator_property_map() { }

  iterator_property_map(RandomAccessIterator cc, const index_map_type& id)
    : inherited(id.process_group(), id.global(),
                local_iterator_map(cc, id.base())) { }
};

namespace parallel {
// Generate an iterator property map with a specific kind of ghost
// cells
template<typename RandomAccessIterator, typename ProcessGroup,
         typename GlobalMap, typename StorageMap>
distributed_property_map<ProcessGroup, 
                         GlobalMap,
                         iterator_property_map<RandomAccessIterator, 
                                               StorageMap> >
make_iterator_property_map(RandomAccessIterator cc,
                           local_property_map<ProcessGroup, GlobalMap, 
                                              StorageMap> index_map)
{
  typedef distributed_property_map<
            ProcessGroup, GlobalMap,
            iterator_property_map<RandomAccessIterator, StorageMap> >
    result_type;
  return result_type(index_map.process_group(), index_map.global(),
                     make_iterator_property_map(cc, index_map.base()));
}

} // end namespace parallel

/** Distributed safe iterator property map.
 *
 * This specialization of @ref safe_iterator_property_map builds a
 * distributed iterator property map given the local index maps
 * generated by distributed graph types that automatically have index
 * properties. 
 *
 * This specialization is useful when creating external distributed
 * property maps via the same syntax used to create external
 * sequential property maps.
 */
template<typename RandomAccessIterator, typename ProcessGroup,
         typename GlobalMap, typename StorageMap, typename ValueType,
         typename Reference>
class safe_iterator_property_map
        <RandomAccessIterator, 
         local_property_map<ProcessGroup, GlobalMap, StorageMap>,
         ValueType, Reference>
  : public parallel::distributed_property_map
             <ProcessGroup, 
              GlobalMap,
              safe_iterator_property_map<RandomAccessIterator, StorageMap,
                                         ValueType, Reference> >
{
  typedef safe_iterator_property_map<RandomAccessIterator, StorageMap, 
                                     ValueType, Reference> local_iterator_map;

  typedef parallel::distributed_property_map<ProcessGroup, GlobalMap,
                                             local_iterator_map> inherited;

  typedef local_property_map<ProcessGroup, GlobalMap, StorageMap> index_map_type;

public:
  safe_iterator_property_map() { }

  safe_iterator_property_map(RandomAccessIterator cc, std::size_t n, 
                             const index_map_type& id)
    : inherited(id.process_group(), id.global(),
                local_iterator_map(cc, n, id.base())) { }
};

/** Distributed safe iterator property map.
 *
 * This specialization of @ref safe_iterator_property_map builds a
 * distributed iterator property map given a distributed index
 * map. Only the local portion of the distributed index property map
 * is utilized.
 *
 * This specialization is useful when creating external distributed
 * property maps via the same syntax used to create external
 * sequential property maps.
 */
template<typename RandomAccessIterator, typename ProcessGroup,
         typename GlobalMap, typename StorageMap, 
         typename ValueType, typename Reference>
class safe_iterator_property_map<
        RandomAccessIterator, 
        parallel::distributed_property_map<ProcessGroup,GlobalMap,StorageMap>,
        ValueType, Reference>
  : public parallel::distributed_property_map
             <ProcessGroup, 
              GlobalMap,
              safe_iterator_property_map<RandomAccessIterator, StorageMap,
                                         ValueType, Reference> >
{
  typedef safe_iterator_property_map<RandomAccessIterator, StorageMap,
                                     ValueType, Reference> local_iterator_map;

  typedef parallel::distributed_property_map<ProcessGroup, GlobalMap,
                                             local_iterator_map> inherited;

  typedef parallel::distributed_property_map<ProcessGroup, GlobalMap, 
                                             StorageMap>
    index_map_type;

public:
  safe_iterator_property_map() { }

  safe_iterator_property_map(RandomAccessIterator cc, std::size_t n, 
                             const index_map_type& id)
    : inherited(id.process_group(), id.global(), 
                local_iterator_map(cc, n, id.base())) { }
};                                            

}

#include <boost/property_map/vector_property_map.hpp>

#endif /* BOOST_PROPERTY_MAP_PARALLEL_PROPERTY_MAPS_HPP */


/* parallel_property_maps.hpp
bHQUedz+gPIIPudEKYq0pWIPZWQfexRkyLZmKvwcROl3Pz+ywzvoY4eUkGxvcukRe501Um/UheodPt8oJ3iUdYNaHY1cO6YhjN9rBj6qveRw1tFOR9f13a2TwR9V163X6vwB54gUd+VIM4yqc5fdOWb/6O/LgwGJGfTvpaG/4cAEmI1FiSn23GWZubb0dKPZtEHdvDjWZDKGLmdx357R+2akG9OXZS3JzTWZjXkudXGK2bQ4JXRQ4uIUb9AfWJyyFl/aM22LU0rLK72OwOLYDOvilFB789je+GWj2rMbrblZubnpSy3ovKRSdQRUv1rpdnhEiqU8ZuroY8x2Y7Z5mc2cZcowmkOHoEcelFIW9K5VK9G524Nv3aUgIN2naD5oHd1Wao7VlGWzmZeg+9EdK8piTd780fvbjFZzjsmeY7IZV8ru0pUc5NX6aDuh3D3GajQvybWk25ZlGP1qoGh0N+/h/p2j909fYrRnLM00m7OzpZNRegXKF6cE/Vp/bm0+Byyjjk82Z9ugky3LGFCrApo+Xs0fnWPGMsOYbjVZMzCU9pD7oYfQrJaolQF3qbtkZGzdZfgWLYWm1Ijb4mwnbt2oPpOylljM9nT0aWaHgXQtHo3uL91izFmam27OXZaldVgexP/M6LPcqYrV+DWZSzX9YueO6mtBZqZ9qS073WSEUHdHX9Nv75v0W7okw25alp5rXDJiE5vcAdfilPyUxIWrn16cghbUMn8o3sjYOoyM1XL/d9QcZpvNZrt1mdk46pAxNnpyTL8m4zKLNQe62jGHJQHsDt0qy70hPctK3evEbt40oSmavuOfG61vrtVsNpmxQ5nDq5b7AmP1nTh6X3O6McMMk87JtRhXOyrd5UH/m2YTbeD/WpBVFNMcTd/R8i8wW7OyM3KsucbQwf/Q5xD31fpclm3OSM/MsP7TPmk9o/vUxjjKOqqdhUuyllqtOUuWGUtcaskGV7lfM95Srd+po/dPtxsz05faMkwYY3PoiDf16nUE0BBkuduS1m8a2+HcZi1LN+VmW5ZIx6rX4X5T/LFYx85tTrrJtizbbv33/Y5qSLk7t67RbS2w5C5ZkmvPypCu3b6x4+yzjh1na4Y5y5abbvv3/bp9DqezEp0atT53jm5nvjk9a8mSZTYTYl7I3aTLO/7aPGaMs43wNIvFtMSKve8E9ZTFCxenONVSR9ATGAn30kalNr5Hx8yreZnZbMlYlinnl7tdKos1PdtH7w/1lmbn5KRnm5aO9Ilj/lPHd+LEk8ooPW2W9ByzzWQ3+t3r7phwucypPJMyek6tudk5cDL4q3tdmSMQrMSQ+hyVDq8aUCslCpYtfnqjiEJ/naflP6Plz4E7ZObmZC4xYs8StcgXXDvqtKpq/Q+Nmdtsoz3LZLZZMrOMS0JHMRAvUzdLjPAFAyEZ/G4nwzPautv/RNuYc1SWybYkx5SbZSxTq8aecBSlXBvzGNvo/jHmtlzrMkuGxZhdVlKphhYj6ChYWSn/GG1ofjVkW3fOp6PbWZhtt6dnmNPhwx4cul4tCbDjSq3f/NH7Z+Qa09PtSzOXZJiN5lCKBfN1eDzU3ldZ7nKvdQdUJ6IH5gAN3p3roYIxc71kqclizjYb1zqcmG7p1KP12TSmzyyjxZZuw2znGM3llZVBHxT0OEaSl80h/cpLxyhsVO6sn1ZMHdVnojnHnpOOXo3a2Aa083nqc2PP53BaOHpuhtFUhvn0B32+8soRrZzudao/oB1fOl/Lz0bLm46cy2xamm2zGv3BtaEhLXI5/K6ico9T86McLYbb3mRT5mx7VqY5UzvXhg5Z6A9s9qjwpFjkCRmhYiksy+8PhqwcDYcEoRy4nzk=
*/