/*=============================================================================
    Copyright (c) 2001-2007 Joel de Guzman
    Copyright (c) 2016 Kohei Takahashi

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
==============================================================================*/
namespace boost { namespace phoenix { namespace detail { namespace tag { struct function_eval {}; template <typename Ostream> inline Ostream &operator<<( Ostream & os , function_eval) { os << "function_eval"; return os; } } namespace expression { template < typename A0 = void , typename A1 = void , typename A2 = void , typename A3 = void , typename A4 = void , typename A5 = void , typename A6 = void , typename A7 = void , typename A8 = void , typename A9 = void , typename Dummy = void > struct function_eval; template < typename A0 , typename A1 > struct function_eval< A0 , A1 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 > {}; template < typename A0 , typename A1 , typename A2 > struct function_eval< A0 , A1 , A2 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 > {}; template < typename A0 , typename A1 , typename A2 , typename A3 > struct function_eval< A0 , A1 , A2 , A3 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 , A3 > {}; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > struct function_eval< A0 , A1 , A2 , A3 , A4 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 , A3 , A4 > {}; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > struct function_eval< A0 , A1 , A2 , A3 , A4 , A5 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 , A3 , A4 , A5 > {}; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > struct function_eval< A0 , A1 , A2 , A3 , A4 , A5 , A6 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 , A3 , A4 , A5 , A6 > {}; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 > struct function_eval< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 > {}; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8 > struct function_eval< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 > {}; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8 , typename A9 > struct function_eval< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 > : boost::phoenix::expr< tag:: function_eval , A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 > {}; } namespace rule { struct function_eval : expression:: function_eval < meta_grammar , boost::proto::vararg< meta_grammar > > {}; } namespace functional { typedef boost::proto::functional::make_expr< tag:: function_eval > make_function_eval; } namespace result_of { template <typename A0 = void , typename A1 = void , typename A2 = void , typename A3 = void , typename A4 = void , typename A5 = void , typename A6 = void , typename A7 = void , typename A8 = void, typename Dummy = void> struct make_function_eval; template <typename A0> struct make_function_eval <A0> : boost::result_of< functional:: make_function_eval( A0 ) > {}; template <typename A0 , typename A1> struct make_function_eval <A0 , A1> : boost::result_of< functional:: make_function_eval( A0 , A1 ) > {}; template <typename A0 , typename A1 , typename A2> struct make_function_eval <A0 , A1 , A2> : boost::result_of< functional:: make_function_eval( A0 , A1 , A2 ) > {}; template <typename A0 , typename A1 , typename A2 , typename A3> struct make_function_eval <A0 , A1 , A2 , A3> : boost::result_of< functional:: make_function_eval( A0 , A1 , A2 , A3 ) > {}; template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4> struct make_function_eval <A0 , A1 , A2 , A3 , A4> : boost::result_of< functional:: make_function_eval( A0 , A1 , A2 , A3 , A4 ) > {}; template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> struct make_function_eval <A0 , A1 , A2 , A3 , A4 , A5> : boost::result_of< functional:: make_function_eval( A0 , A1 , A2 , A3 , A4 , A5 ) > {}; template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> struct make_function_eval <A0 , A1 , A2 , A3 , A4 , A5 , A6> : boost::result_of< functional:: make_function_eval( A0 , A1 , A2 , A3 , A4 , A5 , A6 ) > {}; template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7> struct make_function_eval <A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7> : boost::result_of< functional:: make_function_eval( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 ) > {}; } template <typename A0> inline typename result_of:: make_function_eval< A0 >::type make_function_eval(A0 const& a0) { return functional::make_function_eval()(a0); } template <typename A0 , typename A1> inline typename result_of:: make_function_eval< A0 , A1 >::type make_function_eval(A0 const& a0 , A1 const& a1) { return functional::make_function_eval()(a0 , a1); } template <typename A0 , typename A1 , typename A2> inline typename result_of:: make_function_eval< A0 , A1 , A2 >::type make_function_eval(A0 const& a0 , A1 const& a1 , A2 const& a2) { return functional::make_function_eval()(a0 , a1 , a2); } template <typename A0 , typename A1 , typename A2 , typename A3> inline typename result_of:: make_function_eval< A0 , A1 , A2 , A3 >::type make_function_eval(A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) { return functional::make_function_eval()(a0 , a1 , a2 , a3); } template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4> inline typename result_of:: make_function_eval< A0 , A1 , A2 , A3 , A4 >::type make_function_eval(A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) { return functional::make_function_eval()(a0 , a1 , a2 , a3 , a4); } template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> inline typename result_of:: make_function_eval< A0 , A1 , A2 , A3 , A4 , A5 >::type make_function_eval(A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5) { return functional::make_function_eval()(a0 , a1 , a2 , a3 , a4 , a5); } template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> inline typename result_of:: make_function_eval< A0 , A1 , A2 , A3 , A4 , A5 , A6 >::type make_function_eval(A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6) { return functional::make_function_eval()(a0 , a1 , a2 , a3 , a4 , a5 , a6); } template <typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7> inline typename result_of:: make_function_eval< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 >::type make_function_eval(A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7) { return functional::make_function_eval()(a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7); } } } } namespace boost { namespace phoenix { template <typename Dummy> struct meta_grammar::case_< :: boost :: phoenix :: detail :: tag:: function_eval , Dummy > : enable_rule< :: boost :: phoenix :: detail :: rule:: function_eval , Dummy > {}; } }

/* function_eval_expr_10.hpp
3dh56bWW1S2UK8htbaiaKdcslfUF6maUzKtuaqg4eBEfcxB+HdS3f6imel5DaUNqjKHB+kZmUju/tnRhRWP1/FqGSfHXiGC72lKktSJUwcyX1tdV1zbJ804wfefc1ACLl1fMWzTffmvCSLt+5o/0V1Y0sABvjQ2hxVxOztXO8PFB9r9KeFb2OtdncGZ5da2UD3Xl5RU1FU0V5SG7xFBNRe18JII1evWLmywDzS+t1y1Ex8iim5bWVziZKpuXlr9Nti/EXVjRVFVX7u6iDjWielKyZ5fdWH2o8FiOSS2aHsyuKpTq07C4NK2nAvUVVX7d0EDdPMYtm1dTV7ZAxlZrSNFTaKXLZ830ygfp8sqGuoWhRbULS2t5RLnQrN/6UENFU2l1bai0vr68biF/pWkxQvcpczSoa2yC8A0QT/hyolpHRWnTQaGmqkW1C0KOSLbeDHL0rSltbHT7IGNLeT38RO9UzYYG5HCcyOFQ5LAh4i42TpTF4lWtca4B5R51vs3YxmXriZQMDtRC5C/rXY2JRGcokbr+OvWnd2fz1iP8OycnGv/ezW2l3P69nfvb/+7VNvx3L7+3t79Rmkl+8gZlfvdq+IhU3xHSdyx9B6m+jOn1yZPbiUdJn9GB56k+/M7+vB2k71jpe5bJ+E7WymTqm2sb0neIDnJlbe5aWls2kn5DTXNra8i/43gMZduaNj4YSKG6j3WEa9ccb5ey/BFyx2zCNfTaFUiZbbm/fJ+nYIS+dzrcm0jy/WY7FS5e7Yil7tDsU8puZb9DvbUjva3uL9q1qXuj5cuj3RbXpMsGuW88ZpYNdWXN3a1ec/87ONuauK006f/ezsRtKzNX7tEuUusZYZKdiRDNmzvbE+mJZRYNcId2ZHlPKBzt4SvHfIB6Zbp7sDR9X/t42edZ/Y7V1RoYx5XoMXaSMbJ/HzHMXbF6BPlv1X+S9J/bv8xFEva7IOkhVJGWwZ1lnKNl7yY4mka6w6EVcT7pbR+aor+74zZVZjfB+16E5V03X/+u5F0c78rDMr4tFemJhTvMQbJ/u6r94/5tdquY76Hx3ZLuBF9E8T+yuCh7Vf/7+T/wtqXBd4QGU4UGu7l52SYJ48us+28+pdvrMP88ueN8d7WGoX2fm8j+4ISb+5d5Hk6vsSAiNK+isq6hQuymlNUtEJteLgVlDXytoaamzhrr6sqlIYtdKhqbxNblGb9ZY8NiaSt2S9WVVTQ47O1sf6Dc4rymRY3uuVupugUVS0MVh5RVpfsNCfZjKum6ocF5lIMaZY7DdF1Fo0McfFV1QYXY1631uFWltfMFA2yjyiura6sbq7CM8rxtvbolWMDaJr3u7VSdXvf2qjy4tuGBPqHFDZVLPVyn6tT8Rqry2opDmnBQ6ppkDqNUXXDuo9N1jUtkayGkPGuMV9fQZ107mHLVsX+eGKvGD/JEvqrTtClQ5UHajFN1wX0vVHXBfS9Sa9HP2lGVB581XtUF92GCqtP0Pn+v4px753yXrDdidp9uE8uZNGLBnUX3vbLduatvm0zZNPtlNXeN9jT74YqEmZaIh6d1uO8BtfDxmWUmz9l1Y+wIhSLdI/kJGTSFtURSNlh+P3/wjJxv/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f9v/f//p/9fBrpuqguFOyPN8ZA1obTHno91X8Oy7zo21IcWg17aVoVKQ12x1lCt8eq7pb6suTMccp/Ri4eWRVaZUar/vNpQb7irx4yVstZUWTQRWh2Jx8yGKVIek7HC9ivdoWXdsRXdofbakPsgnOAl126vvQ7n/3yFshslvWfxXsV7TW87nD8PTxaHkvFwZC++21s=
*/