// Copyright David Abrahams 2006. Distributed under the Boost
// Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
#ifndef BOOST_ARCHIVE_DETAIL_REGISTER_ARCHIVE_DWA2006521_HPP
# define BOOST_ARCHIVE_DETAIL_REGISTER_ARCHIVE_DWA2006521_HPP

namespace boost { namespace archive { namespace detail {

// No instantiate_ptr_serialization overloads generated by
// BOOST_SERIALIZATION_REGISTER_ARCHIVE that lexically follow the call
// will be seen *unless* they are in an associated namespace of one of
// the arguments, so we pass one of these along to make sure this
// namespace is considered.  See temp.dep.candidate (14.6.4.2) in the
// standard.
struct adl_tag {};

template <class Archive, class Serializable>
struct ptr_serialization_support;

// We could've just used ptr_serialization_support, above, but using
// it with only a forward declaration causes vc6/7 to complain about a
// missing instantiate member, even if it has one.  This is just a
// friendly layer of indirection.
template <class Archive, class Serializable>
struct _ptr_serialization_support
  : ptr_serialization_support<Archive,Serializable>
{
    typedef int type;
};

#if defined(__SUNPRO_CC) && (__SUNPRO_CC < 0x5130)

template<int N>
struct counter : counter<N-1> {};
template<>
struct counter<0> {};

template<class Serializable>
void instantiate_ptr_serialization(Serializable* s, int, adl_tag) {
    instantiate_ptr_serialization(s, counter<20>());
}

template<class Archive>
struct get_counter {
    static const int value = sizeof(adjust_counter(counter<20>()));
    typedef counter<value> type;
    typedef counter<value - 1> prior;
    typedef char (&next)[value+1];
};

char adjust_counter(counter<0>);
template<class Serializable>
void instantiate_ptr_serialization(Serializable*, counter<0>) {}

#define BOOST_SERIALIZATION_REGISTER_ARCHIVE(Archive)                     \
namespace boost { namespace archive { namespace detail {                  \
    get_counter<Archive >::next adjust_counter(get_counter<Archive >::type);\
    template<class Serializable>                                          \
    void instantiate_ptr_serialization(Serializable* s,                   \
        get_counter<Archive >::type) {                                    \
        ptr_serialization_support<Archive, Serializable> x;               \
        instantiate_ptr_serialization(s, get_counter<Archive >::prior()); \
    }\
}}}


#else

// This function gets called, but its only purpose is to participate
// in overload resolution with the functions declared by
// BOOST_SERIALIZATION_REGISTER_ARCHIVE, below.
template <class Serializable>
void instantiate_ptr_serialization(Serializable*, int, adl_tag ) {}

// The function declaration generated by this macro never actually
// gets called, but its return type gets instantiated, and that's
// enough to cause registration of serialization functions between
// Archive and any exported Serializable type.  See also:
// boost/serialization/export.hpp
# define BOOST_SERIALIZATION_REGISTER_ARCHIVE(Archive)                  \
namespace boost { namespace archive { namespace detail {                \
                                                                        \
template <class Serializable>                                           \
typename _ptr_serialization_support<Archive, Serializable>::type  \
instantiate_ptr_serialization( Serializable*, Archive*, adl_tag );              \
                                                                        \
}}}
#endif
}}} // namespace boost::archive::detail

#endif // BOOST_ARCHIVE_DETAIL_INSTANTIATE_SERIALIZE_DWA2006521_HPP

/* register_archive.hpp
+hxtiStuNre16RLux7pczsieS9UfrUg717taPP+ShcqhvhUYQqclUxVLsf7LTn36DtEzzvxxrhE3uHjj7q+3PjET4T9ItWhCf/ve2s35NDfVapivjI0XD268GibssqlX7FkulaZL0nJf8bf4tpz2OjbNWir/MuvC2XHhRf1vVOKDK9Jp82WtLDjzJ3W6Lbe/v7vxwbF2OoclcUHvvsh6hX9qme5/Wuvz6X7nZwvJjojJ/DZl0ZEEyx7hZXiDgqpRvakCo+gGKr3jGn4Pi+6y6s/1akoy5g803DLev6417JXDoazHlpsE68bFqj+EMCZt3/rQmpXKjhE7wJfWYRPZ6G44NT5VSf2xss1XSedJ7sPdjPFcRSyt2U88chcwf9rz3KCttaPnziplg4UPTjTqG7I69L7qKr0VjEtetcCofOf0iWPhq7tx+t7J/tQvKjncrelabe3wubtj1S6M5Vkexb8rv/HE12ZKYlBTWzZJ8pBM/lrnEP8QpZk4TerrY267BxQYz/CqiNCf0FAr3OXgzCbKdLfatDZy4lyojyNOe0k0u/u6V2I8ucS82Ctcrembi3g4fdhir51LE9t2o2lfT/I+9Wb1JW3vn4fpVbdrfegZd9Sw5xpacoTpfjqfRaCzqdpEkAHXqUPVdeHUpU7E+rrc8aYDDp5m8dh0/7Pq7a/NSqmkKjJNpNKH36toCRI5THjX8hCnxuealmspCUVJtGqtny2wUjq2ZCWdR/EFE4enrC+CBI+7ctnu9nDIGTYK0WZSC+PTUPS+/uWz29wt9zLqlVEGrhNX1mRvM6USYRKbnpTbsnFFBvPRHTf2lvc/sXRhVOhk20OXkNG6n+faE/4pz54pu+AAVyzh4+MGo9LpcGFr2h3jM1OsTn7nUlKytumK2A2aXHjj9spP8qptk6i1bCbrxpA1X7q5rE4VrMLaZk4mCNU9LeOfs16rpu9aSp/87gyh6wOf5u233AxUGwofSN7h+CI4EMRkGK5pzuKq72veljHndnCbum4OY8d2+5b+wdHzMR+nXtldXWulcWHXET/p1/2M7Ql5qtZUxSZvRq7q6q83Y0oue/M6tfO84VjQ7dA3FoWX8pfLlx7sWD8dMy6XExGB03wnXSK7rLytmn4SfrW25/QQ44XN3Su1HrU+9LRSTdVYdnLphSc7a7/s4FqaasmdMiTeHpziqJHBtAMXnpF4AyMat8+SykLk9Csz5vGazaMe69Yve9KwdIS1vonhwTQRm9Hgu0x5NvsSXXxbt+1AXXOpy+Z0cVkNNb9dSi232ipZiuwvL5NnfP62KDm7vl1Tl9lKi+rcFhPl2yX4QxYsa+ue+xSFOzsOmd9f2N9+5r1M9MtdJlHRLWOvdQMKLRNTGWuGXi+PuLFLZGXg8Su6pRviywQ2KXTvVOWklx8641A5MPq8Lnbmur2g/4WLSpVM53w7GTJOXHp08IjxpVw+QYkUmzN6RwOsHUVvPt4UXK6rvzHiy9G+MqHio+Z5ZesE6zUcrwqFxWdmEtpLdPs/OfZ7zFoNWshkLrwrtuHYIE/qwCIXf83PPow1p8t6olOo2FNdPZv9yoX3t2mfXjEQUSeS8CZZerZsg0ehvTqtaWKokKBCzb3aUoO74leizbWrDk4ali4QfF3mENeUYHxfq7zy/arTBxpVUvwW1c2tdvAeO/oig/6uurPESv6J0JWcMsIRQ30nsqWl31f7ctxwEZPtcRay0XiWORhBzTnON2q+Se512GW3qfRxXY2NLhZsCdhoGzd1hpaP+Tof1uxbKTO9Mczh067yxxd9rohz2GWcpHl44MuiqiyG1s8S9wSY7ox1RniUvjaV1o5Rq12yzTW6gU4s5Mk=
*/