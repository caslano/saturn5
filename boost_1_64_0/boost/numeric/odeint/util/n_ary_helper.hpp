/*
 [auto_generated]
 boost/numeric/odeint/util/n_ary_helper.hpp

 Macros to generate scale_sumN and for_eachN functors.

 Copyright 2013 Karsten Ahnert
 Copyright 2013 Mario Mulansky
 Copyright 2013 Pascal Germroth

 Distributed under the Boost Software License, Version 1.0.
 (See accompanying file LICENSE_1_0.txt or
 copy at http://www.boost.org/LICENSE_1_0.txt)
 */

#ifndef BOOST_NUMERIC_ODEINT_UTIL_N_ARY_HELPER_HPP_INCLUDED
#define BOOST_NUMERIC_ODEINT_UTIL_N_ARY_HELPER_HPP_INCLUDED

#include <boost/preprocessor/repetition.hpp>

// like BOOST_PP_ENUM_SHIFTED but with a comma in front like _TRAILING
#define BOOST_ODEINT_ENUM_TRAILING_SHIFTED_PARAMS(count, param) \
    BOOST_PP_COMMA_IF(BOOST_PP_DEC(count)) \
    BOOST_PP_ENUM_SHIFTED_PARAMS(count, param)

#define BOOST_ODEINT_ENUM_TRAILING_SHIFTED_BINARY_PARAMS(count, p1, p2) \
    BOOST_PP_COMMA_IF(BOOST_PP_DEC(count)) \
    BOOST_PP_ENUM_SHIFTED_BINARY_PARAMS(count, p1, p2)

// like BOOST_PP_ENUM_SHIFTED_BINARY_PARAMS(n, p1, p2) but p2 is shifted left.
// generate "p1 ## 0 = p2, p1 ## 1 = p3 ## 0, p1 ## 2 = p3 ## 1"
#define BOOST_ODEINT_ENUM_LSHIFTED_BINARY_PARAMS(count, p1, p2, p3) \
    BOOST_PP_ENUM(count, BOOST_ODEINT_ENUM_LSHIFTED_BINARY_PARAMS_, (p1, p2, p3))
#define BOOST_ODEINT_ENUM_LSHIFTED_BINARY_PARAMS_(z, n, data) \
    BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(3, 0, data), n) \
    BOOST_PP_IF(n, \
        BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(3, 2, data), BOOST_PP_DEC(n)), \
        BOOST_PP_TUPLE_ELEM(3, 1, data))

// like BOOST_PP_ENUM_BINARY_PARAMS(n, p1, p2) but with statements.
// "p1 ## 0 p2 ## 0 ; p1 ## 1 p2 ## 1 ; ..."
#define BOOST_ODEINT_ENUM_BINARY_STATEMENTS(count, p1, p2) \
    BOOST_PP_REPEAT(count, BOOST_ODEINT_ENUM_BINARY_STATEMENTS_, (p1, p2))
#define BOOST_ODEINT_ENUM_BINARY_STATEMENTS_(z, n, data) \
    BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(2, 0, data), n) \
    BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(2, 1, data), n) ;

// like BOOST_PP_ENUM_BINARY_PARAMS(n, p1, p2) but p2 is in parens.
// "p1 ## 0 (p2 ## 0) , p1 ## 1 (p2 ## 1) , ..."
#define BOOST_ODEINT_ENUM_UNARY_CALLS(count, p1, p2) \
    BOOST_PP_ENUM(count, BOOST_ODEINT_ENUM_UNARY_CALLS_, (p1, p2))
#define BOOST_ODEINT_ENUM_SHIFTED_UNARY_CALLS(count, p1, p2) \
    BOOST_PP_ENUM_SHIFTED(count, BOOST_ODEINT_ENUM_UNARY_CALLS_, (p1, p2))
#define BOOST_ODEINT_ENUM_TRAILING_SHIFTED_UNARY_CALLS(count, p1, p2) \
    BOOST_PP_COMMA_IF(BOOST_PP_DEC(count)) \
    BOOST_PP_ENUM_SHIFTED(count, BOOST_ODEINT_ENUM_UNARY_CALLS_, (p1, p2))
#define BOOST_ODEINT_ENUM_UNARY_CALLS_(z, n, data) \
      BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(2, 0, data), n) \
    ( BOOST_PP_CAT(BOOST_PP_TUPLE_ELEM(2, 1, data), n) )


// maximum arity + 1 for scale_sum and for_each
#define BOOST_ODEINT_N_ARY_MAX 16


// generate scale_sum1 to scale_sumN, operator body generated by macro(N)
#define BOOST_ODEINT_GEN_SCALE_SUM(macro) \
    BOOST_PP_REPEAT_FROM_TO(1, BOOST_ODEINT_N_ARY_MAX, BOOST_ODEINT_GEN_SCALE_SUM_, macro)
#define BOOST_ODEINT_GEN_SCALE_SUM_(z, n, macro) \
    template< BOOST_ODEINT_ENUM_LSHIFTED_BINARY_PARAMS(n, class Fac, = double, = Fac) > \
    struct BOOST_PP_CAT(scale_sum, n) \
    { \
        BOOST_ODEINT_ENUM_BINARY_STATEMENTS(n, const Fac, m_alpha) \
        \
        BOOST_PP_CAT(scale_sum, n) \
        ( BOOST_PP_ENUM_BINARY_PARAMS(n, Fac, alpha) ) \
        : BOOST_ODEINT_ENUM_UNARY_CALLS(n, m_alpha, alpha) {} \
        \
        template< BOOST_PP_ENUM_PARAMS(BOOST_PP_INC(n), class T) > \
        void operator()( T0 &t0 \
            BOOST_ODEINT_ENUM_TRAILING_SHIFTED_BINARY_PARAMS(BOOST_PP_INC(n), const T, &t) \
        ) const \
        { macro(n) } \
        typedef void result_type; \
    };

// generate for_each1 to for_eachN, body generated by macro(N)
#define BOOST_ODEINT_GEN_FOR_EACH(macro) \
    BOOST_PP_REPEAT_FROM_TO(1, BOOST_ODEINT_N_ARY_MAX, BOOST_ODEINT_GEN_FOR_EACH_, macro)
#define BOOST_ODEINT_GEN_FOR_EACH_(z, n, macro) \
    template< BOOST_PP_ENUM_PARAMS(n, class S) , class Op > \
    static void for_each##n ( BOOST_PP_ENUM_BINARY_PARAMS(n, S, &s) , Op op ) \
    { macro(n) }


#endif

/* n_ary_helper.hpp
fimW1hGVPTR3J7905XEiPDI7eWTAAx2LDJIiNy7iOBzttSVc5G6FNDucvO6aPzIiRv9C7ujVPt0dHKx9aDcb614LTJco8lLDPbKxlMLumk8lxjSKfxtOMeIPUMFzwSwdcqXdvW7ICrlrm2USRUBua0qjj2ltSrPD9s8W3NB6mv1MMuwW3J0k0O8XP0ZPrkzR20UNDNqu2Va3uBom/4NsL7EQRqWOpSxUQBdLoNSn7bPGh+rJ98Q1HQzzYwA2pVkl3RgxfdELEIcH1sQHSFnZxAkSpnsmBkZvabQfez8XVHP+4HKzK5nnnzFFVUaNW3acTXjlMTbTIF5fbZYC9yWaYrVuHlLaAh+dEhivqp3ZZS+EnYPlwexfwIe9W1ZXt495n3Fez0C+JFXk9QmmonOF0/TrWSNpNBe79evdyuIMFzt128xwqVu3Qa9jU5Fi2fVs7B6+MxG+g/AJJq0TyM6JEb6T8N08+NA9/M7jvfaemDzpoFRVw0c+LZN+2Hl/2uOuzvaP7uxs/yTJbr2nsz01Cd6mpPBvJIVfluT/dlL6tUn+P0mKf2mCvzmfuaUKCoduG5q8pCn6lB+0mQvUwhYYTrFZ252J8mP94NJ2hyLSZATSKTH2gWRlYowfja6h5IUa1yl9EznZO8g2RRKhQynY/RxKC/ZYZ1U83UzeUoceMBHZHYMzZG558dYOEN3/ClsGiO7vwSUjhBeb2P42ST3O1z+haNBHgIGgqfq1bhy7u9aJQOMtep+qExBkfB4uh64l4ablYaSktDT05cHb2mlO/ApdS39sle7DlPuw2mlu5b5CuY9Q7iNqp3mU+zzlnqPcc2qnZSj3y5V7roVW6ZebNy1T+tWOgd+agVDwVDRsEPK9ZqBr6VA46TRnBVymc5ZrKWlZFFgZHlpEmmyq1ThOzw9W5heoYH2KUpSBGgrPtLdgVkcMEEBljKW/tnSOcVfnGC1Py+ApwfNU8IeSgvfoHNwQRWi5BR822CDGCsxLjPHbQ51itFaEDtmC3rzXgz10n5NN2dpDvwxKbajpNa8jmK4vko0LDrsCzrZL04vdGNAIR4sMC1+nkoJgJ1LNjX6SJy9gSAHTlT0mzM49MZxriteE3eEx/0WiNqy2A5gD8brxevBmEJ3AGn0C5ckxy0Fnil2f7IReg79JBhlG5KRy33r39TjIu0q/6bBu0+fZ9csp55xWCx5U4MzaBphALQhkctKs5YUGJ9TugQmdHgrqx+6XMENb8kMfWIO/xOreJMmfxyX4bzwV+vuhffvrB3OUv/ksmAoTssqz95iiGr45rusa5rjmNlj8rrORoVFXOF23Xm6jFhU3j6zq7foER7leOCO6y2Q4zYc8d+B68bvv2SwsRlvxMHfwKn2Cu7bYGbxcn+CpLXZDpcKEjNpiT/BifUJmbXFGcCygxG8oSh1VnBk4l5GpRypwRnjBfgpdFjeVHJa9KV1+Sz7mL9TkCcOv1c4Q4/KQvZVYZ6NgUN/6NEcn83hFljpOBxFc160hjsZxHkwn+PuilEwZG837revWmRy17Q7XkmwaCkZ8J9Vtc608k6S1IadaVtrdRIirb0wtDTW3F7qG9M+CE65IGvKNwVlDmzn9RS7JpUwaaqwpUmJHpTVbImFyMua4Ol7E5dRzXLmFL8C80zVkM34wLgqXIq9zXJ9ugblmojTfsNuOzxt2usyGC0PNOMInYPjMTfYpWo7PRUuNZmuWaScnzBB3GakWre4c/Ql6PtrZbSvdGjq77abba3kdrpVOZIGVn/fpLQMik6w4Vee8LeLUI0W/D1sjRfZw0eHIRZ7Qe9bgBxH72ogzFCnaDTdl1icMbipql22z+f1whj5hSNjB0y0=
*/